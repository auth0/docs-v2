import * as React from 'react';
import React__default, { createContext, forwardRef, createElement, useLayoutEffect, useMemo, useCallback, useState, useEffect, useContext } from 'react';
import * as ReactDOM from 'react-dom';
import ReactDOM__default from 'react-dom';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useForm, FormProvider, Controller, get, set, appendErrors, useFormContext, useFormState } from 'react-hook-form';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../core/dist/chunk-Z45QNK2S.mjs
var d;
var init_chunk_Z45QNK2S = __esm({
  "../core/dist/chunk-Z45QNK2S.mjs"() {
    d = (c) => (a4) => {
      var b2 = c[a4];
      if (b2) return b2();
      throw new Error("Module not found in bundle: " + a4);
    };
  }
});

// ../core/dist/en-US-WLJW6PYP.mjs
var en_US_WLJW6PYP_exports = {};
__export(en_US_WLJW6PYP_exports, {
  common: () => i,
  default: () => l,
  domain_management: () => o,
  idp_management: () => n,
  mfa: () => r,
  org_management: () => a
});
var i, o, a, n, r, l;
var init_en_US_WLJW6PYP = __esm({
  "../core/dist/en-US-WLJW6PYP.mjs"() {
    init_chunk_Z45QNK2S();
    i = { copy: "Copy", copied: "Copied!" };
    o = { domain_table: { header: { title: "Domains", description: "Add a domain to enhance security and streamline login by directing users to your identity provider based on their email domain.", create_button_text: "Add Domain" }, table: { empty_message: "You do not have any domains.", columns: { domain: "Domain Name", status: "Status" }, actions: { configure_button_text: "Configure", view_button_text: "View", verify_button_text: "Verify", delete_button_text: "Delete" } }, notifications: { general_error: "There was an issue processing your request. Please try again or contact support if the issue persists.", fetch_providers_error: "There was an issue fetching providers. Please try again or contact support if the issue persists.", fetch_domains_error: "There was an issue fetching domains. Please try again or contact support if the issue persists.", domain_create: { success: "${domainName} has been created.", error: "There was an issue creating the domain.", on_before: "Domain is not valid." }, domain_verify: { success: "${domainName} has been verified.", error: "There was an issue verifying the domain.", on_before: "Domain verify validation is not correct.", verification_failed: "${domainName} could not be verified. Please wait and try again or check with your DNS provider." }, domain_delete: { success: "${domainName} has been deleted.", error: "There was an issue deleting the domain." }, domain_associate_provider: { success: "${domainName} enabled for ${idp} provider.", error: "There was an issue associating the domain to the provider.", on_before: "Domain associate to provider validation is not correct." }, domain_delete_provider: { success: "${domainName} disabled for ${idp} provider.", error: "There was an issue removing the domain from the provider.", on_before: "Domain delete from provider validation is not correct." } } }, domain_create: { modal: { title: "Add a Domain", field: { label: "Domain URL", placeholder: "domain-name.com", error: "Please enter a valid domain" }, actions: { cancel_button_text: "Cancel", create_button_text: "Add Domain" } } }, domain_configure_providers: { modal: { title: "Configure ${domain}", description: "Direct users with an ${domain} email domain to your identity provider for authentication for the selected providers.", table: { empty_message: "You do not have any providers.", columns: { name: "Name", provider: "Identity Provider" }, actions: { add_provider_button_text: "Add a Provider", view_provider_button_text: "View" } }, actions: { close_button_text: "Close" } } }, domain_delete: { modal: { title: "Delete a Domain", description: { pending: "${domainName} is pending verification and may take up to 48 hours to process. Are you sure you want to delete this domain?", verified: "Deleting ${domainName} may disrupt login flows for users. Are you sure you want to delete this domain? This action cannot be undone." }, actions: { cancel_button_text: "Cancel", delete_button_text: "Delete" } } }, domain_verify: { modal: { title: "Add DNS records for ${domainName}", txt_record_name: { label: "TXT Record Name" }, txt_record_content: { label: "TXT Record Content" }, verification_status: { label: "Verification Status:", pending: "Pending", description: "Your domain is pending verification. Click 'Verify' to refresh the status, or check back later. DNS changes may take up to 48 hours, but typically process faster." }, actions: { verify_button_text: "Verify", delete_button_text: "Delete", done_button_text: "Done" }, errors: { verification_failed: "${domainName} could not be verified. Please wait and try again or check with your DNS provider." } } }, shared: { domain_statuses: { pending: "Pending", verified: "Verified", failed: "Failed" } } };
    a = { org_details: { sections: { settings: { title: "Settings", fields: { name: { label: "Name", placeholder: "Enter organization name", helper_text: "A human-readable identifier for the organization, used by end users to direct them to their organization in your application.", error: "Please enter a valid organization name" }, display_name: { label: "Display Name", placeholder: "Enter display name", helper_text: "The name displayed to end users of this organization.", error: "Please enter a valid display name" } } }, branding: { title: "Branding", fields: { logo: { label: "Organization Logo", helper_text: "The logo that will be displayed to end-users for this organization in any interaction with them.", error: "Please enter a valid HTTPS URL for the logo" }, primary_color: { label: "Primary Color", helper_text: "The primary color for buttons displayed to end users of this organization in your application's authentication flows.", error: "Please enter a valid color format" }, page_background_color: { label: "Page Background Color", helper_text: "The page background color displayed to end users of this organization in your application's authentication flows.", error: "Please enter a valid color format" } } } }, unsaved_changes_text: "Unsaved changes", submit_button_label: "Save", cancel_button_label: "Discard" }, org_delete: { title: "Delete ${orgName}", description: "Once confirmed, this operation cannot be undone.", delete_button_label: "Delete", modal_title: "Delete ${orgName}", modal_description: "Are you sure you want to delete ${orgName}? Users will be maintained but membership to this organization will be removed. Once confirmed, this action cannot be undone.", org_name_field_placeholder: "Type in the organization name", org_name_field_label: "Organization Name", org_name_field_error: 'Please type "${orgName}" to confirm deletion', cancel_button_label: "Cancel" }, org_details_edit: { header: { back_button_text: "Back to Organizations", title: "${orgName}" }, save_org_changes_message: "The changes have been saved for ${orgName}.", org_changes_error_message: "There was an issue processing your request. ${message}.", org_changes_error_message_generic: "There was an issue processing your request. Please try again or contact support if the issue persists." } };
    n = { sso_provider_table: { header: { title: "Single Sign-On", description: "Set up and manage SSO access for your organization.", create_button_text: "Add Provider" }, table: { empty_message: "You do not have any providers.", columns: { name: "Name", identity_provider: "Identity Provider", display_name: "Display Name" }, actions: { edit_button_text: "Edit", delete_button_text: "Delete", remove_button_text: "Remove from organization" } }, create_consent_modal: { title: "Before creating the provider, please note:", description: "Creating this provider will enable SSO access to ${organizationName}. To prioritize security, assign access and test the provider as soon as possible once the provider is active.", actions: { cancel_button_text: "Cancel", process_button_text: "Proceed" } } }, create_sso_provider: { steps: { one: "Identity Provider", two: "Provider Details", three: "Configure Provider" }, header: { title: "Add a Provider", back_button_text: "Back to Single Sign-On" }, nextButtonLabel: "Next", previousButtonLabel: "Back", completeButtonLabel: "Create Provider", notifications: { general_error: "There was an issue processing your request. Please try again or contact support if the issue persists.", provider_create_success: "${providerName} has been created.", provider_create_duplicated_provider_error: "${providerName} provider already exists. Please choose a different name." }, provider_select: { title: "Select Your Identity Provider", description: "Choose the identity provider you plan to integrate with Auth0 to access step-by-step configuration instructions." }, provider_details: { title: "Provider Details", description: "Provide a recognizable name and a permanent identifier to help you manage and reference this provider later.", fields: { name: { label: "Name", placeholder: "Enter an identifier", helper_text: "A human-readable identifier for the provider. This cannot be changed.", error: "Please enter a valid organization name" }, display_name: { label: "Display Name", placeholder: "Enter display name", helper_text: "The name displayed to end users of this provider.", error: "Please enter a valid display name" } } }, provider_configure: { title: "Configure Provider", description: "Establish a connection between your identity provider and Auth0.", fields: { common: { show_as_button: { label: "Show as button", helper_text: "Display this connection as a button on the login page" }, assign_membership_on_login: { label: "Assign membership on login", helper_text: "Automatically grant organization membership to users who log in through this connection" } }, okta: { domain: { label: "Okta Domain", placeholder: "domain-name.okta.com", helper_text: "<link>Where do I find the Okta Domain?</link>", error: "Please enter a valid Okta domain" }, client_id: { label: "Client ID", placeholder: "Enter your client ID", helper_text: "Unique identifier for client application or service integration. <link>Where do I find the Client ID?</link>", error: "Please enter a valid client ID" }, client_secret: { label: "Client Secret", placeholder: "Enter your client secret", helper_text: "Confidential token used for client authentication. <link>Where do I find the Client Secret?</link>", error: "Please enter a valid client secret" }, callback_url: { label: "Callback URL", placeholder: "https://staff0.local.dev.auth0.com/login/callback", helper_text: "You may need to configure the Okta tenant with this callback URL.", error: "Please enter a valid URL" } }, "google-apps": { domain: { label: "Google Workspace Domain", placeholder: "your-google-workspace-domain.com", error: "Please enter a valid Google Workspace domain" }, client_id: { label: "Client ID", placeholder: "Enter your client ID", helper_text: "Unique identifier for client application or service integration.", error: "Please enter a valid client ID" }, client_secret: { label: "Client Secret", placeholder: "Enter your client secret", helper_text: "Confidential token used for client authentication.", error: "Please enter a valid client secret" }, callback_url: { label: "Callback URL", placeholder: "https://staff0.local.dev.auth0.com/login/callback", helper_text: "You may need to configure the Google Workspace tenant with this callback URL.", error: "Please enter a valid URL" } }, waad: { tenant_domain: { label: "Microsoft Entra ID Domain", placeholder: "your-entra-id-domain.com", error: "Please enter a valid Microsoft Entra ID domain" }, client_id: { label: "Client ID", placeholder: "Enter your client ID", helper_text: "Unique identifier for client application or service integration.", error: "Please enter a valid client ID" }, client_secret: { label: "Client Secret", placeholder: "Enter your client secret", helper_text: "Confidential token used for client authentication.", error: "Please enter a valid client secret" }, callback_url: { label: "Callback URL", placeholder: "https://staff0.local.dev.auth0.com/login/callback", helper_text: "You may need to configure the Entra ID tenant with this callback URL.", error: "Please enter a valid URL" } }, oidc: { discovery_url: { label: "OpenID Provider Configuration Endpoint", placeholder: "https://example.com/.well-known/openid-configuration", helper_text: "Enter the URL of the discovery document of the OpenID Connect provider you want to connect with.", error: "Please enter a valid discovery URL" }, type: { label: "Communication Channel", helper_text: "Select whether authentication exchanges occur via server-to-server communication (Back Channel) or through the browser using Implicit Flow with Form Post (Front Channel).", options: { back_channel: { label: "Back Channel" }, front_channel: { label: "Front Channel" } } }, client_id: { label: "Client ID", placeholder: "Enter your client ID", helper_text: "Unique identifier for client application or service integration.", error: "Please enter a valid client ID" }, client_secret: { label: "Client Secret", placeholder: "Enter your client secret", helper_text: "Confidential token used for client authentication.", error: "Please enter a valid client secret" } }, samlp: { meta_data_source: { label: "Metadata Source", options: { meta_data_url: { label: "Metadata URL" }, meta_data_file: { label: "Metadata File" } } }, meta_data_url: { label: "Metadata URL", placeholder: "https://example.com/samlp/metadata.xml", helper_text: "Location to retrieve SAML SSO connection information for integration.", error: "Please enter a valid metadata URL" }, single_sign_on_login_url: { label: "Single Sign-On Login URL", placeholder: "https://example.com/idp/saml/", helper_text: "Endpoint for initiating secure authentication in SAML SSO connections.", error: "Please enter a valid SSO login URL" }, cert: { label: "Signing Certificate", placeholder: "Upload Signing Certificate", helper_text: "SAML X.509 public key encoded in PEM or CER format.", error: "Please upload a valid signing certificate" }, advanced_settings: { title: "Advanced Settings", sign_request: { label: "Sign Request", helper_text_metadata_file: "When enabled, the SAML authentication request will be signed. Download the\xA0<link>certificate</link> and provide it to the SAMLP that will receive the signed assertion to validate the signature. This needs to be enabled first in the SAMLP. Once enabled, share the metadata URL for integration.", helper_text_metadata_url: "When enabled, the SAML authentication request will be signed. Download the\xA0<link>certificate</link> and provide it to the SAMLP that will receive the signed assertion to validate the signature." }, request_protocol_binding: { label: "Request Protocol Binding", placeholder: "HTTP-Post", helper_text: "The SAML protocol binding to use for authentication requests.", error: "Please select a protocol binding" }, sign_request_algorithm: { label: "Sign Request Algorithm", placeholder: "RSA-SHA256", helper_text: "The algorithm used to sign SAML authentication requests.", error: "Please select a signing algorithm" }, sign_request_algorithm_digest: { label: "Sign Request Algorithm Digest", placeholder: "SHA256", helper_text: "The digest algorithm used for SAML request signing.", error: "Please select a digest algorithm" } }, icon_url: { label: "Icon URL", placeholder: "Enter icon URL", helper_text: "URL for the provider icon displayed to users.", error: "Please enter a valid URL" } }, adfs: { meta_data_source: { label: "ADFS Metadata Source", options: { meta_data_url: { label: "ADFS URL" }, meta_data_file: { label: "Metadata File" } } }, meta_data_url: { label: "Metadata URL", placeholder: "https://example.com/FederationMetadata/2007-06/FederationMetadata.xml", helper_text: "Location to retrieve WS-Fed SSO connection information for integration.", error: "Please enter a valid metadata URL" }, meta_data_location_url: { label: "Metadata Location URL", placeholder: "https://HOSTNAME/FederationMetadata/2007-06/FederationMetadata.xml", helper_text: "Location to retrieve WS-Fed SSO connection information for integration.", error: "Please enter a valid metadata location URL" }, federation_metadata_file: { label: "Federation Metadata File", placeholder: "Upload Federation Metadata File", helper_text: "Digital credential used for secure identity authentication.", error: "Please upload a valid federation metadata file" }, upload_button_label: "Upload" }, "ping-federate": { ping_federate_baseurl: { label: "Single Sign-On Login URL", placeholder: "https://example.com/idp/SSO.saml2", helper_text: "Endpoint for initiating secure authentication in PingFederate SSO connections.", error: "Please enter a valid SSO login URL" }, sign_cert: { label: "Signing Certificate", placeholder: "Upload Signing Certificate", helper_text: "Digital credential used for secure identity authentication.", error: "Please upload a valid signing certificate" }, advanced_settings: { title: "Advanced Settings", sign_request: { label: "Sign Request", helper_text: "When enabled, the SAML authentication request will be signed. Download the\xA0<link>certificate</link> and provide it to the SAMLP that will receive the signed assertion to validate the signature. This needs to be enabled first in the SAMLP. Once enabled, share the metadata URL for integration.", error: "Please select an option" }, sign_request_algorithm: { label: "Sign Request Algorithm", placeholder: "RSA-SHA256", helper_text: "The algorithm used to sign SAML authentication requests to PingFederate.", error: "Please select a signing algorithm" }, sign_request_algorithm_digest: { label: "Sign Request Algorithm Digest", placeholder: "SHA256", helper_text: "The digest algorithm used for PingFederate request signing.", error: "Please select a digest algorithm" } } } } } }, edit_sso_provider: { header: { back_button_text: "Back to Single Sign-On", enable_provider_tooltip_text: "Toggle to enable the provider.", disable_provider_tooltip_text: "Toggle to disable the provider." }, tabs: { sso: { name: "Single Sign-On", content: { title: "Single Sign-On", description: "Manage and configure single sign-on.", alert: { warning: "User attribute mappings for single sign-on have been updated. Please review the attributes and update your identity provider configuration to avoid login issues." } } }, provisioning: { name: "Provisioning", content: { header: { title: "Provisioning", description: "Set up provisioning to allow user profile syncing to your organization.", guided_setup_button_label: "Guided Setup", enable_provisioning_tooltip: "Enable provider to create provisioning" }, warning_alert_message: { title: "Mappings for provisioning have been updated.", description: " Please review the attributes and update your identity provider configuration to ensure proper provisioning." }, delete: { modal: { title: "Disable provisioning", content: { description: "Are you sure you want to disable provisioning? This will permanently delete the provisioning configuration and revoke access for any clients using provisioning with this provider." }, actions: { cancel_button_label: "Cancel", delete_button_label: "Proceed" } } }, details: { manage_tokens: { title: "Bearer Tokens", description: "Generate a bearer token to provide your identity provider. You can create up to two tokens.", generate_button_label: "Generate Token", max_tokens_tooltip: "Maximum 2 tokens allowed", empty_state: { title: "No tokens created yet", description: "Generate a bearer token to authenticate SCIM requests from your identity provider." }, table: { token_id_label: "Token ID", created_label: "Created", expires_label: "Expires", actions_label: "Actions" }, token_item: { token_prefix: "Token", never_expire: "This token will never expire.", last_used: "Last used: Never", status_active: "Active", status_expired: "Expired", delete_button_label: "Delete" }, create_modal: { title: "Bearer Token Information", copy_and_close_button_label: "Copy and Close", content: { description: "Copy the bearer token to provide your identity provider. It will not be displayed again upon closing this dialog.", field: { label: "Token" } } }, delete_modal: { title: "Delete token ${tokenId}", cancel_button_label: "Cancel", delete_button_label: "Delete Token", content: { confirmation: "Are you sure you want to delete token ${tokenId}? This action cannot be undone.", description: "To avoid downtime, consider creating a second token and supplying it to your provisioning client before deleting this one." } } }, fields: { user_id_attribute: { label: "User ID Attribute", helper_text: "The attribute that uniquely identifies a user." }, scim_endpoint_url: { label: "SCIM Endpoint URL" }, external_namespace: { label: "External Namespace" } }, mappings: { title: "Mapping", description: "Ensure that the correct user attributes are passed from the identity provider to the service provider.", card: { title: "Required Attributes", description: "Ensure that a valid ${strategy} attribute is mapped to the following attributes.", table: { columns: { attribute_name_label: "Attribute Name", external_field_label: "External Field" } } } } } } }, domains: { name: "Domains", content: { title: "Domains", description: "Enhance security and streamline login by directing users to your identity provider based in their email domain.", create_button_text: "Add Domain", table: { empty_message: "You do not have any domains", columns: { name: "Domain Name", status: "Status", verify: "Verify" }, domain_statuses: { pending: "Pending", verified: "Verified", failed: "Failed" } }, domain_create: { modal: { title: "Add a Domain", field: { label: "Domain URL", placeholder: "domain-name.com", error: "Please enter a valid domain" }, actions: { cancel_button_text: "Cancel", create_button_text: "Add Domain" } } }, domain_delete: { modal: { title: "Delete a Domain", description: { pending: "${domainName} is pending verification and may take up to 48 hours to process. Are you sure you want to delete this domain? This action cannot be undone.", verified: "Deleting ${domainName} may disrupt login flows for users. Are you sure you want to delete this domain? This action cannot be undone." }, actions: { cancel_button_text: "Cancel", delete_button_text: "Delete" } } }, domain_verify: { modal: { title: "Add DNS records for ${domainName}", txt_record_name: { label: "TXT Record Name" }, txt_record_content: { label: "TXT Record Content" }, verification_status: { label: "Verification Status:", pending: "Pending", description: "Your domain is pending verification. Click 'Verify' to refresh the status, or check back later. DNS changes may take up to 48 hours, but typically process faster." }, actions: { verify_button_text: "Verify", delete_button_text: "Delete", done_button_text: "Done" }, errors: { verification_failed: "${domainName} could not be verified. Please wait and try again or check with your DNS provider." } } } } } }, provider_details: { save_button_label: "Save" } }, sso_provider_details: { unsaved_changes_text: "Unsaved changes", submit_button_label: "Save" }, delete_sso_provider: { title: "Delete this provider", description: "Once confirmed, this operation cannot be undone.", delete_button_label: "Delete", modal: { title: "Delete ${providerName}", description: "Users who sign in through this provider will lose access. The action cannot be undone. Are you sure you want to delete this provider?", content: { description: "Type in the name of the provider to confirm.", field: { label: "Provider Name", placeholder: "Type in the provider name" } }, actions: { cancel_button_label: "Cancel", delete_button_label: "Delete" } } }, remove_sso_provider: { title: "Remove this provider from the organization", description: "Once confirmed, this operation cannot be undone.", remove_button_label: "Delete", modal: { title: "Remove ${providerName} from ${organizationName}", description: "This will revoke access to ${providerName} for all users in this organization. Users will not be deleted but will no longer be able to sign in using this provider", content: { description: "Type in the name of the provider to confirm.", field: { label: "Provider Name", placeholder: "Type in the provider name" } }, actions: { cancel_button_text: "Cancel", remove_button_text: "Proceed" } } }, notifications: { delete_success: "${providerName} has been deleted.", remove_success: "${providerName} has been removed from ${organizationName}", update_success: "Changes to ${providerName} have been saved.", general_error: "There was an issue processing your request. Please try again or contact support if the issue persists.", domain_create: { success: "${domainName} has been created.", error: "There was an issue creating the domain.", on_before: "Domain is not valid." }, domain_verify: { success: "${domainName} has been verified.", error: "There was an issue verifying the domain.", on_before: "Domain verify validation is not correct.", verification_failed: "${domainName} could not be verified. Please wait and try again or check with your DNS provider." }, domain_delete: { success: "${domainName} has been deleted.", error: "There was an issue deleting the domain." }, domain_associate_provider: { success: "${domain} enabled for ${idp}" }, domain_delete_provider: { success: "${domain} disabled for ${idp}" }, provisioning_disabled_success: "Provisioning has been disabled.", scim_token_delete_sucess: "Token has been deleted.", scim_token_create_success: "Token generated successfully" } };
    r = { title: "Multi-Factor Authentication methods", description: "Extra protection for your account and your identity", no_active_mfa: "No active MFA factors enrolled.", component_error_title: "Error loading Multi-Factor Authentication component", component_error_description: `We're having trouble loading your multi-factor authentication methods.
Please refresh the page and try again`, loading: "Loading...", delete: "Delete", enroll: "Enroll", submit: "Submit", update: "Update", remove: "Remove", enrolling: "Enrolling...", enrolled: "Enrolled", enabled: "ENABLED", enrollment: "Enrollment", confirmation: "Confirmation", remove_factor: "Enrollment removed successfully.", enroll_factor: "Enrolled successfully.", enroll_totp_mfa: "Enroll OTP MFA", delete_factor: "Delete authenticator ${factorName}", delete_mfa_title: "Remove existing Authenticator", delete_mfa_phone_consent: "Are you sure you want to remove this Phone number for SMS?", delete_mfa_email_consent: "Are you sure you want to remove this Email?", delete_mfa_totp_consent: "Are you sure you want to remove this authenticator?", "delete_mfa_push-notification_consent": "Are you sure you want to remove this push notification?", "delete_mfa_recovery-code_consent": "Are you sure you want to remove this recovery code?", cancel: "Cancel", close: "Close", next: "Next", back: "Back", "yes-remove": "Yes, remove", ok: "Ok", "app-store": "App Store", "google-play": "Google Play", confirm: "Confirm", continue: "Continue", deleting: "Deleting...", errors: { factors_loading_error: "Error loading MFA factors!", unknown_error: "Unknown error occurred", delete_factor: "Delete authenticator failed", failed: "failed: ${message}", phone_number_required: "Phone number is required for SMS enrollment.", email_required: "Email is required for Email enrollment.", invalid_email: "Invalid email address", invalid_phone_number: "Invalid phone number", unsupported_mfa_type: "Unsupported MFA type: ${factorName}", "push-notification": { too_many_entities: "You reached the limit of entities of the push notification type for this user.", unsupported_challenge_type: 'Auth0 Verifier is disabled for your tenant. You can turn it on from dashboard turning on "Push notifications" on Guardian MFA section.', invalid_request: "Missing required parameter", authorization_pending: "Authorization pending: please repeat the request in a few seconds." }, totp: { invalid_request: "Missing required parameter", too_many_entities: "You reached the limit of entities of the totp type for this user.", unsupported_challenge_type: 'OTP Verifier is disabled for your tenant. You can turn it on from dashboard turning on "Push notifications" on Guardian MFA section (Push notications include OTP).', invalid_grant: "Invalid Otp Code" }, phone: { unsupported_challenge_type: 'SMS Verifier is disabled for your tenant. You can turn it on from dashboard turning on "SMS" on Guardian MFA section.', bad_gateway: "The phone number is invalid.", too_many_entities: "You reached the limit of entities of the sms type for this user." }, email: { expired_token: "Verification code is expired", invalid_grant: "Invalid Code", access_denied: "Could not find the requested authenticator", too_many_entities: "You reached the limit of entities of the email type for this user." } }, phone: { title: "Phone Message", description: "No phone number has been added.", "button-text": "Add Phone for SMS" }, "push-notification": { title: "Push Notification using Auth0 Guardian", description: "No push authentication has been added.", "button-text": "Add Push Authentication" }, totp: { title: "One-time Password", description: "No authenticator has been added.", "button-text": "Add Authenticator App" }, email: { title: "Email", description: "No email has been added.", "button-text": "Add Email" }, duo: { title: "Duo Security", description: "Use your DUO account for Multi-factor Authentication." }, "webauthn-roaming": { title: "WebAuthn with FIDO Security Keys", description: "Use WebAuthn-compliant security keys (e.g., FIDO2) as a second factor.", "button-text": "Add WebAuthn with FIDO Security Keys" }, "webauthn-platform": { title: "WebAuthn with FIDO Device Biometrics", description: "Use WebAuthn-compliant device biometrics as a second factor.", "button-text": "Add WebAuthn with FIDO Device Biometrics" }, "recovery-code": { title: "Recovery Code", description: "Use a unique recovery code to regain account access.", "button-text": "Add Recovery Code" }, enrollment_form: { email_address: "Email Address", phone_number: "Phone Number", send_code: "Send Code", sending: "Sending...", enroll_title: "Verify it\u2019s you", enroll_email_placeholder: "Enter email address", enroll_email_description: "Enter your email to receive a verification code", enroll_sms_placeholder: "Enter phone number", enroll_sms_description: "Enter your phone number to receive a verification code", show_auth0_guardian_title: "Scan this QR code with your Auth0 Guardian App to register this Authentication method or copy the url.", recovery_code_description: "Copy this recovery code and keep it somewhere safe. You'll need it if you ever need to log in without your device.", show_otp: { title: "Scan this QR code with your Authenticator App to register this Authentication method or copy the code.", save_recovery: "Save these recovery codes!", enter_code: "Enter the code from your authenticator app", one_time_passcode: "One-Time Passcode", verify_code: "Verify Code", copy_as_code: "Copy as Code", verifying: "Verifying...", enter_verify_code: "Enter the 6-digit code we sent to ${verifier}", enter_opt_code: "Enter the code from your authenticator", install_guardian_description: "In order to continue, install the Auth0 Guardian app via the app store from your mobile device" } } };
    l = { common: i, domain_management: o, org_management: a, idp_management: n, mfa: r };
  }
});

// ../core/dist/ja-NAZSAUWF.mjs
var ja_NAZSAUWF_exports = {};
__export(ja_NAZSAUWF_exports, {
  common: () => o2,
  default: () => n2,
  domain_management: () => r2,
  idp_management: () => l2,
  mfa: () => i2,
  org_management: () => a2
});
var o2, r2, a2, l2, i2, n2;
var init_ja_NAZSAUWF = __esm({
  "../core/dist/ja-NAZSAUWF.mjs"() {
    init_chunk_Z45QNK2S();
    o2 = { copy: "\u30B3\u30D4\u30FC", copied: "\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F" };
    r2 = { domain_table: { header: { title: "\u30C9\u30E1\u30A4\u30F3", description: "\u30C9\u30E1\u30A4\u30F3\u3092\u8FFD\u52A0\u3057\u3066\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u3092\u5F37\u5316\u3057\u3001\u30E6\u30FC\u30B6\u30FC\u306E\u30E1\u30FC\u30EB\u30C9\u30E1\u30A4\u30F3\u306B\u57FA\u3065\u3044\u3066\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3078\u76F4\u63A5\u8A98\u5C0E\u3059\u308B\u3053\u3068\u3067\u30ED\u30B0\u30A4\u30F3\u3092\u52B9\u7387\u5316\u3057\u307E\u3059\u3002", create_button_text: "\u30C9\u30E1\u30A4\u30F3\u3092\u8FFD\u52A0" }, table: { empty_message: "\u30C9\u30E1\u30A4\u30F3\u304C\u3042\u308A\u307E\u305B\u3093\u3002", columns: { domain: "\u30C9\u30E1\u30A4\u30F3\u540D", status: "\u30B9\u30C6\u30FC\u30BF\u30B9" }, actions: { configure_button_text: "\u8A2D\u5B9A", view_button_text: "\u8868\u793A", verify_button_text: "\u691C\u8A3C", delete_button_text: "\u524A\u9664" } }, notifications: { general_error: "\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u51E6\u7406\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001\u554F\u984C\u304C\u89E3\u6C7A\u3057\u306A\u3044\u5834\u5408\u306F\u30B5\u30DD\u30FC\u30C8\u307E\u3067\u304A\u554F\u3044\u5408\u308F\u305B\u304F\u3060\u3055\u3044\u3002", fetch_providers_error: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u53D6\u5F97\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001\u554F\u984C\u304C\u89E3\u6C7A\u3057\u306A\u3044\u5834\u5408\u306F\u30B5\u30DD\u30FC\u30C8\u307E\u3067\u304A\u554F\u3044\u5408\u308F\u305B\u304F\u3060\u3055\u3044\u3002", fetch_domains_error: "\u30C9\u30E1\u30A4\u30F3\u306E\u53D6\u5F97\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001\u554F\u984C\u304C\u89E3\u6C7A\u3057\u306A\u3044\u5834\u5408\u306F\u30B5\u30DD\u30FC\u30C8\u307E\u3067\u304A\u554F\u3044\u5408\u308F\u305B\u304F\u3060\u3055\u3044\u3002", domain_create: { success: "${domainName}\u304C\u4F5C\u6210\u3055\u308C\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u306E\u4F5C\u6210\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002", on_before: "\u30C9\u30E1\u30A4\u30F3\u304C\u6709\u52B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002" }, domain_verify: { success: "${domainName}\u304C\u691C\u8A3C\u3055\u308C\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u306E\u691C\u8A3C\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002", on_before: "\u30C9\u30E1\u30A4\u30F3\u691C\u8A3C\u306E\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002", verification_failed: "${domainName}\u3092\u691C\u8A3C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u3057\u3070\u3089\u304F\u5F85\u3063\u3066\u304B\u3089\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001DNS\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002" }, domain_delete: { success: "${domainName}\u304C\u524A\u9664\u3055\u308C\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u306E\u524A\u9664\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002" }, domain_associate_provider: { success: "${domainName}\u304C${idp}\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3067\u6709\u52B9\u306B\u306A\u308A\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u3092\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306B\u95A2\u9023\u4ED8\u3051\u308B\u969B\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002", on_before: "\u30C9\u30E1\u30A4\u30F3\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u95A2\u9023\u4ED8\u3051\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002" }, domain_delete_provider: { success: "${domainName}\u304C${idp}\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3067\u7121\u52B9\u306B\u306A\u308A\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u3092\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u304B\u3089\u524A\u9664\u3059\u308B\u969B\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002", on_before: "\u30C9\u30E1\u30A4\u30F3\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u524A\u9664\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002" } } }, domain_create: { modal: { title: "\u30C9\u30E1\u30A4\u30F3\u306E\u8FFD\u52A0", field: { label: "\u30C9\u30E1\u30A4\u30F3URL", placeholder: "\u30C9\u30E1\u30A4\u30F3\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", error: "\u6709\u52B9\u306A\u30C9\u30E1\u30A4\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, actions: { cancel_button_text: "\u30AD\u30E3\u30F3\u30BB\u30EB", create_button_text: "\u30C9\u30E1\u30A4\u30F3\u3092\u8FFD\u52A0" } } }, domain_configure_providers: { modal: { title: "${domain}\u3092\u8A2D\u5B9A", description: "${domain}\u30E1\u30FC\u30EB\u30C9\u30E1\u30A4\u30F3\u3092\u6301\u3064\u30E6\u30FC\u30B6\u30FC\u3092\u3001\u9078\u629E\u3057\u305F\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u8A8D\u8A3C\u306E\u305F\u3081\u306B\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306B\u76F4\u63A5\u8A98\u5C0E\u3057\u307E\u3059\u3002", table: { empty_message: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u304C\u3042\u308A\u307E\u305B\u3093\u3002", columns: { name: "\u540D\u524D", provider: "\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC" }, actions: { add_provider_button_text: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u8FFD\u52A0", view_provider_button_text: "\u8868\u793A" } }, actions: { close_button_text: "\u9589\u3058\u308B" } } }, domain_delete: { modal: { title: "\u30C9\u30E1\u30A4\u30F3\u306E\u524A\u9664", description: { pending: "${domainName}\u306F\u691C\u8A3C\u5F85\u3061\u3067\u3001\u51E6\u7406\u306B\u6700\u592748\u6642\u9593\u304B\u304B\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30C9\u30E1\u30A4\u30F3\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F", verified: "${domainName} \u3092\u524A\u9664\u3059\u308B\u3068\u3001\u30E6\u30FC\u30B6\u30FC\u306E\u30ED\u30B0\u30A4\u30F3\u30D5\u30ED\u30FC\u306B\u5F71\u97FF\u3092\u4E0E\u3048\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30C9\u30E1\u30A4\u30F3\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u305B\u307E\u305B\u3093\u3002" }, actions: { cancel_button_text: "\u30AD\u30E3\u30F3\u30BB\u30EB", delete_button_text: "\u524A\u9664" } } }, domain_verify: { modal: { title: "${domainName}\u306EDNS\u30EC\u30B3\u30FC\u30C9\u3092\u8FFD\u52A0", txt_record_name: { label: "TXT\u30EC\u30B3\u30FC\u30C9\u540D" }, txt_record_content: { label: "TXT\u30EC\u30B3\u30FC\u30C9\u306E\u5185\u5BB9" }, verification_status: { label: "\u691C\u8A3C\u30B9\u30C6\u30FC\u30BF\u30B9:", pending: "\u4FDD\u7559\u4E2D", description: "\u30C9\u30E1\u30A4\u30F3\u306E\u691C\u8A3C\u304C\u4FDD\u7559\u4E2D\u3067\u3059\u3002\u300C\u691C\u8A3C\u300D\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30B9\u30C6\u30FC\u30BF\u30B9\u3092\u66F4\u65B0\u3059\u308B\u304B\u3001\u5F8C\u3067\u3082\u3046\u4E00\u5EA6\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002DNS\u5909\u66F4\u306B\u306F\u6700\u592748\u6642\u9593\u304B\u304B\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u304C\u3001\u901A\u5E38\u306F\u3088\u308A\u65E9\u304F\u51E6\u7406\u3055\u308C\u307E\u3059\u3002" }, actions: { verify_button_text: "\u691C\u8A3C", delete_button_text: "\u524A\u9664", done_button_text: "\u5B8C\u4E86" }, errors: { verification_failed: "${domainName}\u3092\u691C\u8A3C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u3057\u3070\u3089\u304F\u5F85\u3063\u3066\u304B\u3089\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001DNS\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002" } } }, shared: { domain_statuses: { pending: "\u4FDD\u7559\u4E2D", verified: "\u691C\u8A3C\u6E08\u307F", failed: "\u5931\u6557" } } };
    a2 = { org_details: { sections: { settings: { title: "\u8A2D\u5B9A", fields: { name: { label: "\u540D\u524D", placeholder: "\u7D44\u7E54\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u7D44\u7E54\u306E\u4EBA\u9593\u304C\u8AAD\u307F\u3084\u3059\u3044\u8B58\u5225\u5B50\u3067\u3001\u30A8\u30F3\u30C9\u30E6\u30FC\u30B6\u30FC\u304C\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u5185\u3067\u81EA\u5206\u306E\u7D44\u7E54\u306B\u79FB\u52D5\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u307E\u3059\u3002", error: "\u6709\u52B9\u306A\u7D44\u7E54\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, display_name: { label: "\u8868\u793A\u540D", placeholder: "\u8868\u793A\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u3053\u306E\u7D44\u7E54\u306E\u30A8\u30F3\u30C9\u30E6\u30FC\u30B6\u30FC\u306B\u8868\u793A\u3055\u308C\u308B\u540D\u524D\u3067\u3059\u3002", error: "\u6709\u52B9\u306A\u8868\u793A\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } } }, branding: { title: "\u30D6\u30E9\u30F3\u30C7\u30A3\u30F3\u30B0", fields: { logo: { label: "\u7D44\u7E54\u30ED\u30B4", helper_text: "\u3053\u306E\u7D44\u7E54\u306E\u30A8\u30F3\u30C9\u30E6\u30FC\u30B6\u30FC\u3068\u306E\u3084\u308A\u53D6\u308A\u306E\u969B\u306B\u8868\u793A\u3055\u308C\u308B\u30ED\u30B4\u3067\u3059\u3002", error: "\u30ED\u30B4\u306E\u6709\u52B9\u306AHTTPS URL\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, primary_color: { label: "\u30D7\u30E9\u30A4\u30DE\u30EA\u30AB\u30E9\u30FC", helper_text: "\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u306E\u8A8D\u8A3C\u30D5\u30ED\u30FC\u3067\u3053\u306E\u7D44\u7E54\u306E\u30A8\u30F3\u30C9\u30E6\u30FC\u30B6\u30FC\u306B\u8868\u793A\u3055\u308C\u308B\u30DC\u30BF\u30F3\u306E\u30D7\u30E9\u30A4\u30DE\u30EA\u30AB\u30E9\u30FC\u3067\u3059\u3002", error: "\u6709\u52B9\u306A\u30AB\u30E9\u30FC\u5F62\u5F0F\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, page_background_color: { label: "\u30DA\u30FC\u30B8\u80CC\u666F\u8272", helper_text: "\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u306E\u8A8D\u8A3C\u30D5\u30ED\u30FC\u3067\u3053\u306E\u7D44\u7E54\u306E\u30A8\u30F3\u30C9\u30E6\u30FC\u30B6\u30FC\u306B\u8868\u793A\u3055\u308C\u308B\u30DA\u30FC\u30B8\u80CC\u666F\u8272\u3067\u3059\u3002", error: "\u6709\u52B9\u306A\u30AB\u30E9\u30FC\u5F62\u5F0F\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } } } }, unsaved_changes_text: "\u672A\u4FDD\u5B58\u306E\u5909\u66F4", submit_button_label: "\u4FDD\u5B58", cancel_button_label: "\u7834\u68C4" }, org_delete: { title: "${orgName}\u3092\u524A\u9664", description: "\u4E00\u5EA6\u78BA\u8A8D\u3059\u308B\u3068\u3001\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002", delete_button_label: "\u524A\u9664", modal_title: "${orgName}\u3092\u524A\u9664", modal_description: "${orgName}\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F\u30E6\u30FC\u30B6\u30FC\u306F\u7DAD\u6301\u3055\u308C\u307E\u3059\u304C\u3001\u3053\u306E\u7D44\u7E54\u3078\u306E\u30E1\u30F3\u30D0\u30FC\u30B7\u30C3\u30D7\u306F\u524A\u9664\u3055\u308C\u307E\u3059\u3002\u4E00\u5EA6\u78BA\u8A8D\u3059\u308B\u3068\u3001\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002", org_name_field_placeholder: "\u7D44\u7E54\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", org_name_field_label: "\u7D44\u7E54\u540D", org_name_field_error: "\u524A\u9664\u3092\u78BA\u8A8D\u3059\u308B\u305F\u3081\u306B\u300C${orgName}\u300D\u3068\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", cancel_button_label: "\u30AD\u30E3\u30F3\u30BB\u30EB" }, org_details_edit: { header: { back_button_text: "\u7D44\u7E54\u4E00\u89A7\u306B\u623B\u308B", title: "${orgName}" }, save_org_changes_message: "${orgName}\u306E\u5909\u66F4\u304C\u4FDD\u5B58\u3055\u308C\u307E\u3057\u305F\u3002", org_changes_error_message: "\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u51E6\u7406\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002${message}.", org_changes_error_message_generic: "\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u51E6\u7406\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001\u554F\u984C\u304C\u89E3\u6C7A\u3057\u306A\u3044\u5834\u5408\u306F\u30B5\u30DD\u30FC\u30C8\u307E\u3067\u304A\u554F\u3044\u5408\u308F\u305B\u304F\u3060\u3055\u3044\u3002" } };
    l2 = { sso_provider_table: { header: { title: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3", description: "\u7D44\u7E54\u306ESSO\u30A2\u30AF\u30BB\u30B9\u3092\u8A2D\u5B9A\u30FB\u7BA1\u7406\u3057\u307E\u3059\u3002", create_button_text: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u8FFD\u52A0" }, table: { empty_message: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u304C\u3042\u308A\u307E\u305B\u3093\u3002", columns: { name: "\u540D\u524D", identity_provider: "\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC", display_name: "\u8868\u793A\u540D" }, actions: { edit_button_text: "\u7DE8\u96C6", delete_button_text: "\u524A\u9664", remove_button_text: "\u7D44\u7E54\u304B\u3089\u524A\u9664" } }, create_consent_modal: { title: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u4F5C\u6210\u3059\u308B\u524D\u306B\u3001\u4EE5\u4E0B\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\uFF1A", description: "\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u4F5C\u6210\u3059\u308B\u3068\u3001${organizationName}\u3078\u306ESSO\u30A2\u30AF\u30BB\u30B9\u304C\u6709\u52B9\u306B\u306A\u308A\u307E\u3059\u3002\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u3092\u512A\u5148\u3059\u308B\u305F\u3081\u3001\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u304C\u30A2\u30AF\u30C6\u30A3\u30D6\u306B\u306A\u3063\u305F\u3089\u3001\u3067\u304D\u308B\u3060\u3051\u65E9\u304F\u30A2\u30AF\u30BB\u30B9\u6A29\u9650\u3092\u5272\u308A\u5F53\u3066\u3066\u3001\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u30C6\u30B9\u30C8\u3057\u3066\u304F\u3060\u3055\u3044\u3002", actions: { cancel_button_text: "\u30AD\u30E3\u30F3\u30BB\u30EB", process_button_text: "\u7D9A\u884C" } } }, create_sso_provider: { steps: { one: "\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC", two: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u8A73\u7D30", three: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u8A2D\u5B9A" }, header: { title: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u8FFD\u52A0", back_button_text: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3\u306B\u623B\u308B" }, nextButtonLabel: "\u6B21\u3078", previousButtonLabel: "\u623B\u308B", completeButtonLabel: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u4F5C\u6210", notifications: { general_error: "\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u51E6\u7406\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001\u554F\u984C\u304C\u89E3\u6C7A\u3057\u306A\u3044\u5834\u5408\u306F\u30B5\u30DD\u30FC\u30C8\u306B\u304A\u554F\u3044\u5408\u308F\u305B\u304F\u3060\u3055\u3044\u3002", provider_create_success: "${providerName} \u304C\u4F5C\u6210\u3055\u308C\u307E\u3057\u305F\u3002", provider_create_duplicated_provider_error: "${providerName} \u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306F\u65E2\u306B\u5B58\u5728\u3057\u307E\u3059\u3002\u5225\u306E\u540D\u524D\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002" }, provider_select: { title: "ID\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u9078\u629E", description: "Auth0\u3068\u7D71\u5408\u3059\u308B\u4E88\u5B9A\u306EID\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u9078\u629E\u3057\u3066\u3001\u30B9\u30C6\u30C3\u30D7\u30D0\u30A4\u30B9\u30C6\u30C3\u30D7\u306E\u8A2D\u5B9A\u624B\u9806\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u3066\u304F\u3060\u3055\u3044\u3002" }, provider_details: { title: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u8A73\u7D30", description: "\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u5F8C\u3067\u7BA1\u7406\u30FB\u53C2\u7167\u3059\u308B\u305F\u3081\u306B\u3001\u8A8D\u8B58\u3057\u3084\u3059\u3044\u540D\u524D\u3068\u6C38\u7D9A\u7684\u306A\u8B58\u5225\u5B50\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002", fields: { name: { label: "\u540D\u524D", placeholder: "\u8B58\u5225\u5B50\u3092\u5165\u529B", helper_text: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u4EBA\u304C\u8AAD\u3081\u308B\u8B58\u5225\u5B50\u3067\u3059\u3002\u3053\u308C\u306F\u5909\u66F4\u3067\u304D\u307E\u305B\u3093\u3002", error: "\u6709\u52B9\u306A\u540D\u524D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, display_name: { label: "\u8868\u793A\u540D", placeholder: "\u8868\u793A\u540D\u3092\u5165\u529B", helper_text: "\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u30A8\u30F3\u30C9\u30E6\u30FC\u30B6\u30FC\u306B\u8868\u793A\u3055\u308C\u308B\u540D\u524D\u3067\u3059\u3002", error: "\u6709\u52B9\u306A\u8868\u793A\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } } }, provider_configure: { title: "Configure Provider", description: "Establish a connection between your identity provider and Auth0.", fields: { common: { show_as_button: { label: "\u30DC\u30BF\u30F3\u3068\u3057\u3066\u8868\u793A", helper_text: "\u3053\u306E\u63A5\u7D9A\u3092\u30ED\u30B0\u30A4\u30F3\u30DA\u30FC\u30B8\u306B\u30DC\u30BF\u30F3\u3068\u3057\u3066\u8868\u793A\u3057\u307E\u3059" }, assign_membership_on_login: { label: "\u30ED\u30B0\u30A4\u30F3\u6642\u306B\u30E1\u30F3\u30D0\u30FC\u30B7\u30C3\u30D7\u3092\u5272\u308A\u5F53\u3066", helper_text: "\u3053\u306E\u63A5\u7D9A\u3092\u901A\u3058\u3066\u30ED\u30B0\u30A4\u30F3\u3057\u305F\u30E6\u30FC\u30B6\u30FC\u306B\u7D44\u7E54\u30E1\u30F3\u30D0\u30FC\u30B7\u30C3\u30D7\u3092\u81EA\u52D5\u7684\u306B\u4ED8\u4E0E\u3057\u307E\u3059" } }, okta: { domain: { label: "Okta\u30C9\u30E1\u30A4\u30F3", placeholder: "domain-name.okta.com", helper_text: "<link>Okta\u30C9\u30E1\u30A4\u30F3\u306F\u3069\u3053\u3067\u78BA\u8A8D\u3067\u304D\u307E\u3059\u304B\uFF1F</link>", error: "\u6709\u52B9\u306AOkta\u30C9\u30E1\u30A4\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_id: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8ID", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8ID\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u307E\u305F\u306F\u30B5\u30FC\u30D3\u30B9\u7D71\u5408\u306E\u4E00\u610F\u8B58\u5225\u5B50\u3002<link>\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8ID\u306F\u3069\u3053\u3067\u78BA\u8A8D\u3067\u304D\u307E\u3059\u304B\uFF1F</link>", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8ID\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_secret: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u8A8D\u8A3C\u306B\u4F7F\u7528\u3055\u308C\u308B\u6A5F\u5BC6\u30C8\u30FC\u30AF\u30F3\u3002<link>\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u306F\u3069\u3053\u3067\u78BA\u8A8D\u3067\u304D\u307E\u3059\u304B\uFF1F</link>", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, icon_url: { label: "\u30A2\u30A4\u30B3\u30F3URL", placeholder: "\u30A2\u30A4\u30B3\u30F3URL\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30E6\u30FC\u30B6\u30FC\u306B\u8868\u793A\u3055\u308C\u308B\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u30A2\u30A4\u30B3\u30F3\u306EURL\u3002", error: "\u6709\u52B9\u306AURL\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } }, "google-apps": { domain: { label: "Google \u30EF\u30FC\u30AF\u30B9\u30DA\u30FC\u30B9\u30C9\u30E1\u30A4\u30F3", placeholder: "your-google-workspace-domain.com", error: "\u6709\u52B9\u306A Google \u30EF\u30FC\u30AF\u30B9\u30DA\u30FC\u30B9\u30C9\u30E1\u30A4\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_id: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u307E\u305F\u306F\u30B5\u30FC\u30D3\u30B9\u7D71\u5408\u306E\u4E00\u610F\u8B58\u5225\u5B50\u3002", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_secret: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u8A8D\u8A3C\u306B\u4F7F\u7528\u3055\u308C\u308B\u6A5F\u5BC6\u30C8\u30FC\u30AF\u30F3\u3002", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, callback_url: { label: "\u30B3\u30FC\u30EB\u30D0\u30C3\u30AF URL", placeholder: "https://staff0.local.dev.auth0.com/login/callback", helper_text: "\u3053\u306E\u30B3\u30FC\u30EB\u30D0\u30C3\u30AF URL \u3067 Google \u30EF\u30FC\u30AF\u30B9\u30DA\u30FC\u30B9\u30C6\u30CA\u30F3\u30C8\u3092\u8A2D\u5B9A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u3002", error: "\u6709\u52B9\u306A URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } }, waad: { tenant_domain: { label: "Microsoft Entra ID \u30C9\u30E1\u30A4\u30F3", placeholder: "your-entra-id-domain.com", error: "\u6709\u52B9\u306A Microsoft Entra ID \u30C9\u30E1\u30A4\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_id: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u307E\u305F\u306F\u30B5\u30FC\u30D3\u30B9\u7D71\u5408\u306E\u4E00\u610F\u8B58\u5225\u5B50\u3002", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_secret: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u8A8D\u8A3C\u306B\u4F7F\u7528\u3055\u308C\u308B\u6A5F\u5BC6\u30C8\u30FC\u30AF\u30F3\u3002", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, callback_url: { label: "\u30B3\u30FC\u30EB\u30D0\u30C3\u30AF URL", placeholder: "https://staff0.local.dev.auth0.com/login/callback", helper_text: "\u3053\u306E \u30B3\u30FC\u30EB\u30D0\u30C3\u30AF URL \u3067 Entra ID \u30C6\u30CA\u30F3\u30C8\u3092\u8A2D\u5B9A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u3002", error: "\u6709\u52B9\u306A URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } }, oidc: { discovery_url: { label: "OpenID \u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u69CB\u6210\u30A8\u30F3\u30C9\u30DD\u30A4\u30F3\u30C8", placeholder: "https://example.com/.well-known/openid-configuration", helper_text: "\u63A5\u7D9A\u3057\u305F\u3044 OpenID Connect \u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u30C7\u30A3\u30B9\u30AB\u30D0\u30EA\u30FC\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u306E URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002", error: "\u6709\u52B9\u306A\u30C7\u30A3\u30B9\u30AB\u30D0\u30EA\u30FC URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, type: { label: "\u901A\u4FE1\u30C1\u30E3\u30CD\u30EB", helper_text: "\u8A8D\u8A3C\u4EA4\u63DB\u304C\u30B5\u30FC\u30D0\u30FC\u9593\u901A\u4FE1\uFF08\u30D0\u30C3\u30AF\u30C1\u30E3\u30CD\u30EB\uFF09\u307E\u305F\u306FImplicit Flow with Form Post \u3092\u4F7F\u7528\u3057\u3066\u30D6\u30E9\u30A6\u30B6\u7D4C\u7531\uFF08\u30D5\u30ED\u30F3\u30C8\u30C1\u30E3\u30CD\u30EB\uFF09\u3067\u884C\u308F\u308C\u308B\u304B\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002", options: { back_channel: { label: "\u30D0\u30C3\u30AF\u30C1\u30E3\u30CD\u30EB" }, front_channel: { label: "\u30D5\u30ED\u30F3\u30C8\u30C1\u30E3\u30CD\u30EB" } } }, client_id: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u307E\u305F\u306F\u30B5\u30FC\u30D3\u30B9\u7D71\u5408\u306E\u4E00\u610F\u8B58\u5225\u5B50\u3002", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8 ID \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, client_secret: { label: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8", placeholder: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", helper_text: "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u8A8D\u8A3C\u306B\u4F7F\u7528\u3055\u308C\u308B\u6A5F\u5BC6\u30C8\u30FC\u30AF\u30F3\u3002", error: "\u6709\u52B9\u306A\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u30B7\u30FC\u30AF\u30EC\u30C3\u30C8\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } }, "ping-federate": { meta_data_url: { label: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3\u30ED\u30B0\u30A4\u30F3 URL", placeholder: "https://example.com/idp/SSO.saml2", helper_text: "PingFederate SSO \u63A5\u7D9A\u3067\u30BB\u30AD\u30E5\u30A2\u306A\u8A8D\u8A3C\u3092\u958B\u59CB\u3059\u308B\u305F\u3081\u306E\u30A8\u30F3\u30C9\u30DD\u30A4\u30F3\u30C8\u3002", error: "\u6709\u52B9\u306A SSO \u30ED\u30B0\u30A4\u30F3 URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, sign_cert: { label: "\u7F72\u540D\u8A3C\u660E\u66F8", placeholder: "\u7F72\u540D\u8A3C\u660E\u66F8\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9", helper_text: "\u30BB\u30AD\u30E5\u30A2\u306A\u8EAB\u5143\u8A8D\u8A3C\u306B\u4F7F\u7528\u3055\u308C\u308B\u30C7\u30B8\u30BF\u30EB\u8CC7\u683C\u60C5\u5831\u3002", error: "\u6709\u52B9\u306A\u7F72\u540D\u8A3C\u660E\u66F8\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3057\u3066\u304F\u3060\u3055\u3044" }, advanced_settings: { title: "\u8A73\u7D30\u8A2D\u5B9A", sign_request: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D", helper_text: "\u6709\u52B9\u306B\u3059\u308B\u3068\u3001SAML \u8A8D\u8A3C\u30EA\u30AF\u30A8\u30B9\u30C8\u304C\u7F72\u540D\u3055\u308C\u307E\u3059\u3002<link>\u8A3C\u660E\u66F8</link>\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u3066\u3001\u7F72\u540D\u3055\u308C\u305F\u30A2\u30B5\u30FC\u30B7\u30E7\u30F3\u3092\u53D7\u4FE1\u3059\u308B SAMLP \u306B\u63D0\u4F9B\u3057\u3001\u7F72\u540D\u3092\u691C\u8A3C\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u3053\u308C\u306F\u6700\u521D\u306B SAMLP \u3067\u6709\u52B9\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\u6709\u52B9\u306B\u3057\u305F\u3089\u3001\u7D71\u5408\u7528\u306E\u30E1\u30BF\u30C7\u30FC\u30BF URL \u3092\u5171\u6709\u3057\u3066\u304F\u3060\u3055\u3044\u3002", error: "\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" }, sign_request_algorithm: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0", placeholder: "RSA-SHA256", helper_text: "PingFederate \u3078\u306E SAML \u8A8D\u8A3C\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u7F72\u540D\u306B\u4F7F\u7528\u3055\u308C\u308B\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3002", error: "\u7F72\u540D\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" }, sign_request_algorithm_digest: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u30C0\u30A4\u30B8\u30A7\u30B9\u30C8", placeholder: "SHA256", helper_text: "PingFederate \u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D\u306B\u4F7F\u7528\u3055\u308C\u308B\u30C0\u30A4\u30B8\u30A7\u30B9\u30C8\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3002", error: "\u30C0\u30A4\u30B8\u30A7\u30B9\u30C8\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" } } }, adfs: { meta_data_source: { label: "ADFS \u30E1\u30BF\u30C7\u30FC\u30BF\u30BD\u30FC\u30B9", options: { meta_data_url: { label: "ADFS URL" }, meta_data_file: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB" } } }, meta_data_url: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF URL", placeholder: "https://example.com/FederationMetadata/2007-06/FederationMetadata.xml", helper_text: "\u7D71\u5408\u7528\u306E WS-Fed SSO \u63A5\u7D9A\u60C5\u5831\u3092\u53D6\u5F97\u3059\u308B\u5834\u6240\u3002", error: "\u6709\u52B9\u306A\u30E1\u30BF\u30C7\u30FC\u30BF URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, meta_data_location_url: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF\u30ED\u30B1\u30FC\u30B7\u30E7\u30F3 URL", placeholder: "https://HOSTNAME/FederationMetadata/2007-06/FederationMetadata.xml", helper_text: "\u7D71\u5408\u7528\u306E WS-Fed SSO \u63A5\u7D9A\u60C5\u5831\u3092\u53D6\u5F97\u3059\u308B\u5834\u6240\u3002", error: "\u6709\u52B9\u306A\u30E1\u30BF\u30C7\u30FC\u30BF\u30ED\u30B1\u30FC\u30B7\u30E7\u30F3 URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, federation_metadata_file: { label: "\u30D5\u30A7\u30C7\u30EC\u30FC\u30B7\u30E7\u30F3\u30E1\u30BF\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB", placeholder: "\u30D5\u30A7\u30C7\u30EC\u30FC\u30B7\u30E7\u30F3\u30E1\u30BF\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9", helper_text: "\u30BB\u30AD\u30E5\u30A2\u306A\u8EAB\u5143\u8A8D\u8A3C\u306B\u4F7F\u7528\u3055\u308C\u308B\u30C7\u30B8\u30BF\u30EB\u8CC7\u683C\u60C5\u5831\u3002", error: "\u6709\u52B9\u306A\u30D5\u30A7\u30C7\u30EC\u30FC\u30B7\u30E7\u30F3\u30E1\u30BF\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3057\u3066\u304F\u3060\u3055\u3044" }, upload_button_label: "\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9" }, samlp: { meta_data_source: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF\u30BD\u30FC\u30B9", options: { meta_data_url: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF URL" }, meta_data_file: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF\u30D5\u30A1\u30A4\u30EB" } } }, meta_data_url: { label: "\u30E1\u30BF\u30C7\u30FC\u30BF URL", placeholder: "https://example.com/samlp/metadata.xml", helper_text: "\u7D71\u5408\u7528\u306E SAML SSO \u63A5\u7D9A\u60C5\u5831\u3092\u53D6\u5F97\u3059\u308B\u5834\u6240\u3002", error: "\u6709\u52B9\u306A\u30E1\u30BF\u30C7\u30FC\u30BF URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, single_sign_on_login_url: { label: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3\u30ED\u30B0\u30A4\u30F3 URL", placeholder: "https://example.com/idp/saml/", helper_text: "SAML SSO \u63A5\u7D9A\u3067\u30BB\u30AD\u30E5\u30A2\u306A\u8A8D\u8A3C\u3092\u958B\u59CB\u3059\u308B\u305F\u3081\u306E\u30A8\u30F3\u30C9\u30DD\u30A4\u30F3\u30C8\u3002", error: "\u6709\u52B9\u306A SSO \u30ED\u30B0\u30A4\u30F3 URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, cert: { label: "\u7F72\u540D\u8A3C\u660E\u66F8", placeholder: "\u7F72\u540D\u8A3C\u660E\u66F8\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9", helper_text: "PEM \u307E\u305F\u306F CER \u5F62\u5F0F\u3067\u30A8\u30F3\u30B3\u30FC\u30C9\u3055\u308C\u305F SAML X.509 \u516C\u958B\u9375\u3002", error: "\u6709\u52B9\u306A\u7F72\u540D\u8A3C\u660E\u66F8\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3057\u3066\u304F\u3060\u3055\u3044" }, advanced_settings: { title: "\u8A73\u7D30\u8A2D\u5B9A", sign_request: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D", helper_text_metadata_file: "\u6709\u52B9\u306B\u3059\u308B\u3068\u3001SAML\u8A8D\u8A3C\u30EA\u30AF\u30A8\u30B9\u30C8\u304C\u7F72\u540D\u3055\u308C\u307E\u3059\u3002<link>\u8A3C\u660E\u66F8</link>\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u3001\u7F72\u540D\u4ED8\u304D\u30A2\u30B5\u30FC\u30B7\u30E7\u30F3\u3092\u53D7\u4FE1\u3059\u308BSAMLP\u306B\u63D0\u4F9B\u3057\u3066\u3001\u7F72\u540D\u306E\u691C\u8A3C\u3092\u884C\u3063\u3066\u304F\u3060\u3055\u3044\u3002\u3053\u308C\u306F\u307E\u305ASAMLP\u5074\u3067\u6709\u52B9\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\u6709\u52B9\u306B\u3057\u305F\u5F8C\u3001\u9023\u643A\u306E\u305F\u3081\u306B\u30E1\u30BF\u30C7\u30FC\u30BFURL\u3092\u5171\u6709\u3057\u3066\u304F\u3060\u3055\u3044\u3002", helper_text_metadata_url: "\u6709\u52B9\u306B\u3059\u308B\u3068\u3001SAML\u8A8D\u8A3C\u30EA\u30AF\u30A8\u30B9\u30C8\u304C\u7F72\u540D\u3055\u308C\u307E\u3059\u3002<link>\u8A3C\u660E\u66F8</link>\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u3001\u7F72\u540D\u4ED8\u304D\u30A2\u30B5\u30FC\u30B7\u30E7\u30F3\u3092\u53D7\u4FE1\u3059\u308BSAMLP\u306B\u63D0\u4F9B\u3057\u3066\u3001\u7F72\u540D\u306E\u691C\u8A3C\u3092\u884C\u3063\u3066\u304F\u3060\u3055\u3044\u3002" }, request_protocol_binding: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u30D7\u30ED\u30C8\u30B3\u30EB\u30D0\u30A4\u30F3\u30C7\u30A3\u30F3\u30B0", placeholder: "HTTP-Post", helper_text: "\u8A8D\u8A3C\u30EA\u30AF\u30A8\u30B9\u30C8\u306B\u4F7F\u7528\u3059\u308B SAML \u30D7\u30ED\u30C8\u30B3\u30EB\u30D0\u30A4\u30F3\u30C7\u30A3\u30F3\u30B0\u3002", error: "\u30D7\u30ED\u30C8\u30B3\u30EB\u30D0\u30A4\u30F3\u30C7\u30A3\u30F3\u30B0\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" }, sign_request_algorithm: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0", placeholder: "RSA-SHA256", helper_text: "SAML \u8A8D\u8A3C\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u7F72\u540D\u306B\u4F7F\u7528\u3055\u308C\u308B\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3002", error: "\u7F72\u540D\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" }, sign_request_algorithm_digest: { label: "\u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u30C0\u30A4\u30B8\u30A7\u30B9\u30C8", placeholder: "SHA256", helper_text: "SAML \u30EA\u30AF\u30A8\u30B9\u30C8\u7F72\u540D\u306B\u4F7F\u7528\u3055\u308C\u308B\u30C0\u30A4\u30B8\u30A7\u30B9\u30C8\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3002", error: "\u30C0\u30A4\u30B8\u30A7\u30B9\u30C8\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" } }, icon_url: { label: "\u30A2\u30A4\u30B3\u30F3 URL", placeholder: "\u30A2\u30A4\u30B3\u30F3 URL \u3092\u5165\u529B", helper_text: "\u30E6\u30FC\u30B6\u30FC\u306B\u8868\u793A\u3055\u308C\u308B\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u30A2\u30A4\u30B3\u30F3\u306E URL\u3002", error: "\u6709\u52B9\u306A URL \u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" } } } } }, edit_sso_provider: { header: { back_button_text: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3\u306B\u623B\u308B", enable_provider_tooltip_text: "\u30C8\u30B0\u30EB\u3067\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u6709\u52B9\u306B\u3057\u307E\u3059\u3002", disable_provider_tooltip_text: "\u30C8\u30B0\u30EB\u3067\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u7121\u52B9\u306B\u3057\u307E\u3059\u3002" }, tabs: { sso: { name: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3", content: { title: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3", description: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3\u3092\u7BA1\u7406\u30FB\u8A2D\u5B9A\u3057\u307E\u3059\u3002", alert: { warning: "\u30B7\u30F3\u30B0\u30EB\u30B5\u30A4\u30F3\u30AA\u30F3\u306E\u30E6\u30FC\u30B6\u30FC\u5C5E\u6027\u30DE\u30C3\u30D4\u30F3\u30B0\u304C\u66F4\u65B0\u3055\u308C\u307E\u3057\u305F\u3002\u30ED\u30B0\u30A4\u30F3\u306E\u554F\u984C\u3092\u56DE\u907F\u3059\u308B\u305F\u3081\u3001\u5C5E\u6027\u3092\u78BA\u8A8D\u3057\u3066\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u8A2D\u5B9A\u3092\u66F4\u65B0\u3057\u3066\u304F\u3060\u3055\u3044\u3002" } } }, provisioning: { name: "\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0", content: { header: { title: "\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0", description: "\u30E6\u30FC\u30B6\u30FC\u30D7\u30ED\u30D5\u30A1\u30A4\u30EB\u3092\u7D44\u7E54\u306B\u540C\u671F\u3059\u308B\u305F\u3081\u306E\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0\u3092\u8A2D\u5B9A\u3057\u307E\u3059\u3002", guided_setup_button_label: "\u30AC\u30A4\u30C9\u4ED8\u304D\u30BB\u30C3\u30C8\u30A2\u30C3\u30D7", enable_provisioning_tooltip: "\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0\u3092\u4F5C\u6210\u3059\u308B\u306B\u306F\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044" }, warning_alert_message: { title: "\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0\u306E\u30DE\u30C3\u30D4\u30F3\u30B0\u304C\u66F4\u65B0\u3055\u308C\u307E\u3057\u305F\u3002", description: "\u5C5E\u6027\u3092\u78BA\u8A8D\u3057\u3001\u9069\u5207\u306A\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0\u3092\u78BA\u4FDD\u3059\u308B\u305F\u3081\u306B\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306E\u8A2D\u5B9A\u3092\u66F4\u65B0\u3057\u3066\u304F\u3060\u3055\u3044\u3002" }, delete: { modal: { title: "Disable provisioning", content: { description: "Are you sure you want to disable provisioning? This will permanently delete the provisioning configuration and revoke access for any clients using provisioning with this provider." }, actions: { cancel_button_label: "Cancel", delete_button_label: "Proceed" } } }, details: { manage_tokens: { title: "\u30D9\u30A2\u30E9\u30FC\u30C8\u30FC\u30AF\u30F3", description: "\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306B\u63D0\u4F9B\u3059\u308B\u30D9\u30A2\u30E9\u30FC\u30C8\u30FC\u30AF\u30F3\u3092\u751F\u6210\u3057\u307E\u3059\u3002\u6700\u59272\u3064\u306E\u30C8\u30FC\u30AF\u30F3\u3092\u4F5C\u6210\u3067\u304D\u307E\u3059\u3002", generate_button_label: "\u30C8\u30FC\u30AF\u30F3\u3092\u751F\u6210", max_tokens_tooltip: "\u6700\u59272\u3064\u306E\u30C8\u30FC\u30AF\u30F3\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u307E\u3059", empty_state: { title: "\u307E\u3060\u30C8\u30FC\u30AF\u30F3\u304C\u4F5C\u6210\u3055\u308C\u3066\u3044\u307E\u305B\u3093", description: "\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u304B\u3089\u306ESCIM\u30EA\u30AF\u30A8\u30B9\u30C8\u3092\u8A8D\u8A3C\u3059\u308B\u305F\u3081\u306E\u30D9\u30A2\u30E9\u30FC\u30C8\u30FC\u30AF\u30F3\u3092\u751F\u6210\u3057\u3066\u304F\u3060\u3055\u3044\u3002" }, table: { token_id_label: "\u30C8\u30FC\u30AF\u30F3ID", created_label: "\u4F5C\u6210\u65E5\u6642", expires_label: "\u6709\u52B9\u671F\u9650", actions_label: "\u30A2\u30AF\u30B7\u30E7\u30F3" }, token_item: { token_prefix: "\u30C8\u30FC\u30AF\u30F3", never_expire: "\u3053\u306E\u30C8\u30FC\u30AF\u30F3\u306B\u6709\u52B9\u671F\u9650\u306F\u3042\u308A\u307E\u305B\u3093\u3002", last_used: "\u6700\u7D42\u4F7F\u7528: \u306A\u3057", status_active: "\u6709\u52B9", status_expired: "\u671F\u9650\u5207\u308C", delete_button_label: "\u524A\u9664" }, create_modal: { title: "\u30D9\u30A2\u30E9\u30FC\u30C8\u30FC\u30AF\u30F3\u60C5\u5831", copy_and_close_button_label: "\u30B3\u30D4\u30FC\u3057\u3066\u9589\u3058\u308B", content: { description: "\u30D9\u30A2\u30E9\u30FC\u30C8\u30FC\u30AF\u30F3\u3092\u30B3\u30D4\u30FC\u3057\u3066\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306B\u63D0\u4F9B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u3053\u306E\u30C0\u30A4\u30A2\u30ED\u30B0\u3092\u9589\u3058\u308B\u3068\u518D\u8868\u793A\u3055\u308C\u307E\u305B\u3093\u3002", field: { label: "\u30C8\u30FC\u30AF\u30F3" } } }, delete_modal: { title: "\u30C8\u30FC\u30AF\u30F3${tokenId}\u3092\u524A\u9664", cancel_button_label: "\u30AD\u30E3\u30F3\u30BB\u30EB", delete_button_label: "\u30C8\u30FC\u30AF\u30F3\u3092\u524A\u9664", content: { confirmation: "\u30C8\u30FC\u30AF\u30F3${tokenId}\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002", description: "\u30C0\u30A6\u30F3\u30BF\u30A4\u30E0\u3092\u907F\u3051\u308B\u305F\u3081\u306B\u3001\u3053\u306E\u30C8\u30FC\u30AF\u30F3\u3092\u524A\u9664\u3059\u308B\u524D\u306B2\u756A\u76EE\u306E\u30C8\u30FC\u30AF\u30F3\u3092\u4F5C\u6210\u3057\u3066\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u306B\u63D0\u4F9B\u3059\u308B\u3053\u3068\u3092\u691C\u8A0E\u3057\u3066\u304F\u3060\u3055\u3044\u3002" } } }, fields: { user_id_attribute: { label: "\u30E6\u30FC\u30B6\u30FCID\u5C5E\u6027", helper_text: "\u30E6\u30FC\u30B6\u30FC\u3092\u4E00\u610F\u306B\u8B58\u5225\u3059\u308B\u5C5E\u6027\u3002" }, scim_endpoint_url: { label: "SCIM\u30A8\u30F3\u30C9\u30DD\u30A4\u30F3\u30C8URL" }, external_namespace: { label: "\u5916\u90E8\u30CD\u30FC\u30E0\u30B9\u30DA\u30FC\u30B9" } }, mappings: { title: "\u30DE\u30C3\u30D4\u30F3\u30B0", description: "\u6B63\u3057\u3044\u30E6\u30FC\u30B6\u30FC\u5C5E\u6027\u304C\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u304B\u3089\u30B5\u30FC\u30D3\u30B9\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u306B\u6E21\u3055\u308C\u308B\u3053\u3068\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002", card: { title: "\u5FC5\u9808\u5C5E\u6027", description: "\u6709\u52B9\u306A${strategy}\u5C5E\u6027\u304C\u6B21\u306E\u5C5E\u6027\u306B\u30DE\u30C3\u30D4\u30F3\u30B0\u3055\u308C\u3066\u3044\u308B\u3053\u3068\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002", table: { columns: { attribute_name_label: "\u5C5E\u6027\u540D", external_field_label: "\u5916\u90E8\u30D5\u30A3\u30FC\u30EB\u30C9" } } } } } } }, domains: { name: "\u30C9\u30E1\u30A4\u30F3", content: { title: "\u30C9\u30E1\u30A4\u30F3", description: "\u30E6\u30FC\u30B6\u30FC\u306E\u30E1\u30FC\u30EB\u30C9\u30E1\u30A4\u30F3\u306B\u57FA\u3065\u3044\u3066\u30A2\u30A4\u30C7\u30F3\u30C6\u30A3\u30C6\u30A3\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3078\u8A98\u5C0E\u3059\u308B\u3053\u3068\u3067\u3001\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u3092\u5F37\u5316\u3057\u30ED\u30B0\u30A4\u30F3\u3092\u52B9\u7387\u5316\u3057\u307E\u3059\u3002", create_button_text: "\u30C9\u30E1\u30A4\u30F3\u3092\u8FFD\u52A0", table: { empty_message: "\u30C9\u30E1\u30A4\u30F3\u304C\u3042\u308A\u307E\u305B\u3093", columns: { name: "\u30C9\u30E1\u30A4\u30F3\u540D", status: "\u30B9\u30C6\u30FC\u30BF\u30B9", verify: "\u691C\u8A3C" }, domain_statuses: { pending: "\u4FDD\u7559\u4E2D", verified: "\u691C\u8A3C\u6E08\u307F", failed: "\u5931\u6557" } }, domain_create: { modal: { title: "\u30C9\u30E1\u30A4\u30F3\u306E\u8FFD\u52A0", field: { label: "\u30C9\u30E1\u30A4\u30F3URL", placeholder: "domain-name.com", error: "\u6709\u52B9\u306A\u30C9\u30E1\u30A4\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044" }, actions: { cancel_button_text: "\u30AD\u30E3\u30F3\u30BB\u30EB", create_button_text: "\u30C9\u30E1\u30A4\u30F3\u3092\u8FFD\u52A0" } } }, domain_delete: { modal: { title: "\u30C9\u30E1\u30A4\u30F3\u306E\u524A\u9664", description: { pending: "${domainName} \u306F\u78BA\u8A8D\u5F85\u3061\u3067\u3042\u308A\u3001\u51E6\u7406\u306B\u6700\u592748\u6642\u9593\u304B\u304B\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30C9\u30E1\u30A4\u30F3\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u305B\u307E\u305B\u3093\u3002", verified: "${domainName} \u3092\u524A\u9664\u3059\u308B\u3068\u3001\u30E6\u30FC\u30B6\u30FC\u306E\u30ED\u30B0\u30A4\u30F3\u30D5\u30ED\u30FC\u306B\u5F71\u97FF\u3092\u4E0E\u3048\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30C9\u30E1\u30A4\u30F3\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u305B\u307E\u305B\u3093\u3002" }, actions: { cancel_button_text: "\u30AD\u30E3\u30F3\u30BB\u30EB", delete_button_text: "\u524A\u9664" } } }, domain_verify: { modal: { title: "${domainName}\u306EDNS\u30EC\u30B3\u30FC\u30C9\u3092\u8FFD\u52A0", txt_record_name: { label: "TXT\u30EC\u30B3\u30FC\u30C9\u540D" }, txt_record_content: { label: "TXT\u30EC\u30B3\u30FC\u30C9\u306E\u5185\u5BB9" }, verification_status: { label: "\u691C\u8A3C\u30B9\u30C6\u30FC\u30BF\u30B9:", pending: "\u4FDD\u7559\u4E2D", description: "\u30C9\u30E1\u30A4\u30F3\u306E\u691C\u8A3C\u304C\u4FDD\u7559\u4E2D\u3067\u3059\u3002\u300C\u691C\u8A3C\u300D\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30B9\u30C6\u30FC\u30BF\u30B9\u3092\u66F4\u65B0\u3059\u308B\u304B\u3001\u5F8C\u3067\u3082\u3046\u4E00\u5EA6\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002DNS\u5909\u66F4\u306B\u306F\u6700\u592748\u6642\u9593\u304B\u304B\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u304C\u3001\u901A\u5E38\u306F\u3088\u308A\u65E9\u304F\u51E6\u7406\u3055\u308C\u307E\u3059\u3002" }, actions: { verify_button_text: "\u691C\u8A3C", delete_button_text: "\u524A\u9664", done_button_text: "\u5B8C\u4E86" }, errors: { verification_failed: "${domainName}\u3092\u691C\u8A3C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u3057\u3070\u3089\u304F\u5F85\u3063\u3066\u304B\u3089\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001DNS\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002" } } } } } }, provider_details: { save_button_label: "\u4FDD\u5B58" } }, delete_sso_provider: { title: "\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u524A\u9664", description: "\u4E00\u5EA6\u78BA\u8A8D\u3059\u308B\u3068\u3001\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002", delete_button_label: "\u524A\u9664", modal: { title: "${providerName}\u3092\u524A\u9664", description: "\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3067\u30B5\u30A4\u30F3\u30A4\u30F3\u3059\u308B\u30E6\u30FC\u30B6\u30FC\u306F\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u304F\u306A\u308A\u307E\u3059\u3002\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F", content: { description: "\u78BA\u8A8D\u306E\u305F\u3081\u306B\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002", field: { label: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u540D", placeholder: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u540D\u3092\u5165\u529B" } }, actions: { cancel_button_label: "\u30AD\u30E3\u30F3\u30BB\u30EB", delete_button_label: "\u524A\u9664" } } }, remove_sso_provider: { title: "\u7D44\u7E54\u304B\u3089\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u524A\u9664", description: "\u78BA\u8A8D\u5F8C\u3001\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002", remove_button_label: "\u524A\u9664", modal: { title: "${organizationName}\u304B\u3089${providerName}\u3092\u524A\u9664", description: "\u3053\u306E\u64CD\u4F5C\u306B\u3088\u308A\u3001\u3053\u306E\u7D44\u7E54\u306E\u3059\u3079\u3066\u306E\u30E6\u30FC\u30B6\u30FC\u306E${providerName}\u3078\u306E\u30A2\u30AF\u30BB\u30B9\u304C\u53D6\u308A\u6D88\u3055\u308C\u307E\u3059\u3002\u30E6\u30FC\u30B6\u30FC\u306F\u524A\u9664\u3055\u308C\u307E\u305B\u3093\u304C\u3001\u3053\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u4F7F\u7528\u3057\u3066\u30B5\u30A4\u30F3\u30A4\u30F3\u3067\u304D\u306A\u304F\u306A\u308A\u307E\u3059", content: { description: "\u78BA\u8A8D\u306E\u305F\u3081\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002", field: { label: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u540D", placeholder: "\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u540D\u3092\u5165\u529B" } }, actions: { cancel_button_text: "\u30AD\u30E3\u30F3\u30BB\u30EB", remove_button_text: "\u5B9F\u884C" } } }, sso_provider_details: { unsaved_changes_text: "\u672A\u4FDD\u5B58\u306E\u5909\u66F4", submit_button_label: "\u4FDD\u5B58" }, notifications: { delete_success: "${providerName}\u304C\u524A\u9664\u3055\u308C\u307E\u3057\u305F\u3002", remove_success: "${providerName}\u304C${organizationName}\u304B\u3089\u524A\u9664\u3055\u308C\u307E\u3057\u305F", update_success: "${providerName}\u3078\u306E\u5909\u66F4\u304C\u4FDD\u5B58\u3055\u308C\u307E\u3057\u305F\u3002", general_error: "\u30EA\u30AF\u30A8\u30B9\u30C8\u306E\u51E6\u7406\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001\u554F\u984C\u304C\u89E3\u6C7A\u3057\u306A\u3044\u5834\u5408\u306F\u30B5\u30DD\u30FC\u30C8\u306B\u304A\u554F\u3044\u5408\u308F\u305B\u304F\u3060\u3055\u3044\u3002", domain_create: { success: "${domainName}\u304C\u4F5C\u6210\u3055\u308C\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u306E\u4F5C\u6210\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002", on_before: "\u30C9\u30E1\u30A4\u30F3\u304C\u6709\u52B9\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002" }, domain_verify: { success: "${domainName}\u304C\u691C\u8A3C\u3055\u308C\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u306E\u691C\u8A3C\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002", on_before: "\u30C9\u30E1\u30A4\u30F3\u691C\u8A3C\u306E\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002", verification_failed: "${domainName}\u3092\u691C\u8A3C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u3057\u3070\u3089\u304F\u5F85\u3063\u3066\u304B\u3089\u518D\u5EA6\u304A\u8A66\u3057\u3044\u305F\u3060\u304F\u304B\u3001DNS\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002" }, domain_delete: { success: "${domainName}\u304C\u524A\u9664\u3055\u308C\u307E\u3057\u305F\u3002", error: "\u30C9\u30E1\u30A4\u30F3\u306E\u524A\u9664\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002" }, domain_associate_provider: { success: "${domain}\u304C${idp}\u3067\u6709\u52B9\u306B\u306A\u308A\u307E\u3057\u305F" }, domain_delete_provider: { success: "${domain}\u304C${idp}\u3067\u7121\u52B9\u306B\u306A\u308A\u307E\u3057\u305F" }, provisioning_disabled_success: "\u30D7\u30ED\u30D3\u30B8\u30E7\u30CB\u30F3\u30B0\u304C\u7121\u52B9\u306B\u306A\u308A\u307E\u3057\u305F\u3002", scim_token_delete_sucess: "\u30C8\u30FC\u30AF\u30F3\u304C\u524A\u9664\u3055\u308C\u307E\u3057\u305F\u3002", scim_token_create_success: "\u30C8\u30FC\u30AF\u30F3\u304C\u6B63\u5E38\u306B\u751F\u6210\u3055\u308C\u307E\u3057\u305F" } };
    i2 = { title: "\u591A\u8981\u7D20\u8A8D\u8A3C\u65B9\u6CD5", description: "\u3042\u306A\u305F\u306E\u30A2\u30AB\u30A6\u30F3\u30C8\u3068\u8EAB\u5143\u3092\u3055\u3089\u306B\u4FDD\u8B77\u3057\u307E\u3059", no_active_mfa: "\u767B\u9332\u3055\u308C\u3066\u3044\u308B\u591A\u8981\u7D20\u8A8D\u8A3C\u306F\u3042\u308A\u307E\u305B\u3093\u3002", component_error_title: "\u591A\u8981\u7D20\u8A8D\u8A3C\u30B3\u30F3\u30DD\u30FC\u30CD\u30F3\u30C8\u306E\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC", component_error_description: "\u591A\u8981\u7D20\u8A8D\u8A3C\u65B9\u6CD5\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u30DA\u30FC\u30B8\u3092\u518D\u8AAD\u307F\u8FBC\u307F\u3057\u3066\u3001\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044", loading: "\u8AAD\u307F\u8FBC\u307F\u4E2D...", delete: "\u524A\u9664", enroll: "\u767B\u9332", submit: "\u9001\u4FE1", update: "\u66F4\u65B0", remove: "\u524A\u9664", enrolling: "\u767B\u9332\u4E2D...", enrolled: "\u767B\u9332\u6E08\u307F", enabled: "\u6709\u52B9", enrollment: "\u767B\u9332", confirmation: "\u78BA\u8A8D", remove_factor: "\u767B\u9332\u3092\u6B63\u5E38\u306B\u524A\u9664\u3057\u307E\u3057\u305F\u3002", enroll_factor: "\u6B63\u5E38\u306B\u767B\u9332\u3055\u308C\u307E\u3057\u305F\u3002", enroll_totp_mfa: "\u30EF\u30F3\u30BF\u30A4\u30E0\u30D1\u30B9\u30EF\u30FC\u30C9\u306E\u767B\u9332", delete_factor: "${factorName}\u306E\u8A8D\u8A3C\u8981\u7D20\u3092\u524A\u9664", delete_mfa_title: "\u65E2\u5B58\u306E\u8A8D\u8A3C\u30B7\u30B9\u30C6\u30E0\u3092\u524A\u9664", delete_mfa_phone_consent: "\u3053\u306E\u96FB\u8A71\u756A\u53F7\u3092SMS MFA\u304B\u3089\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F", delete_mfa_email_consent: "\u3053\u306EE\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F", delete_mfa_totp_consent: "\u3053\u306E\u8A8D\u8A3C\u30A2\u30D7\u30EA\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F", "delete_mfa_push-notification_consent": "\u30D7\u30C3\u30B7\u30E5\u901A\u77E5\u306B\u3088\u308B\u8A8D\u8A3C\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F", "delete_mfa_recovery-code_consent": "\u3053\u306E\u30EA\u30AB\u30D0\u30EA\u30FC\u30B3\u30FC\u30C9\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F", cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB", close: "\u9589\u3058\u308B", next: "\u6B21\u3078", back: "\u623B\u308B", "yes-remove": "\u306F\u3044\u3001\u524A\u9664\u3057\u307E\u3059", "app-store": "App Store", "google-play": "Google Play", ok: "\u306F\u3044", confirm: "\u78BA\u8A8D", continue: "\u7D9A\u884C", confirm_delete: "\u524A\u9664", deleting: "\u524A\u9664\u4E2D...", errors: { factors_loading_error: "\u591A\u8981\u7D20\u8A8D\u8A3C\u306E\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC\uFF01", unknown_error: "\u4E0D\u660E\u306A\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F", delete_factor: "\u8A8D\u8A3C\u5668\u306E\u524A\u9664\u306B\u5931\u6557\u3057\u307E\u3057\u305F", failed: "\u5931\u6557\u3057\u307E\u3057\u305F: ${message}", phone_number_required: "SMS\u767B\u9332\u306B\u306F\u96FB\u8A71\u756A\u53F7\u304C\u5FC5\u8981\u3067\u3059\u3002", email_required: "\u30E1\u30FC\u30EB\u767B\u9332\u306B\u306F\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u304C\u5FC5\u8981\u3067\u3059\u3002", invalid_email: "\u7121\u52B9\u306A\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9", invalid_phone_number: "\u7121\u52B9\u306A\u96FB\u8A71\u756A\u53F7", unsupported_mfa_type: "\u672A\u5BFE\u5FDC\u306EMFA\u30BF\u30A4\u30D7\u3067\u3059: ${factorName}", "push-notification": { too_many_entities: "\u3053\u306E\u30E6\u30FC\u30B6\u30FC\u306E\u30D7\u30C3\u30B7\u30E5\u901A\u77E5\u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\u306E\u6570\u306B\u306F\u4E0A\u9650\u304C\u3042\u308A\u307E\u3059\u3002", unsupported_challenge_type: "Auth0 Verifier \u304C\u30C6\u30CA\u30F3\u30C8\u3067\u7121\u52B9\u306B\u306A\u3063\u3066\u3044\u307E\u3059\u3002\u30C0\u30C3\u30B7\u30E5\u30DC\u30FC\u30C9\u306E Guardian MFA \u30BB\u30AF\u30B7\u30E7\u30F3\u3067\u300C\u30D7\u30C3\u30B7\u30E5\u901A\u77E5\u300D\u3092\u30AA\u30F3\u306B\u3059\u308B\u3068\u6709\u52B9\u306B\u3067\u304D\u307E\u3059\u3002", invalid_request: "\u5FC5\u9808\u30D1\u30E9\u30E1\u30FC\u30BF\u30FC\u304C\u3042\u308A\u307E\u305B\u3093", authorization_pending: "\u627F\u8A8D\u4FDD\u7559\u4E2D: \u6570\u79D2\u5F8C\u306B\u30EA\u30AF\u30A8\u30B9\u30C8\u3092\u518D\u8A66\u884C\u3057\u3066\u304F\u3060\u3055\u3044\u3002" }, totp: { invalid_request: "\u5FC5\u9808\u30D1\u30E9\u30E1\u30FC\u30BF\u30FC\u304C\u3042\u308A\u307E\u305B\u3093", too_many_entities: "\u3053\u306E\u30E6\u30FC\u30B6\u30FC\u306ETOTP\u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\u306E\u6570\u306B\u306F\u4E0A\u9650\u304C\u3042\u308A\u307E\u3059\u3002", unsupported_challenge_type: "OTP Verifier \u304C\u30C6\u30CA\u30F3\u30C8\u3067\u7121\u52B9\u306B\u306A\u3063\u3066\u3044\u307E\u3059\u3002\u30C0\u30C3\u30B7\u30E5\u30DC\u30FC\u30C9\u306E Guardian MFA \u30BB\u30AF\u30B7\u30E7\u30F3\u3067\u300C\u30D7\u30C3\u30B7\u30E5\u901A\u77E5\u300D\u3092\u30AA\u30F3\u306B\u3059\u308B\u3068\u6709\u52B9\u306B\u3067\u304D\u307E\u3059\uFF08\u30D7\u30C3\u30B7\u30E5\u901A\u77E5\u306B\u306FOTP\u304C\u542B\u307E\u308C\u307E\u3059\uFF09\u3002", invalid_grant: "OTP\u30B3\u30FC\u30C9\u304C\u7121\u52B9\u3067\u3059" }, phone: { unsupported_challenge_type: "SMS Verifier \u304C\u30C6\u30CA\u30F3\u30C8\u3067\u7121\u52B9\u306B\u306A\u3063\u3066\u3044\u307E\u3059\u3002\u30C0\u30C3\u30B7\u30E5\u30DC\u30FC\u30C9\u306E Guardian MFA \u30BB\u30AF\u30B7\u30E7\u30F3\u3067\u300CSMS\u300D\u3092\u30AA\u30F3\u306B\u3059\u308B\u3068\u6709\u52B9\u306B\u3067\u304D\u307E\u3059\u3002", bad_gateway: "\u96FB\u8A71\u756A\u53F7\u304C\u7121\u52B9\u3067\u3059\u3002", too_many_entities: "\u3053\u306E\u30E6\u30FC\u30B6\u30FC\u306ESMS\u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\u306E\u6570\u306B\u306F\u4E0A\u9650\u304C\u3042\u308A\u307E\u3059\u3002" }, email: { expired_token: "\u78BA\u8A8D\u30B3\u30FC\u30C9\u306E\u6709\u52B9\u671F\u9650\u304C\u5207\u308C\u307E\u3057\u305F", invalid_grant: "\u30B3\u30FC\u30C9\u304C\u7121\u52B9\u3067\u3059", access_denied: "\u8981\u6C42\u3055\u308C\u305F\u8A8D\u8A3C\u6A5F\u80FD\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F", too_many_entities: "\u3053\u306E\u30E6\u30FC\u30B6\u30FC\u306E\u30E1\u30FC\u30EB\u30A8\u30F3\u30C6\u30A3\u30C6\u30A3\u306E\u6570\u306B\u306F\u4E0A\u9650\u304C\u3042\u308A\u307E\u3059\u3002" } }, phone: { title: "\u96FB\u8A71\u30E1\u30C3\u30BB\u30FC\u30B8 ", description: "\u96FB\u8A71\u756A\u53F7\u304C\u8FFD\u52A0\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002", "button-text": "SMS\u7528\u96FB\u8A71\u756A\u53F7\u3092\u8FFD\u52A0" }, "push-notification": { title: "Auth0 Guardian \u30D7\u30C3\u30B7\u30E5\u901A\u77E5", description: "\u30D7\u30C3\u30B7\u30E5\u8A8D\u8A3C\u304C\u8FFD\u52A0\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002", "button-text": "\u30D7\u30C3\u30B7\u30E5\u8A8D\u8A3C\u3092\u8FFD\u52A0" }, totp: { title: "\u30EF\u30F3\u30BF\u30A4\u30E0\u30D1\u30B9\u30EF\u30FC\u30C9", description: "\u8A8D\u8A3C\u30B7\u30B9\u30C6\u30E0\u304C\u8FFD\u52A0\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002", "button-text": "\u8A8D\u8A3C\u30A2\u30D7\u30EA\u3092\u8FFD\u52A0" }, email: { title: "\u30E1\u30FC\u30EB", description: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u304C\u8FFD\u52A0\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002", "button-text": "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u3092\u8FFD\u52A0" }, duo: { title: "Duo\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3", description: "\u591A\u8981\u7D20\u8A8D\u8A3C\u306BDuo\u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002" }, "webauthn-roaming": { title: "FIDO\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30AD\u30FC\u306B\u3088\u308BWebAuthn", description: "\u4E8C\u8981\u7D20\u8A8D\u8A3C\u3068\u3057\u3066WebAuthn\u5BFE\u5FDC\u306E\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30AD\u30FC\uFF08FIDO2\u306A\u3069\uFF09\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002", "button-text": "FIDO \u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30AD\u30FC\u3067WebAuthn\u3092\u8FFD\u52A0" }, "webauthn-platform": { title: "\u30C7\u30D0\u30A4\u30B9\u751F\u4F53\u8A8D\u8A3C\u306B\u3088\u308BWebAuthn", description: "\u4E8C\u8981\u7D20\u8A8D\u8A3C\u3068\u3057\u3066WebAuthn\u5BFE\u5FDC\u306E\u30C7\u30D0\u30A4\u30B9\u751F\u4F53\u8A8D\u8A3C\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002", "button-text": "FIDO\u30C7\u30D0\u30A4\u30B9\u751F\u4F53\u8A8D\u8A3C\u3067WebAuthn\u3092\u8FFD\u52A0" }, "recovery-code": { title: "\u30EA\u30AB\u30D0\u30EA\u30FC\u30B3\u30FC\u30C9", description: "\u30A2\u30AB\u30A6\u30F3\u30C8\u3078\u306E\u30A2\u30AF\u30BB\u30B9\u3092\u56DE\u5FA9\u3059\u308B\u305F\u3081\u306B\u56FA\u6709\u306E\u30EA\u30AB\u30D0\u30EA\u30FC\u30B3\u30FC\u30C9\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002", "button-text": "\u30EA\u30AB\u30D0\u30EA\u30FC\u30B3\u30FC\u30C9\u3092\u518D\u751F\u6210" }, enrollment_form: { email_address: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9", phone_number: "\u96FB\u8A71\u756A\u53F7 (SMS)", send_code: "\u30B3\u30FC\u30C9\u3092\u9001\u4FE1", sending: "\u9001\u4FE1\u4E2D...", enroll_title: "\u672C\u4EBA\u78BA\u8A8D", enroll_email_placeholder: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u3092\u5165\u529B", enroll_email_description: "\u8A8D\u8A3C\u30B3\u30FC\u30C9\u3092\u53D7\u4FE1\u3059\u308B\u305F\u3081\u306B\u3042\u306A\u305F\u306E\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", enroll_sms_placeholder: "\u96FB\u8A71\u756A\u53F7\u3092\u5165\u529B", enroll_sms_description: "\u8A8D\u8A3C\u30B3\u30FC\u30C9\u3092\u53D7\u4FE1\u3059\u308B\u305F\u3081\u306B\u3042\u306A\u305F\u306E\u96FB\u8A71\u756A\u53F7\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", show_auth0_guardian_title: "\u3053\u306EQR\u30B3\u30FC\u30C9\u3092Auth0 Guardian\u30A2\u30D7\u30EA\u3067\u30B9\u30AD\u30E3\u30F3\u3059\u308B\u304B\u3001URL\u3092\u30B3\u30D4\u30FC\u3057\u3066\u3001\u3053\u306E\u8A8D\u8A3C\u65B9\u6CD5\u3092\u767B\u9332\u3057\u3066\u304F\u3060\u3055\u3044", recovery_code_description: "\u3053\u306E\u30EA\u30AB\u30D0\u30EA\u30FC\u30B3\u30FC\u30C9\u3092\u30B3\u30D4\u30FC\u3057\u3066\u3001\u5B89\u5168\u306A\u5834\u6240\u306B\u4FDD\u7BA1\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u30C7\u30D0\u30A4\u30B9\u306A\u3057\u3067\u30ED\u30B0\u30A4\u30F3\u3059\u308B\u5FC5\u8981\u304C\u3042\u308B\u5834\u5408\u306B\u4F7F\u7528\u3057\u307E\u3059\u3002", show_otp: { title: "\u3053\u306E QR \u30B3\u30FC\u30C9\u3092 Authenticator \u30A2\u30D7\u30EA\u3067\u30B9\u30AD\u30E3\u30F3\u3057\u3066\u3001\u3053\u306E\u8A8D\u8A3C\u65B9\u6CD5\u3092\u767B\u9332\u3059\u308B\u304B\u3001\u30B3\u30FC\u30C9\u3092\u30B3\u30D4\u30FC\u3057\u3066\u304F\u3060\u3055\u3044\u3002", save_recovery: "\u3053\u308C\u3089\u306E\u30EA\u30AB\u30D0\u30EA\u30FC\u30B3\u30FC\u30C9\u3092\u4FDD\u5B58\u3057\u3066\u304F\u3060\u3055\u3044\uFF01", enter_code: "\u8A8D\u8A3C\u30A2\u30D7\u30EA\u306E\u30B3\u30FC\u30C9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", one_time_passcode: "\u30EF\u30F3\u30BF\u30A4\u30E0\u30D1\u30B9\u30B3\u30FC\u30C9", verify_code: "\u30B3\u30FC\u30C9\u3092\u78BA\u8A8D", copy_as_code: "\u30B3\u30FC\u30C9\u3068\u3057\u3066\u30B3\u30D4\u30FC", verifying: "\u78BA\u8A8D\u4E2D...", enter_verify_code: "${verifier}\u306B\u9001\u4FE1\u3055\u308C\u305F6\u6841\u306E\u30B3\u30FC\u30C9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", enter_opt_code: "\u8A8D\u8A3C\u30A2\u30D7\u30EA\u306E\u30B3\u30FC\u30C9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044", install_guardian_description: "\u7D9A\u884C\u3059\u308B\u306B\u306F\u3001\u304A\u4F7F\u3044\u306E\u30E2\u30D0\u30A4\u30EB\u30C7\u30D0\u30A4\u30B9\u304B\u3089\u30A2\u30D7\u30EA\u30B9\u30C8\u30A2\u7D4C\u7531\u3067Auth0 Guardian\u30A2\u30D7\u30EA\u3092\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u3057\u3066\u304F\u3060\u3055\u3044\u3002" } } };
    n2 = { common: o2, domain_management: r2, org_management: a2, idp_management: l2, mfa: i2 };
  }
});
function __insertCSS(code) {
  if (typeof document == "undefined") return;
  let head = document.head || document.getElementsByTagName("head")[0];
  let style = document.createElement("style");
  style.type = "text/css";
  head.appendChild(style);
  style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));
}
var getAsset = (type) => {
  switch (type) {
    case "success":
      return SuccessIcon;
    case "info":
      return InfoIcon;
    case "warning":
      return WarningIcon;
    case "error":
      return ErrorIcon;
    default:
      return null;
  }
};
var bars = Array(12).fill(0);
var Loader = ({ visible, className }) => {
  return /* @__PURE__ */ React__default.createElement("div", {
    className: [
      "sonner-loading-wrapper",
      className
    ].filter(Boolean).join(" "),
    "data-visible": visible
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "sonner-spinner"
  }, bars.map((_2, i5) => /* @__PURE__ */ React__default.createElement("div", {
    className: "sonner-loading-bar",
    key: `spinner-bar-${i5}`
  }))));
};
var SuccessIcon = /* @__PURE__ */ React__default.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ React__default.createElement("path", {
  fillRule: "evenodd",
  d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
  clipRule: "evenodd"
}));
var WarningIcon = /* @__PURE__ */ React__default.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ React__default.createElement("path", {
  fillRule: "evenodd",
  d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
  clipRule: "evenodd"
}));
var InfoIcon = /* @__PURE__ */ React__default.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ React__default.createElement("path", {
  fillRule: "evenodd",
  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
  clipRule: "evenodd"
}));
var ErrorIcon = /* @__PURE__ */ React__default.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ React__default.createElement("path", {
  fillRule: "evenodd",
  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
  clipRule: "evenodd"
}));
var CloseIcon = /* @__PURE__ */ React__default.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "1.5",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}, /* @__PURE__ */ React__default.createElement("line", {
  x1: "18",
  y1: "6",
  x2: "6",
  y2: "18"
}), /* @__PURE__ */ React__default.createElement("line", {
  x1: "6",
  y1: "6",
  x2: "18",
  y2: "18"
}));
var useIsDocumentHidden = () => {
  const [isDocumentHidden, setIsDocumentHidden] = React__default.useState(document.hidden);
  React__default.useEffect(() => {
    const callback = () => {
      setIsDocumentHidden(document.hidden);
    };
    document.addEventListener("visibilitychange", callback);
    return () => window.removeEventListener("visibilitychange", callback);
  }, []);
  return isDocumentHidden;
};
var toastsCounter = 1;
var Observer = class {
  constructor() {
    this.subscribe = (subscriber) => {
      this.subscribers.push(subscriber);
      return () => {
        const index2 = this.subscribers.indexOf(subscriber);
        this.subscribers.splice(index2, 1);
      };
    };
    this.publish = (data) => {
      this.subscribers.forEach((subscriber) => subscriber(data));
    };
    this.addToast = (data) => {
      this.publish(data);
      this.toasts = [
        ...this.toasts,
        data
      ];
    };
    this.create = (data) => {
      var _data_id;
      const { message, ...rest } = data;
      const id = typeof (data == null ? void 0 : data.id) === "number" || ((_data_id = data.id) == null ? void 0 : _data_id.length) > 0 ? data.id : toastsCounter++;
      const alreadyExists = this.toasts.find((toast2) => {
        return toast2.id === id;
      });
      const dismissible = data.dismissible === void 0 ? true : data.dismissible;
      if (this.dismissedToasts.has(id)) {
        this.dismissedToasts.delete(id);
      }
      if (alreadyExists) {
        this.toasts = this.toasts.map((toast2) => {
          if (toast2.id === id) {
            this.publish({
              ...toast2,
              ...data,
              id,
              title: message
            });
            return {
              ...toast2,
              ...data,
              id,
              dismissible,
              title: message
            };
          }
          return toast2;
        });
      } else {
        this.addToast({
          title: message,
          ...rest,
          dismissible,
          id
        });
      }
      return id;
    };
    this.dismiss = (id) => {
      if (id) {
        this.dismissedToasts.add(id);
        requestAnimationFrame(() => this.subscribers.forEach((subscriber) => subscriber({
          id,
          dismiss: true
        })));
      } else {
        this.toasts.forEach((toast2) => {
          this.subscribers.forEach((subscriber) => subscriber({
            id: toast2.id,
            dismiss: true
          }));
        });
      }
      return id;
    };
    this.message = (message, data) => {
      return this.create({
        ...data,
        message
      });
    };
    this.error = (message, data) => {
      return this.create({
        ...data,
        message,
        type: "error"
      });
    };
    this.success = (message, data) => {
      return this.create({
        ...data,
        type: "success",
        message
      });
    };
    this.info = (message, data) => {
      return this.create({
        ...data,
        type: "info",
        message
      });
    };
    this.warning = (message, data) => {
      return this.create({
        ...data,
        type: "warning",
        message
      });
    };
    this.loading = (message, data) => {
      return this.create({
        ...data,
        type: "loading",
        message
      });
    };
    this.promise = (promise, data) => {
      if (!data) {
        return;
      }
      let id = void 0;
      if (data.loading !== void 0) {
        id = this.create({
          ...data,
          promise,
          type: "loading",
          message: data.loading,
          description: typeof data.description !== "function" ? data.description : void 0
        });
      }
      const p = Promise.resolve(promise instanceof Function ? promise() : promise);
      let shouldDismiss = id !== void 0;
      let result;
      const originalPromise = p.then(async (response) => {
        result = [
          "resolve",
          response
        ];
        const isReactElementResponse = React__default.isValidElement(response);
        if (isReactElementResponse) {
          shouldDismiss = false;
          this.create({
            id,
            type: "default",
            message: response
          });
        } else if (isHttpResponse(response) && !response.ok) {
          shouldDismiss = false;
          const promiseData = typeof data.error === "function" ? await data.error(`HTTP error! status: ${response.status}`) : data.error;
          const description = typeof data.description === "function" ? await data.description(`HTTP error! status: ${response.status}`) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React__default.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "error",
            description,
            ...toastSettings
          });
        } else if (response instanceof Error) {
          shouldDismiss = false;
          const promiseData = typeof data.error === "function" ? await data.error(response) : data.error;
          const description = typeof data.description === "function" ? await data.description(response) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React__default.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "error",
            description,
            ...toastSettings
          });
        } else if (data.success !== void 0) {
          shouldDismiss = false;
          const promiseData = typeof data.success === "function" ? await data.success(response) : data.success;
          const description = typeof data.description === "function" ? await data.description(response) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React__default.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "success",
            description,
            ...toastSettings
          });
        }
      }).catch(async (error) => {
        result = [
          "reject",
          error
        ];
        if (data.error !== void 0) {
          shouldDismiss = false;
          const promiseData = typeof data.error === "function" ? await data.error(error) : data.error;
          const description = typeof data.description === "function" ? await data.description(error) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React__default.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "error",
            description,
            ...toastSettings
          });
        }
      }).finally(() => {
        if (shouldDismiss) {
          this.dismiss(id);
          id = void 0;
        }
        data.finally == null ? void 0 : data.finally.call(data);
      });
      const unwrap = () => new Promise((resolve, reject) => originalPromise.then(() => result[0] === "reject" ? reject(result[1]) : resolve(result[1])).catch(reject));
      if (typeof id !== "string" && typeof id !== "number") {
        return {
          unwrap
        };
      } else {
        return Object.assign(id, {
          unwrap
        });
      }
    };
    this.custom = (jsx47, data) => {
      const id = (data == null ? void 0 : data.id) || toastsCounter++;
      this.create({
        jsx: jsx47(id),
        id,
        ...data
      });
      return id;
    };
    this.getActiveToasts = () => {
      return this.toasts.filter((toast2) => !this.dismissedToasts.has(toast2.id));
    };
    this.subscribers = [];
    this.toasts = [];
    this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var ToastState = new Observer();
var toastFunction = (message, data) => {
  const id = (data == null ? void 0 : data.id) || toastsCounter++;
  ToastState.addToast({
    title: message,
    ...data,
    id
  });
  return id;
};
var isHttpResponse = (data) => {
  return data && typeof data === "object" && "ok" in data && typeof data.ok === "boolean" && "status" in data && typeof data.status === "number";
};
var basicToast = toastFunction;
var getHistory = () => ToastState.toasts;
var getToasts = () => ToastState.getActiveToasts();
Object.assign(basicToast, {
  success: ToastState.success,
  info: ToastState.info,
  warning: ToastState.warning,
  error: ToastState.error,
  custom: ToastState.custom,
  message: ToastState.message,
  promise: ToastState.promise,
  dismiss: ToastState.dismiss,
  loading: ToastState.loading
}, {
  getHistory,
  getToasts
});
__insertCSS("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function isAction(action) {
  return action.label !== void 0;
}
var VISIBLE_TOASTS_AMOUNT = 3;
var VIEWPORT_OFFSET = "24px";
var MOBILE_VIEWPORT_OFFSET = "16px";
var TOAST_LIFETIME = 4e3;
var TOAST_WIDTH = 356;
var GAP = 14;
var SWIPE_THRESHOLD = 45;
var TIME_BEFORE_UNMOUNT = 200;
function cn(...classes) {
  return classes.filter(Boolean).join(" ");
}
function getDefaultSwipeDirections(position) {
  const [y2, x] = position.split("-");
  const directions = [];
  if (y2) {
    directions.push(y2);
  }
  if (x) {
    directions.push(x);
  }
  return directions;
}
var Toast = (props) => {
  var _toast_classNames, _toast_classNames1, _toast_classNames2, _toast_classNames3, _toast_classNames4, _toast_classNames5, _toast_classNames6, _toast_classNames7, _toast_classNames8;
  const { invert: ToasterInvert, toast: toast2, unstyled, interacting, setHeights, visibleToasts, heights, index: index2, toasts, expanded, removeToast, defaultRichColors, closeButton: closeButtonFromToaster, style, cancelButtonStyle, actionButtonStyle, className = "", descriptionClassName = "", duration: durationFromToaster, position, gap, expandByDefault, classNames, icons, closeButtonAriaLabel = "Close toast" } = props;
  const [swipeDirection, setSwipeDirection] = React__default.useState(null);
  const [swipeOutDirection, setSwipeOutDirection] = React__default.useState(null);
  const [mounted, setMounted] = React__default.useState(false);
  const [removed, setRemoved] = React__default.useState(false);
  const [swiping, setSwiping] = React__default.useState(false);
  const [swipeOut, setSwipeOut] = React__default.useState(false);
  const [isSwiped, setIsSwiped] = React__default.useState(false);
  const [offsetBeforeRemove, setOffsetBeforeRemove] = React__default.useState(0);
  const [initialHeight, setInitialHeight] = React__default.useState(0);
  const remainingTime = React__default.useRef(toast2.duration || durationFromToaster || TOAST_LIFETIME);
  const dragStartTime = React__default.useRef(null);
  const toastRef = React__default.useRef(null);
  const isFront = index2 === 0;
  const isVisible = index2 + 1 <= visibleToasts;
  const toastType = toast2.type;
  const dismissible = toast2.dismissible !== false;
  const toastClassname = toast2.className || "";
  const toastDescriptionClassname = toast2.descriptionClassName || "";
  const heightIndex = React__default.useMemo(() => heights.findIndex((height) => height.toastId === toast2.id) || 0, [
    heights,
    toast2.id
  ]);
  const closeButton = React__default.useMemo(() => {
    var _toast_closeButton;
    return (_toast_closeButton = toast2.closeButton) != null ? _toast_closeButton : closeButtonFromToaster;
  }, [
    toast2.closeButton,
    closeButtonFromToaster
  ]);
  const duration = React__default.useMemo(() => toast2.duration || durationFromToaster || TOAST_LIFETIME, [
    toast2.duration,
    durationFromToaster
  ]);
  const closeTimerStartTimeRef = React__default.useRef(0);
  const offset4 = React__default.useRef(0);
  const lastCloseTimerStartTimeRef = React__default.useRef(0);
  const pointerStartRef = React__default.useRef(null);
  const [y2, x] = position.split("-");
  const toastsHeightBefore = React__default.useMemo(() => {
    return heights.reduce((prev, curr, reducerIndex) => {
      if (reducerIndex >= heightIndex) {
        return prev;
      }
      return prev + curr.height;
    }, 0);
  }, [
    heights,
    heightIndex
  ]);
  const isDocumentHidden = useIsDocumentHidden();
  const invert = toast2.invert || ToasterInvert;
  const disabled = toastType === "loading";
  offset4.current = React__default.useMemo(() => heightIndex * gap + toastsHeightBefore, [
    heightIndex,
    toastsHeightBefore
  ]);
  React__default.useEffect(() => {
    remainingTime.current = duration;
  }, [
    duration
  ]);
  React__default.useEffect(() => {
    setMounted(true);
  }, []);
  React__default.useEffect(() => {
    const toastNode = toastRef.current;
    if (toastNode) {
      const height = toastNode.getBoundingClientRect().height;
      setInitialHeight(height);
      setHeights((h2) => [
        {
          toastId: toast2.id,
          height,
          position: toast2.position
        },
        ...h2
      ]);
      return () => setHeights((h2) => h2.filter((height2) => height2.toastId !== toast2.id));
    }
  }, [
    setHeights,
    toast2.id
  ]);
  React__default.useLayoutEffect(() => {
    if (!mounted) return;
    const toastNode = toastRef.current;
    const originalHeight = toastNode.style.height;
    toastNode.style.height = "auto";
    const newHeight = toastNode.getBoundingClientRect().height;
    toastNode.style.height = originalHeight;
    setInitialHeight(newHeight);
    setHeights((heights2) => {
      const alreadyExists = heights2.find((height) => height.toastId === toast2.id);
      if (!alreadyExists) {
        return [
          {
            toastId: toast2.id,
            height: newHeight,
            position: toast2.position
          },
          ...heights2
        ];
      } else {
        return heights2.map((height) => height.toastId === toast2.id ? {
          ...height,
          height: newHeight
        } : height);
      }
    });
  }, [
    mounted,
    toast2.title,
    toast2.description,
    setHeights,
    toast2.id,
    toast2.jsx,
    toast2.action,
    toast2.cancel
  ]);
  const deleteToast = React__default.useCallback(() => {
    setRemoved(true);
    setOffsetBeforeRemove(offset4.current);
    setHeights((h2) => h2.filter((height) => height.toastId !== toast2.id));
    setTimeout(() => {
      removeToast(toast2);
    }, TIME_BEFORE_UNMOUNT);
  }, [
    toast2,
    removeToast,
    setHeights,
    offset4
  ]);
  React__default.useEffect(() => {
    if (toast2.promise && toastType === "loading" || toast2.duration === Infinity || toast2.type === "loading") return;
    let timeoutId;
    const pauseTimer = () => {
      if (lastCloseTimerStartTimeRef.current < closeTimerStartTimeRef.current) {
        const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
        remainingTime.current = remainingTime.current - elapsedTime;
      }
      lastCloseTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
    };
    const startTimer = () => {
      if (remainingTime.current === Infinity) return;
      closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
      timeoutId = setTimeout(() => {
        toast2.onAutoClose == null ? void 0 : toast2.onAutoClose.call(toast2, toast2);
        deleteToast();
      }, remainingTime.current);
    };
    if (expanded || interacting || isDocumentHidden) {
      pauseTimer();
    } else {
      startTimer();
    }
    return () => clearTimeout(timeoutId);
  }, [
    expanded,
    interacting,
    toast2,
    toastType,
    isDocumentHidden,
    deleteToast
  ]);
  React__default.useEffect(() => {
    if (toast2.delete) {
      deleteToast();
      toast2.onDismiss == null ? void 0 : toast2.onDismiss.call(toast2, toast2);
    }
  }, [
    deleteToast,
    toast2.delete
  ]);
  function getLoadingIcon() {
    var _toast_classNames9;
    if (icons == null ? void 0 : icons.loading) {
      var _toast_classNames12;
      return /* @__PURE__ */ React__default.createElement("div", {
        className: cn(classNames == null ? void 0 : classNames.loader, toast2 == null ? void 0 : (_toast_classNames12 = toast2.classNames) == null ? void 0 : _toast_classNames12.loader, "sonner-loader"),
        "data-visible": toastType === "loading"
      }, icons.loading);
    }
    return /* @__PURE__ */ React__default.createElement(Loader, {
      className: cn(classNames == null ? void 0 : classNames.loader, toast2 == null ? void 0 : (_toast_classNames9 = toast2.classNames) == null ? void 0 : _toast_classNames9.loader),
      visible: toastType === "loading"
    });
  }
  const icon = toast2.icon || (icons == null ? void 0 : icons[toastType]) || getAsset(toastType);
  var _toast_richColors, _icons_close;
  return /* @__PURE__ */ React__default.createElement("li", {
    tabIndex: 0,
    ref: toastRef,
    className: cn(className, toastClassname, classNames == null ? void 0 : classNames.toast, toast2 == null ? void 0 : (_toast_classNames = toast2.classNames) == null ? void 0 : _toast_classNames.toast, classNames == null ? void 0 : classNames.default, classNames == null ? void 0 : classNames[toastType], toast2 == null ? void 0 : (_toast_classNames1 = toast2.classNames) == null ? void 0 : _toast_classNames1[toastType]),
    "data-sonner-toast": "",
    "data-rich-colors": (_toast_richColors = toast2.richColors) != null ? _toast_richColors : defaultRichColors,
    "data-styled": !Boolean(toast2.jsx || toast2.unstyled || unstyled),
    "data-mounted": mounted,
    "data-promise": Boolean(toast2.promise),
    "data-swiped": isSwiped,
    "data-removed": removed,
    "data-visible": isVisible,
    "data-y-position": y2,
    "data-x-position": x,
    "data-index": index2,
    "data-front": isFront,
    "data-swiping": swiping,
    "data-dismissible": dismissible,
    "data-type": toastType,
    "data-invert": invert,
    "data-swipe-out": swipeOut,
    "data-swipe-direction": swipeOutDirection,
    "data-expanded": Boolean(expanded || expandByDefault && mounted),
    "data-testid": toast2.testId,
    style: {
      "--index": index2,
      "--toasts-before": index2,
      "--z-index": toasts.length - index2,
      "--offset": `${removed ? offsetBeforeRemove : offset4.current}px`,
      "--initial-height": expandByDefault ? "auto" : `${initialHeight}px`,
      ...style,
      ...toast2.style
    },
    onDragEnd: () => {
      setSwiping(false);
      setSwipeDirection(null);
      pointerStartRef.current = null;
    },
    onPointerDown: (event) => {
      if (event.button === 2) return;
      if (disabled || !dismissible) return;
      dragStartTime.current = /* @__PURE__ */ new Date();
      setOffsetBeforeRemove(offset4.current);
      event.target.setPointerCapture(event.pointerId);
      if (event.target.tagName === "BUTTON") return;
      setSwiping(true);
      pointerStartRef.current = {
        x: event.clientX,
        y: event.clientY
      };
    },
    onPointerUp: () => {
      var _toastRef_current, _toastRef_current1, _dragStartTime_current;
      if (swipeOut || !dismissible) return;
      pointerStartRef.current = null;
      const swipeAmountX = Number(((_toastRef_current = toastRef.current) == null ? void 0 : _toastRef_current.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0);
      const swipeAmountY = Number(((_toastRef_current1 = toastRef.current) == null ? void 0 : _toastRef_current1.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0);
      const timeTaken = (/* @__PURE__ */ new Date()).getTime() - ((_dragStartTime_current = dragStartTime.current) == null ? void 0 : _dragStartTime_current.getTime());
      const swipeAmount = swipeDirection === "x" ? swipeAmountX : swipeAmountY;
      const velocity = Math.abs(swipeAmount) / timeTaken;
      if (Math.abs(swipeAmount) >= SWIPE_THRESHOLD || velocity > 0.11) {
        setOffsetBeforeRemove(offset4.current);
        toast2.onDismiss == null ? void 0 : toast2.onDismiss.call(toast2, toast2);
        if (swipeDirection === "x") {
          setSwipeOutDirection(swipeAmountX > 0 ? "right" : "left");
        } else {
          setSwipeOutDirection(swipeAmountY > 0 ? "down" : "up");
        }
        deleteToast();
        setSwipeOut(true);
        return;
      } else {
        var _toastRef_current2, _toastRef_current3;
        (_toastRef_current2 = toastRef.current) == null ? void 0 : _toastRef_current2.style.setProperty("--swipe-amount-x", `0px`);
        (_toastRef_current3 = toastRef.current) == null ? void 0 : _toastRef_current3.style.setProperty("--swipe-amount-y", `0px`);
      }
      setIsSwiped(false);
      setSwiping(false);
      setSwipeDirection(null);
    },
    onPointerMove: (event) => {
      var _window_getSelection, _toastRef_current, _toastRef_current1;
      if (!pointerStartRef.current || !dismissible) return;
      const isHighlighted = ((_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString().length) > 0;
      if (isHighlighted) return;
      const yDelta = event.clientY - pointerStartRef.current.y;
      const xDelta = event.clientX - pointerStartRef.current.x;
      var _props_swipeDirections;
      const swipeDirections = (_props_swipeDirections = props.swipeDirections) != null ? _props_swipeDirections : getDefaultSwipeDirections(position);
      if (!swipeDirection && (Math.abs(xDelta) > 1 || Math.abs(yDelta) > 1)) {
        setSwipeDirection(Math.abs(xDelta) > Math.abs(yDelta) ? "x" : "y");
      }
      let swipeAmount = {
        x: 0,
        y: 0
      };
      const getDampening = (delta) => {
        const factor = Math.abs(delta) / 20;
        return 1 / (1.5 + factor);
      };
      if (swipeDirection === "y") {
        if (swipeDirections.includes("top") || swipeDirections.includes("bottom")) {
          if (swipeDirections.includes("top") && yDelta < 0 || swipeDirections.includes("bottom") && yDelta > 0) {
            swipeAmount.y = yDelta;
          } else {
            const dampenedDelta = yDelta * getDampening(yDelta);
            swipeAmount.y = Math.abs(dampenedDelta) < Math.abs(yDelta) ? dampenedDelta : yDelta;
          }
        }
      } else if (swipeDirection === "x") {
        if (swipeDirections.includes("left") || swipeDirections.includes("right")) {
          if (swipeDirections.includes("left") && xDelta < 0 || swipeDirections.includes("right") && xDelta > 0) {
            swipeAmount.x = xDelta;
          } else {
            const dampenedDelta = xDelta * getDampening(xDelta);
            swipeAmount.x = Math.abs(dampenedDelta) < Math.abs(xDelta) ? dampenedDelta : xDelta;
          }
        }
      }
      if (Math.abs(swipeAmount.x) > 0 || Math.abs(swipeAmount.y) > 0) {
        setIsSwiped(true);
      }
      (_toastRef_current = toastRef.current) == null ? void 0 : _toastRef_current.style.setProperty("--swipe-amount-x", `${swipeAmount.x}px`);
      (_toastRef_current1 = toastRef.current) == null ? void 0 : _toastRef_current1.style.setProperty("--swipe-amount-y", `${swipeAmount.y}px`);
    }
  }, closeButton && !toast2.jsx && toastType !== "loading" ? /* @__PURE__ */ React__default.createElement("button", {
    "aria-label": closeButtonAriaLabel,
    "data-disabled": disabled,
    "data-close-button": true,
    onClick: disabled || !dismissible ? () => {
    } : () => {
      deleteToast();
      toast2.onDismiss == null ? void 0 : toast2.onDismiss.call(toast2, toast2);
    },
    className: cn(classNames == null ? void 0 : classNames.closeButton, toast2 == null ? void 0 : (_toast_classNames2 = toast2.classNames) == null ? void 0 : _toast_classNames2.closeButton)
  }, (_icons_close = icons == null ? void 0 : icons.close) != null ? _icons_close : CloseIcon) : null, (toastType || toast2.icon || toast2.promise) && toast2.icon !== null && ((icons == null ? void 0 : icons[toastType]) !== null || toast2.icon) ? /* @__PURE__ */ React__default.createElement("div", {
    "data-icon": "",
    className: cn(classNames == null ? void 0 : classNames.icon, toast2 == null ? void 0 : (_toast_classNames3 = toast2.classNames) == null ? void 0 : _toast_classNames3.icon)
  }, toast2.promise || toast2.type === "loading" && !toast2.icon ? toast2.icon || getLoadingIcon() : null, toast2.type !== "loading" ? icon : null) : null, /* @__PURE__ */ React__default.createElement("div", {
    "data-content": "",
    className: cn(classNames == null ? void 0 : classNames.content, toast2 == null ? void 0 : (_toast_classNames4 = toast2.classNames) == null ? void 0 : _toast_classNames4.content)
  }, /* @__PURE__ */ React__default.createElement("div", {
    "data-title": "",
    className: cn(classNames == null ? void 0 : classNames.title, toast2 == null ? void 0 : (_toast_classNames5 = toast2.classNames) == null ? void 0 : _toast_classNames5.title)
  }, toast2.jsx ? toast2.jsx : typeof toast2.title === "function" ? toast2.title() : toast2.title), toast2.description ? /* @__PURE__ */ React__default.createElement("div", {
    "data-description": "",
    className: cn(descriptionClassName, toastDescriptionClassname, classNames == null ? void 0 : classNames.description, toast2 == null ? void 0 : (_toast_classNames6 = toast2.classNames) == null ? void 0 : _toast_classNames6.description)
  }, typeof toast2.description === "function" ? toast2.description() : toast2.description) : null), /* @__PURE__ */ React__default.isValidElement(toast2.cancel) ? toast2.cancel : toast2.cancel && isAction(toast2.cancel) ? /* @__PURE__ */ React__default.createElement("button", {
    "data-button": true,
    "data-cancel": true,
    style: toast2.cancelButtonStyle || cancelButtonStyle,
    onClick: (event) => {
      if (!isAction(toast2.cancel)) return;
      if (!dismissible) return;
      toast2.cancel.onClick == null ? void 0 : toast2.cancel.onClick.call(toast2.cancel, event);
      deleteToast();
    },
    className: cn(classNames == null ? void 0 : classNames.cancelButton, toast2 == null ? void 0 : (_toast_classNames7 = toast2.classNames) == null ? void 0 : _toast_classNames7.cancelButton)
  }, toast2.cancel.label) : null, /* @__PURE__ */ React__default.isValidElement(toast2.action) ? toast2.action : toast2.action && isAction(toast2.action) ? /* @__PURE__ */ React__default.createElement("button", {
    "data-button": true,
    "data-action": true,
    style: toast2.actionButtonStyle || actionButtonStyle,
    onClick: (event) => {
      if (!isAction(toast2.action)) return;
      toast2.action.onClick == null ? void 0 : toast2.action.onClick.call(toast2.action, event);
      if (event.defaultPrevented) return;
      deleteToast();
    },
    className: cn(classNames == null ? void 0 : classNames.actionButton, toast2 == null ? void 0 : (_toast_classNames8 = toast2.classNames) == null ? void 0 : _toast_classNames8.actionButton)
  }, toast2.action.label) : null);
};
function getDocumentDirection() {
  if (typeof window === "undefined") return "ltr";
  if (typeof document === "undefined") return "ltr";
  const dirAttribute = document.documentElement.getAttribute("dir");
  if (dirAttribute === "auto" || !dirAttribute) {
    return window.getComputedStyle(document.documentElement).direction;
  }
  return dirAttribute;
}
function assignOffset(defaultOffset, mobileOffset) {
  const styles = {};
  [
    defaultOffset,
    mobileOffset
  ].forEach((offset4, index2) => {
    const isMobile = index2 === 1;
    const prefix = isMobile ? "--mobile-offset" : "--offset";
    const defaultValue = isMobile ? MOBILE_VIEWPORT_OFFSET : VIEWPORT_OFFSET;
    function assignAll(offset5) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((key) => {
        styles[`${prefix}-${key}`] = typeof offset5 === "number" ? `${offset5}px` : offset5;
      });
    }
    if (typeof offset4 === "number" || typeof offset4 === "string") {
      assignAll(offset4);
    } else if (typeof offset4 === "object") {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((key) => {
        if (offset4[key] === void 0) {
          styles[`${prefix}-${key}`] = defaultValue;
        } else {
          styles[`${prefix}-${key}`] = typeof offset4[key] === "number" ? `${offset4[key]}px` : offset4[key];
        }
      });
    } else {
      assignAll(defaultValue);
    }
  });
  return styles;
}
var Toaster = /* @__PURE__ */ React__default.forwardRef(function Toaster2(props, ref) {
  const { id, invert, position = "bottom-right", hotkey = [
    "altKey",
    "KeyT"
  ], expand, closeButton, className, offset: offset4, mobileOffset, theme = "light", richColors, duration, style, visibleToasts = VISIBLE_TOASTS_AMOUNT, toastOptions, dir = getDocumentDirection(), gap = GAP, icons, containerAriaLabel = "Notifications" } = props;
  const [toasts, setToasts] = React__default.useState([]);
  const filteredToasts = React__default.useMemo(() => {
    if (id) {
      return toasts.filter((toast2) => toast2.toasterId === id);
    }
    return toasts.filter((toast2) => !toast2.toasterId);
  }, [
    toasts,
    id
  ]);
  const possiblePositions = React__default.useMemo(() => {
    return Array.from(new Set([
      position
    ].concat(filteredToasts.filter((toast2) => toast2.position).map((toast2) => toast2.position))));
  }, [
    filteredToasts,
    position
  ]);
  const [heights, setHeights] = React__default.useState([]);
  const [expanded, setExpanded] = React__default.useState(false);
  const [interacting, setInteracting] = React__default.useState(false);
  const [actualTheme, setActualTheme] = React__default.useState(theme !== "system" ? theme : typeof window !== "undefined" ? window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : "light");
  const listRef = React__default.useRef(null);
  const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
  const lastFocusedElementRef = React__default.useRef(null);
  const isFocusWithinRef = React__default.useRef(false);
  const removeToast = React__default.useCallback((toastToRemove) => {
    setToasts((toasts2) => {
      var _toasts_find;
      if (!((_toasts_find = toasts2.find((toast2) => toast2.id === toastToRemove.id)) == null ? void 0 : _toasts_find.delete)) {
        ToastState.dismiss(toastToRemove.id);
      }
      return toasts2.filter(({ id: id2 }) => id2 !== toastToRemove.id);
    });
  }, []);
  React__default.useEffect(() => {
    return ToastState.subscribe((toast2) => {
      if (toast2.dismiss) {
        requestAnimationFrame(() => {
          setToasts((toasts2) => toasts2.map((t3) => t3.id === toast2.id ? {
            ...t3,
            delete: true
          } : t3));
        });
        return;
      }
      setTimeout(() => {
        ReactDOM__default.flushSync(() => {
          setToasts((toasts2) => {
            const indexOfExistingToast = toasts2.findIndex((t3) => t3.id === toast2.id);
            if (indexOfExistingToast !== -1) {
              return [
                ...toasts2.slice(0, indexOfExistingToast),
                {
                  ...toasts2[indexOfExistingToast],
                  ...toast2
                },
                ...toasts2.slice(indexOfExistingToast + 1)
              ];
            }
            return [
              toast2,
              ...toasts2
            ];
          });
        });
      });
    });
  }, [
    toasts
  ]);
  React__default.useEffect(() => {
    if (theme !== "system") {
      setActualTheme(theme);
      return;
    }
    if (theme === "system") {
      if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        setActualTheme("dark");
      } else {
        setActualTheme("light");
      }
    }
    if (typeof window === "undefined") return;
    const darkMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    try {
      darkMediaQuery.addEventListener("change", ({ matches }) => {
        if (matches) {
          setActualTheme("dark");
        } else {
          setActualTheme("light");
        }
      });
    } catch (error) {
      darkMediaQuery.addListener(({ matches }) => {
        try {
          if (matches) {
            setActualTheme("dark");
          } else {
            setActualTheme("light");
          }
        } catch (e2) {
          console.error(e2);
        }
      });
    }
  }, [
    theme
  ]);
  React__default.useEffect(() => {
    if (toasts.length <= 1) {
      setExpanded(false);
    }
  }, [
    toasts
  ]);
  React__default.useEffect(() => {
    const handleKeyDown = (event) => {
      var _listRef_current;
      const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
      if (isHotkeyPressed) {
        var _listRef_current1;
        setExpanded(true);
        (_listRef_current1 = listRef.current) == null ? void 0 : _listRef_current1.focus();
      }
      if (event.code === "Escape" && (document.activeElement === listRef.current || ((_listRef_current = listRef.current) == null ? void 0 : _listRef_current.contains(document.activeElement)))) {
        setExpanded(false);
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [
    hotkey
  ]);
  React__default.useEffect(() => {
    if (listRef.current) {
      return () => {
        if (lastFocusedElementRef.current) {
          lastFocusedElementRef.current.focus({
            preventScroll: true
          });
          lastFocusedElementRef.current = null;
          isFocusWithinRef.current = false;
        }
      };
    }
  }, [
    listRef.current
  ]);
  return (
    // Remove item from normal navigation flow, only available via hotkey
    /* @__PURE__ */ React__default.createElement("section", {
      ref,
      "aria-label": `${containerAriaLabel} ${hotkeyLabel}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false",
      suppressHydrationWarning: true
    }, possiblePositions.map((position2, index2) => {
      var _heights_;
      const [y2, x] = position2.split("-");
      if (!filteredToasts.length) return null;
      return /* @__PURE__ */ React__default.createElement("ol", {
        key: position2,
        dir: dir === "auto" ? getDocumentDirection() : dir,
        tabIndex: -1,
        ref: listRef,
        className,
        "data-sonner-toaster": true,
        "data-sonner-theme": actualTheme,
        "data-y-position": y2,
        "data-x-position": x,
        style: {
          "--front-toast-height": `${((_heights_ = heights[0]) == null ? void 0 : _heights_.height) || 0}px`,
          "--width": `${TOAST_WIDTH}px`,
          "--gap": `${gap}px`,
          ...style,
          ...assignOffset(offset4, mobileOffset)
        },
        onBlur: (event) => {
          if (isFocusWithinRef.current && !event.currentTarget.contains(event.relatedTarget)) {
            isFocusWithinRef.current = false;
            if (lastFocusedElementRef.current) {
              lastFocusedElementRef.current.focus({
                preventScroll: true
              });
              lastFocusedElementRef.current = null;
            }
          }
        },
        onFocus: (event) => {
          const isNotDismissible = event.target instanceof HTMLElement && event.target.dataset.dismissible === "false";
          if (isNotDismissible) return;
          if (!isFocusWithinRef.current) {
            isFocusWithinRef.current = true;
            lastFocusedElementRef.current = event.relatedTarget;
          }
        },
        onMouseEnter: () => setExpanded(true),
        onMouseMove: () => setExpanded(true),
        onMouseLeave: () => {
          if (!interacting) {
            setExpanded(false);
          }
        },
        onDragEnd: () => setExpanded(false),
        onPointerDown: (event) => {
          const isNotDismissible = event.target instanceof HTMLElement && event.target.dataset.dismissible === "false";
          if (isNotDismissible) return;
          setInteracting(true);
        },
        onPointerUp: () => setInteracting(false)
      }, filteredToasts.filter((toast2) => !toast2.position && index2 === 0 || toast2.position === position2).map((toast2, index3) => {
        var _toastOptions_duration, _toastOptions_closeButton;
        return /* @__PURE__ */ React__default.createElement(Toast, {
          key: toast2.id,
          icons,
          index: index3,
          toast: toast2,
          defaultRichColors: richColors,
          duration: (_toastOptions_duration = toastOptions == null ? void 0 : toastOptions.duration) != null ? _toastOptions_duration : duration,
          className: toastOptions == null ? void 0 : toastOptions.className,
          descriptionClassName: toastOptions == null ? void 0 : toastOptions.descriptionClassName,
          invert,
          visibleToasts,
          closeButton: (_toastOptions_closeButton = toastOptions == null ? void 0 : toastOptions.closeButton) != null ? _toastOptions_closeButton : closeButton,
          interacting,
          position: position2,
          style: toastOptions == null ? void 0 : toastOptions.style,
          unstyled: toastOptions == null ? void 0 : toastOptions.unstyled,
          classNames: toastOptions == null ? void 0 : toastOptions.classNames,
          cancelButtonStyle: toastOptions == null ? void 0 : toastOptions.cancelButtonStyle,
          actionButtonStyle: toastOptions == null ? void 0 : toastOptions.actionButtonStyle,
          closeButtonAriaLabel: toastOptions == null ? void 0 : toastOptions.closeButtonAriaLabel,
          removeToast,
          toasts: filteredToasts.filter((t3) => t3.position == toast2.position),
          heights: heights.filter((h2) => h2.position == toast2.position),
          setHeights,
          expandByDefault: expand,
          gap,
          expanded,
          swipeDirections: props.swipeDirections
        });
      }));
    }))
  );
});

// ../core/dist/index.mjs
init_chunk_Z45QNK2S();

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/Supplier.mjs
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Supplier = {
  get: (supplier) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof supplier === "function") {
      return supplier();
    } else {
      return supplier;
    }
  })
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/EndpointSupplier.mjs
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var EndpointSupplier = {
  get: (supplier, arg) => __awaiter2(void 0, void 0, void 0, function* () {
    if (typeof supplier === "function") {
      return supplier(arg);
    } else {
      return supplier;
    }
  })
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/json.mjs
var toJson = (value, replacer, space) => {
  return JSON.stringify(value, replacer, space);
};
function fromJson(text2, reviver) {
  return JSON.parse(text2, reviver);
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/url/qs.mjs
var defaultQsOptions = {
  arrayFormat: "indices",
  encode: true
};
function encodeValue(value, shouldEncode) {
  if (value === void 0) {
    return "";
  }
  if (value === null) {
    return "";
  }
  const stringValue = String(value);
  return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
}
function stringifyObject(obj, prefix = "", options) {
  const parts = [];
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}[${key}]` : key;
    if (value === void 0) {
      continue;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        continue;
      }
      for (let i5 = 0; i5 < value.length; i5++) {
        const item = value[i5];
        if (item === void 0) {
          continue;
        }
        if (typeof item === "object" && !Array.isArray(item) && item !== null) {
          const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i5}]` : fullKey;
          parts.push(...stringifyObject(item, arrayKey, options));
        } else {
          const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i5}]` : fullKey;
          const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
          parts.push(`${encodedKey}=${encodeValue(item, options.encode)}`);
        }
      }
    } else if (typeof value === "object" && value !== null) {
      if (Object.keys(value).length === 0) {
        continue;
      }
      parts.push(...stringifyObject(value, fullKey, options));
    } else {
      const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
      parts.push(`${encodedKey}=${encodeValue(value, options.encode)}`);
    }
  }
  return parts;
}
function toQueryString(obj, options) {
  if (obj == null || typeof obj !== "object") {
    return "";
  }
  const parts = stringifyObject(obj, "", Object.assign(Object.assign({}, defaultQsOptions), options));
  return parts.join("&");
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/createRequestUrl.mjs
function createRequestUrl(baseUrl, queryParameters) {
  const queryString = toQueryString(queryParameters, { arrayFormat: "repeat" });
  return queryString ? `${baseUrl}?${queryString}` : baseUrl;
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/BinaryResponse.mjs
function getBinaryResponse(response) {
  const binaryResponse = {
    get bodyUsed() {
      return response.bodyUsed;
    },
    stream: () => response.body,
    arrayBuffer: response.arrayBuffer.bind(response),
    blob: response.blob.bind(response)
  };
  if ("bytes" in response && typeof response.bytes === "function") {
    binaryResponse.bytes = response.bytes.bind(response);
  }
  return binaryResponse;
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/ResponseWithBody.mjs
function isResponseWithBody(response) {
  return response.body != null;
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/getResponseBody.mjs
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getResponseBody(response, responseType) {
  return __awaiter3(this, void 0, void 0, function* () {
    if (!isResponseWithBody(response)) {
      return void 0;
    }
    switch (responseType) {
      case "binary-response":
        return getBinaryResponse(response);
      case "blob":
        return yield response.blob();
      case "arrayBuffer":
        return yield response.arrayBuffer();
      case "sse":
        return response.body;
      case "streaming":
        return response.body;
      case "text":
        return yield response.text();
    }
    const text2 = yield response.text();
    if (text2.length > 0) {
      try {
        let responseBody = fromJson(text2);
        return responseBody;
      } catch (err) {
        return {
          ok: false,
          error: {
            reason: "non-json",
            statusCode: response.status,
            rawBody: text2
          }
        };
      }
    }
    return void 0;
  });
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/getErrorResponseBody.mjs
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getErrorResponseBody(response) {
  return __awaiter4(this, void 0, void 0, function* () {
    var _a, _b, _c;
    let contentType = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (contentType == null || contentType.length === 0) {
      return getResponseBody(response);
    }
    if (contentType.indexOf(";") !== -1) {
      contentType = (_c = (_b = contentType.split(";")[0]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
    }
    switch (contentType) {
      case "application/hal+json":
      case "application/json":
      case "application/ld+json":
      case "application/problem+json":
      case "application/vnd.api+json":
      case "text/json":
        const text2 = yield response.text();
        return text2.length > 0 ? fromJson(text2) : void 0;
      default:
        if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
          const text3 = yield response.text();
          return text3.length > 0 ? fromJson(text3) : void 0;
        }
        return yield response.text();
    }
  });
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/getFetchFn.mjs
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getFetchFn() {
  return __awaiter5(this, void 0, void 0, function* () {
    return fetch;
  });
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/getRequestBody.mjs
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getRequestBody(_a) {
  return __awaiter6(this, arguments, void 0, function* ({ body, type }) {
    if (type === "form") {
      return toQueryString(body, { arrayFormat: "repeat", encode: true });
    }
    if (type.includes("json")) {
      return toJson(body);
    } else {
      return body;
    }
  });
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/signals.mjs
var TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
  const controller = new AbortController();
  const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
  return { signal: controller.signal, abortId };
}
function anySignal(...args) {
  const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  const controller = new AbortController();
  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
      break;
    }
    signal.addEventListener("abort", () => controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
      signal: controller.signal
    });
  }
  return controller.signal;
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/makeRequest.mjs
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var makeRequest = (fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex) => __awaiter7(void 0, void 0, void 0, function* () {
  const signals = [];
  let timeoutAbortId = void 0;
  if (timeoutMs != null) {
    const { signal, abortId } = getTimeoutSignal(timeoutMs);
    timeoutAbortId = abortId;
    signals.push(signal);
  }
  if (abortSignal != null) {
    signals.push(abortSignal);
  }
  let newSignals = anySignal(signals);
  const response = yield fetchFn(url, {
    method,
    headers,
    body: requestBody,
    signal: newSignals,
    credentials: withCredentials ? "include" : void 0,
    // @ts-ignore
    duplex
  });
  if (timeoutAbortId != null) {
    clearTimeout(timeoutAbortId);
  }
  return response;
});

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/Headers.mjs
var Headers2;
if (typeof globalThis.Headers !== "undefined") {
  Headers2 = globalThis.Headers;
} else {
  Headers2 = class Headers5 {
    constructor(init) {
      this.headers = /* @__PURE__ */ new Map();
      if (init) {
        if (init instanceof Headers5) {
          init.forEach((value, key) => this.append(key, value));
        } else if (Array.isArray(init)) {
          for (const [key, value] of init) {
            if (typeof key === "string" && typeof value === "string") {
              this.append(key, value);
            } else {
              throw new TypeError("Each header entry must be a [string, string] tuple");
            }
          }
        } else {
          for (const [key, value] of Object.entries(init)) {
            if (typeof value === "string") {
              this.append(key, value);
            } else {
              throw new TypeError("Header values must be strings");
            }
          }
        }
      }
    }
    append(name, value) {
      const key = name.toLowerCase();
      const existing = this.headers.get(key) || [];
      this.headers.set(key, [...existing, value]);
    }
    delete(name) {
      const key = name.toLowerCase();
      this.headers.delete(key);
    }
    get(name) {
      const key = name.toLowerCase();
      const values = this.headers.get(key);
      return values ? values.join(", ") : null;
    }
    has(name) {
      const key = name.toLowerCase();
      return this.headers.has(key);
    }
    set(name, value) {
      const key = name.toLowerCase();
      this.headers.set(key, [value]);
    }
    forEach(callbackfn, thisArg) {
      const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
      this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
    }
    getSetCookie() {
      return this.headers.get("set-cookie") || [];
    }
    *entries() {
      for (const [key, values] of this.headers.entries()) {
        yield [key, values.join(", ")];
      }
    }
    *keys() {
      yield* this.headers.keys();
    }
    *values() {
      for (const values of this.headers.values()) {
        yield values.join(", ");
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
  };
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/RawResponse.mjs
var abortRawResponse = {
  headers: new Headers2(),
  redirected: false,
  status: 499,
  statusText: "Client Closed Request",
  type: "error",
  url: ""
};
var unknownRawResponse = {
  headers: new Headers2(),
  redirected: false,
  status: 0,
  statusText: "Unknown Error",
  type: "error",
  url: ""
};
function toRawResponse(response) {
  return {
    headers: response.headers,
    redirected: response.redirected,
    status: response.status,
    statusText: response.statusText,
    type: response.type,
    url: response.url
  };
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/requestWithRetries.mjs
var __awaiter8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var INITIAL_RETRY_DELAY = 1e3;
var MAX_RETRY_DELAY = 6e4;
var DEFAULT_MAX_RETRIES = 2;
var JITTER_FACTOR = 0.2;
function addPositiveJitter(delay) {
  const jitterMultiplier = 1 + Math.random() * JITTER_FACTOR;
  return delay * jitterMultiplier;
}
function addSymmetricJitter(delay) {
  const jitterMultiplier = 1 + (Math.random() - 0.5) * JITTER_FACTOR;
  return delay * jitterMultiplier;
}
function getRetryDelayFromHeaders(response, retryAttempt) {
  const retryAfter = response.headers.get("Retry-After");
  if (retryAfter) {
    const retryAfterSeconds = parseInt(retryAfter, 10);
    if (!isNaN(retryAfterSeconds) && retryAfterSeconds > 0) {
      return Math.min(retryAfterSeconds * 1e3, MAX_RETRY_DELAY);
    }
    const retryAfterDate = new Date(retryAfter);
    if (!isNaN(retryAfterDate.getTime())) {
      const delay = retryAfterDate.getTime() - Date.now();
      if (delay > 0) {
        return Math.min(Math.max(delay, 0), MAX_RETRY_DELAY);
      }
    }
  }
  const rateLimitReset = response.headers.get("X-RateLimit-Reset");
  if (rateLimitReset) {
    const resetTime = parseInt(rateLimitReset, 10);
    if (!isNaN(resetTime)) {
      const delay = resetTime * 1e3 - Date.now();
      if (delay > 0) {
        return addPositiveJitter(Math.min(delay, MAX_RETRY_DELAY));
      }
    }
  }
  return addSymmetricJitter(Math.min(INITIAL_RETRY_DELAY * Math.pow(2, retryAttempt), MAX_RETRY_DELAY));
}
function requestWithRetries(requestFn_1) {
  return __awaiter8(this, arguments, void 0, function* (requestFn, maxRetries = DEFAULT_MAX_RETRIES) {
    let response = yield requestFn();
    for (let i5 = 0; i5 < maxRetries; ++i5) {
      if ([408, 429].includes(response.status) || response.status >= 500) {
        const delay = getRetryDelayFromHeaders(response, i5);
        yield new Promise((resolve) => setTimeout(resolve, delay));
        response = yield requestFn();
      } else {
        break;
      }
    }
    return response;
  });
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/Fetcher.mjs
var __awaiter9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getHeaders(args) {
  return __awaiter9(this, void 0, void 0, function* () {
    var _a;
    const newHeaders = {};
    if (args.body !== void 0 && args.contentType != null) {
      newHeaders["Content-Type"] = args.contentType;
    }
    if (args.headers == null) {
      return newHeaders;
    }
    for (const [key, value] of Object.entries(args.headers)) {
      const result = yield EndpointSupplier.get(value, { endpointMetadata: (_a = args.endpointMetadata) !== null && _a !== void 0 ? _a : {} });
      if (typeof result === "string") {
        newHeaders[key] = result;
        continue;
      }
      if (result == null) {
        continue;
      }
      newHeaders[key] = `${result}`;
    }
    return newHeaders;
  });
}
function fetcherImpl(args) {
  return __awaiter9(this, void 0, void 0, function* () {
    var _a, _b;
    const url = createRequestUrl(args.url, args.queryParameters);
    const requestBody = yield getRequestBody({
      body: args.body,
      type: (_a = args.requestType) !== null && _a !== void 0 ? _a : "other"
    });
    const fetchFn = (_b = args.fetchFn) !== null && _b !== void 0 ? _b : yield getFetchFn();
    try {
      const response = yield requestWithRetries(() => __awaiter9(this, void 0, void 0, function* () {
        return makeRequest(fetchFn, url, args.method, yield getHeaders(args), requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
      }), args.maxRetries);
      if (response.status >= 200 && response.status < 400) {
        return {
          ok: true,
          body: yield getResponseBody(response, args.responseType),
          headers: response.headers,
          rawResponse: toRawResponse(response)
        };
      } else {
        return {
          ok: false,
          error: {
            reason: "status-code",
            statusCode: response.status,
            body: yield getErrorResponseBody(response)
          },
          rawResponse: toRawResponse(response)
        };
      }
    } catch (error) {
      if (args.abortSignal != null && args.abortSignal.aborted) {
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: "The user aborted a request"
          },
          rawResponse: abortRawResponse
        };
      } else if (error instanceof Error && error.name === "AbortError") {
        return {
          ok: false,
          error: {
            reason: "timeout"
          },
          rawResponse: abortRawResponse
        };
      } else if (error instanceof Error) {
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: error.message
          },
          rawResponse: unknownRawResponse
        };
      }
      return {
        ok: false,
        error: {
          reason: "unknown",
          errorMessage: toJson(error)
        },
        rawResponse: unknownRawResponse
      };
    }
  });
}
var fetcher = fetcherImpl;

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/fetcher/HttpResponsePromise.mjs
var __awaiter10 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var HttpResponsePromise = class _HttpResponsePromise extends Promise {
  constructor(promise) {
    super((resolve) => {
      resolve(void 0);
    });
    this.innerPromise = promise;
  }
  /**
   * Creates an `HttpResponsePromise` from a function that returns a promise.
   *
   * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
   * @param args - Arguments to pass to the function.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromFunction(fn, ...args) {
    return new _HttpResponsePromise(fn(...args));
  }
  /**
   * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
   *
   * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
   * @returns A function that returns an `HttpResponsePromise` instance.
   */
  static interceptFunction(fn) {
    return (...args) => {
      return _HttpResponsePromise.fromPromise(fn(...args));
    };
  }
  /**
   * Creates an `HttpResponsePromise` from an existing promise.
   *
   * @param promise - A promise resolving to a `WithRawResponse` object.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromPromise(promise) {
    return new _HttpResponsePromise(promise);
  }
  /**
   * Creates an `HttpResponsePromise` from an executor function.
   *
   * @param executor - A function that takes resolve and reject callbacks to create a promise.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromExecutor(executor) {
    const promise = new Promise(executor);
    return new _HttpResponsePromise(promise);
  }
  /**
   * Creates an `HttpResponsePromise` from a resolved result.
   *
   * @param result - A `WithRawResponse` object to resolve immediately.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromResult(result) {
    const promise = Promise.resolve(result);
    return new _HttpResponsePromise(promise);
  }
  unwrap() {
    if (!this.unwrappedPromise) {
      this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
    }
    return this.unwrappedPromise;
  }
  /** @inheritdoc */
  then(onfulfilled, onrejected) {
    return this.unwrap().then(onfulfilled, onrejected);
  }
  /** @inheritdoc */
  catch(onrejected) {
    return this.unwrap().catch(onrejected);
  }
  /** @inheritdoc */
  finally(onfinally) {
    return this.unwrap().finally(onfinally);
  }
  /**
   * Retrieves the data and raw response.
   *
   * @returns A promise resolving to a `WithRawResponse` object.
   */
  withRawResponse() {
    return __awaiter10(this, void 0, void 0, function* () {
      return yield this.innerPromise;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/runtime/runtime.mjs
var RUNTIME = evaluateRuntime();
function evaluateRuntime() {
  var _a, _b, _c, _d, _e;
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  if (isBrowser) {
    return {
      type: "browser",
      version: window.navigator.userAgent
    };
  }
  const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
  if (isCloudflare) {
    return {
      type: "workerd"
    };
  }
  const isEdgeRuntime = typeof EdgeRuntime === "string";
  if (isEdgeRuntime) {
    return {
      type: "edge-runtime"
    };
  }
  const isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" || ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
  if (isWebWorker) {
    return {
      type: "web-worker"
    };
  }
  const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  if (isDeno) {
    return {
      type: "deno",
      version: Deno.version.deno
    };
  }
  const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  if (isBun) {
    return {
      type: "bun",
      version: Bun.version
    };
  }
  const isNode2 = typeof process !== "undefined" && "version" in process && !!process.version && "versions" in process && !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
  if (isNode2) {
    return {
      type: "node",
      version: process.versions.node,
      parsedVersion: Number(process.versions.node.split(".")[0])
    };
  }
  const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  if (isReactNative) {
    return {
      type: "react-native"
    };
  }
  return {
    type: "unknown"
  };
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/url/index.mjs
var url_exports = {};
__export(url_exports, {
  encodePathParam: () => encodePathParam,
  join: () => join,
  toQueryString: () => toQueryString
});

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/url/encodePathParam.mjs
function encodePathParam(param) {
  if (param === null) {
    return "null";
  }
  const typeofParam = typeof param;
  switch (typeofParam) {
    case "undefined":
      return "undefined";
    case "string":
    case "number":
    case "boolean":
      break;
    default:
      param = String(param);
      break;
  }
  return encodeURIComponent(param);
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/url/join.mjs
function join(base, ...segments) {
  if (!base) {
    return "";
  }
  if (segments.length === 0) {
    return base;
  }
  if (base.includes("://")) {
    let url;
    try {
      url = new URL(base);
    } catch (_a) {
      return joinPath(base, ...segments);
    }
    const lastSegment = segments[segments.length - 1];
    const shouldPreserveTrailingSlash = lastSegment && lastSegment.endsWith("/");
    for (const segment of segments) {
      const cleanSegment = trimSlashes(segment);
      if (cleanSegment) {
        url.pathname = joinPathSegments(url.pathname, cleanSegment);
      }
    }
    if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
      url.pathname += "/";
    }
    return url.toString();
  }
  return joinPath(base, ...segments);
}
function joinPath(base, ...segments) {
  if (segments.length === 0) {
    return base;
  }
  let result = base;
  const lastSegment = segments[segments.length - 1];
  const shouldPreserveTrailingSlash = lastSegment && lastSegment.endsWith("/");
  for (const segment of segments) {
    const cleanSegment = trimSlashes(segment);
    if (cleanSegment) {
      result = joinPathSegments(result, cleanSegment);
    }
  }
  if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
    result += "/";
  }
  return result;
}
function joinPathSegments(left, right) {
  if (left.endsWith("/")) {
    return left + right;
  }
  return left + "/" + right;
}
function trimSlashes(str) {
  if (!str)
    return str;
  let start = 0;
  let end = str.length;
  if (str.startsWith("/"))
    start = 1;
  if (str.endsWith("/"))
    end = str.length - 1;
  return start === 0 && end === str.length ? str : str.slice(start, end);
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/base64.mjs
function bytesToBase64(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}
function base64Encode(input) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "utf8").toString("base64");
  }
  const bytes = new TextEncoder().encode(input);
  return bytesToBase64(bytes);
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/utils/setObjectProperty.mjs
function setObjectProperty(object, path, value) {
  if (object == null) {
    return object;
  }
  const keys = path.split(".");
  if (keys.length === 0) {
    return object;
  }
  let current = object;
  for (let i5 = 0; i5 < keys.length - 1; i5++) {
    const key = keys[i5];
    if (key == null) {
      continue;
    }
    if (!current[key] || typeof current[key] !== "object") {
      current[key] = {};
    }
    current = current[key];
  }
  const lastKey = keys[keys.length - 1];
  if (lastKey == null) {
    return object;
  }
  current[lastKey] = value;
  return object;
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/pagination/Page.mjs
var __awaiter11 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i5, q = [];
  return i5 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i5[Symbol.asyncIterator] = function() {
    return this;
  }, i5;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n4, f) {
    if (g2[n4]) {
      i5[n4] = function(v) {
        return new Promise(function(a4, b2) {
          q.push([n4, v, a4, b2]) > 1 || resume(n4, v);
        });
      };
      if (f) i5[n4] = f(i5[n4]);
    }
  }
  function resume(n4, v) {
    try {
      step(g2[n4](v));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r5) {
    r5.value instanceof __await ? Promise.resolve(r5.value.v).then(fulfill, reject) : settle(q[0][2], r5);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var __asyncValues = function(o5) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o5[Symbol.asyncIterator], i5;
  return m2 ? m2.call(o5) : (o5 = typeof __values === "function" ? __values(o5) : o5[Symbol.iterator](), i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
    return this;
  }, i5);
  function verb(n4) {
    i5[n4] = o5[n4] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o5[n4](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
};
var Page = class {
  constructor({ response, rawResponse, hasNextPage, getItems, loadPage }) {
    this.response = response;
    this.rawResponse = rawResponse;
    this.data = getItems(response);
    this._hasNextPage = hasNextPage;
    this.getItems = getItems;
    this.loadNextPage = loadPage;
  }
  /**
   * Retrieves the next page
   * @returns this
   */
  getNextPage() {
    return __awaiter11(this, void 0, void 0, function* () {
      const { data, rawResponse } = yield this.loadNextPage(this.response).withRawResponse();
      this.response = data;
      this.rawResponse = rawResponse;
      this.data = this.getItems(this.response);
      return this;
    });
  }
  /**
   * @returns whether there is a next page to load
   */
  hasNextPage() {
    return this._hasNextPage(this.response);
  }
  iterMessages() {
    return __asyncGenerator(this, arguments, function* iterMessages_1() {
      for (const item of this.data) {
        yield yield __await(item);
      }
      while (this.hasNextPage()) {
        yield __await(this.getNextPage());
        for (const item of this.data) {
          yield yield __await(item);
        }
      }
    });
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a() {
      var _b, e_1, _c, _d;
      try {
        for (var _e = true, _f = __asyncValues(this.iterMessages()), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true) {
          _d = _g.value;
          _e = false;
          const message = _d;
          yield yield __await(message);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/errors/MyAccountError.mjs
var MyAccountError = class _MyAccountError extends Error {
  constructor({ message, statusCode, body, rawResponse }) {
    super(buildMessage({ message, statusCode, body }));
    Object.setPrototypeOf(this, _MyAccountError.prototype);
    this.statusCode = statusCode;
    this.body = body;
    this.rawResponse = rawResponse;
  }
};
function buildMessage({ message, statusCode, body }) {
  let lines = [];
  if (message != null) {
    lines.push(message);
  }
  if (statusCode != null) {
    lines.push(`Status code: ${statusCode.toString()}`);
  }
  if (body != null) {
    lines.push(`Body: ${toJson(body, void 0, 2)}`);
  }
  return lines.join("\n");
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/errors/MyAccountTimeoutError.mjs
var MyAccountTimeoutError = class _MyAccountTimeoutError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _MyAccountTimeoutError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/errors/BadRequestError.mjs
var BadRequestError = class _BadRequestError extends MyAccountError {
  constructor(body, rawResponse) {
    super({
      message: "BadRequestError",
      statusCode: 400,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _BadRequestError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/errors/UnauthorizedError.mjs
var UnauthorizedError = class _UnauthorizedError extends MyAccountError {
  constructor(body, rawResponse) {
    super({
      message: "UnauthorizedError",
      statusCode: 401,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/errors/ForbiddenError.mjs
var ForbiddenError = class _ForbiddenError extends MyAccountError {
  constructor(body, rawResponse) {
    super({
      message: "ForbiddenError",
      statusCode: 403,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _ForbiddenError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/errors/TooManyRequestsError.mjs
var TooManyRequestsError = class _TooManyRequestsError extends MyAccountError {
  constructor(body, rawResponse) {
    super({
      message: "TooManyRequestsError",
      statusCode: 429,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _TooManyRequestsError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/errors/NotFoundError.mjs
var NotFoundError = class _NotFoundError extends MyAccountError {
  constructor(body, rawResponse) {
    super({
      message: "NotFoundError",
      statusCode: 404,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _NotFoundError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/environments.mjs
var MyAccountEnvironment = {
  Default: "https://auth0.auth0.com/me/v1"
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/core/headers.mjs
function mergeHeaders(...headersArray) {
  const result = {};
  for (const [key, value] of headersArray.filter((headers) => headers != null).flatMap((headers) => Object.entries(headers))) {
    const insensitiveKey = key.toLowerCase();
    if (value != null) {
      result[insensitiveKey] = value;
    } else if (insensitiveKey in result) {
      delete result[insensitiveKey];
    }
  }
  return result;
}
function mergeOnlyDefinedHeaders(...headersArray) {
  const result = {};
  for (const [key, value] of headersArray.filter((headers) => headers != null).flatMap((headers) => Object.entries(headers))) {
    const insensitiveKey = key.toLowerCase();
    if (value != null) {
      result[insensitiveKey] = value;
    }
  }
  return result;
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/resources/factors/client/Client.mjs
var __awaiter12 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Factors = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * List of factors enabled for the Auth0 tenant and available for enrollment by this user.
   *
   * @param {Factors.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.factors.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter12(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = { security: [{ "Bearer-DPoP": ["read:me:factors"] }] };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, "factors"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling GET /factors.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter12(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/resources/authenticationMethods/client/Client.mjs
var __awaiter13 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AuthenticationMethods = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Retrieve detailed list of authentication methods belonging to the authenticated user.
   *
   * @param {AuthenticationMethods.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.authenticationMethods.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter13(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = { security: [{ "Bearer-DPoP": ["read:me:authentication_methods"] }] };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, "authentication-methods"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling GET /authentication-methods.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Start the enrollment of a supported authentication method.
   *
   * @param {MyAccount.CreateAuthenticationMethodRequestContent} request
   * @param {AuthenticationMethods.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.authenticationMethods.create({
   *         type: "passkey"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter13(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [{ "Bearer-DPoP": ["create:me:authentication_methods"] }]
      };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, "authentication-methods"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling POST /authentication-methods.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Retrieves a single authentication method belonging to the authenticated user.
   *
   * @param {MyAccount.PathAuthenticationMethodId} authenticationMethodId - Authentication Method ID. This value is part of the Location header returned when creating an authentication method. It should be used as it is, without any modifications.
   * @param {AuthenticationMethods.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.NotFoundError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.authenticationMethods.get("authentication_method_id")
   */
  get(authenticationMethodId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(authenticationMethodId, requestOptions));
  }
  __get(authenticationMethodId, requestOptions) {
    return __awaiter13(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = { security: [{ "Bearer-DPoP": ["read:me:authentication_methods"] }] };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, `authentication-methods/${url_exports.encodePathParam(authenticationMethodId)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling GET /authentication-methods/{authentication_method_id}.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Deletes a single authentication method belonging to the authenticated user.
   *
   * @param {MyAccount.PathAuthenticationMethodId} authenticationMethodId - Authentication Method ID. This value is part of the Location header returned when creating an authentication method. It should be used as it is, without any modifications.
   * @param {AuthenticationMethods.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.authenticationMethods.delete("authentication_method_id")
   */
  delete(authenticationMethodId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(authenticationMethodId, requestOptions));
  }
  __delete(authenticationMethodId, requestOptions) {
    return __awaiter13(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [{ "Bearer-DPoP": ["delete:me:authentication_methods"] }]
      };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, `authentication-methods/${url_exports.encodePathParam(authenticationMethodId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling DELETE /authentication-methods/{authentication_method_id}.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Updates a single authentication method
   *
   * @param {MyAccount.PathAuthenticationMethodId} authenticationMethodId - Authentication Method ID. This value is part of the Location header returned when creating an authentication method. It should be used as it is, without any modifications.
   * @param {MyAccount.UpdateAuthenticationMethodRequestContent} request
   * @param {AuthenticationMethods.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.authenticationMethods.update("authentication_method_id")
   */
  update(authenticationMethodId, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(authenticationMethodId, request, requestOptions));
  }
  __update(authenticationMethodId_1) {
    return __awaiter13(this, arguments, void 0, function* (authenticationMethodId, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [{ "Bearer-DPoP": ["update:me:authentication_methods"] }]
      };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, `authentication-methods/${url_exports.encodePathParam(authenticationMethodId)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling PATCH /authentication-methods/{authentication_method_id}.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Confirm the enrollment of a supported authentication method.
   *
   * @param {MyAccount.PathAuthenticationMethodId} authenticationMethodId - Authentication Method ID. This value is part of the Location header returned when creating an authentication method. It should be used as it is, without any modifications.
   * @param {MyAccount.VerifyAuthenticationMethodRequestContent} request
   * @param {AuthenticationMethods.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.authenticationMethods.verify("authentication_method_id", {
   *         auth_session: "auth_session",
   *         authn_response: {
   *             id: "id",
   *             rawId: "rawId",
   *             response: {
   *                 attestationObject: "attestationObject",
   *                 clientDataJSON: "clientDataJSON"
   *             },
   *             type: "public-key"
   *         }
   *     })
   */
  verify(authenticationMethodId, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__verify(authenticationMethodId, request, requestOptions));
  }
  __verify(authenticationMethodId, request, requestOptions) {
    return __awaiter13(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [{ "Bearer-DPoP": ["create:me:authentication_methods"] }]
      };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, `authentication-methods/${url_exports.encodePathParam(authenticationMethodId)}/verify`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling POST /authentication-methods/{authentication_method_id}/verify.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter13(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/resources/connectedAccounts/resources/connections/client/Client.mjs
var __awaiter14 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Connections = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Retrieve available connections that can be used for account linking by the authenticated user.
   *
   * @param {MyAccount.ListConnectedAccountsConnectionsRequestParameters} request
   * @param {Connections.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.connectedAccounts.connections.list({
   *         from: "from",
   *         take: 1
   *     })
   */
  list() {
    return __awaiter14(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter14(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const _metadata = {
          security: [{ "Bearer-DPoP": ["read:me:connected_accounts"] }]
        };
        const { from: from_, take = 10 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        let _headers = mergeHeaders((_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : MyAccountEnvironment.Default, "connected-accounts/connections"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          endpointMetadata: _metadata,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new MyAccountError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        switch (_response.error.reason) {
          case "non-json":
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.rawBody,
              rawResponse: _response.rawResponse
            });
          case "timeout":
            throw new MyAccountTimeoutError("Timeout exceeded when calling GET /connected-accounts/connections.");
          case "unknown":
            throw new MyAccountError({
              message: _response.error.errorMessage,
              rawResponse: _response.rawResponse
            });
        }
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.connections) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter14(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/api/resources/connectedAccounts/client/Client.mjs
var __awaiter15 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ConnectedAccounts = class {
  constructor(_options) {
    this._options = _options;
  }
  get connections() {
    var _a;
    return (_a = this._connections) !== null && _a !== void 0 ? _a : this._connections = new Connections(this._options);
  }
  /**
   * Start an authorization flow to link the authenticated user's account with an external identity provider.
   *
   * @param {MyAccount.CreateConnectedAccountsRequestContent} request
   * @param {ConnectedAccounts.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.connectedAccounts.create({
   *         connection: "connection",
   *         redirect_uri: "redirect_uri"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter15(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = { security: [{ "Bearer-DPoP": ["create:me:connected_accounts"] }] };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, "connected-accounts/connect"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling POST /connected-accounts/connect.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Complete a previously started authorization flow to link the authenticated user's account with an external identity provider.
   *
   * @param {MyAccount.CompleteConnectedAccountsRequestContent} request
   * @param {ConnectedAccounts.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.connectedAccounts.complete({
   *         auth_session: "auth_session",
   *         connect_code: "connect_code",
   *         redirect_uri: "redirect_uri"
   *     })
   */
  complete(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__complete(request, requestOptions));
  }
  __complete(request, requestOptions) {
    return __awaiter15(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = { security: [{ "Bearer-DPoP": ["create:me:connected_accounts"] }] };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, "connected-accounts/complete"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling POST /connected-accounts/complete.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Retrieve connected accounts belonging to the authenticated user.
   *
   * @param {MyAccount.ListConnectedAccountsRequestParameters} request
   * @param {ConnectedAccounts.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.connectedAccounts.list({
   *         connection: "connection",
   *         from: "from",
   *         take: 1
   *     })
   */
  list() {
    return __awaiter15(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter15(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const _metadata = {
          security: [{ "Bearer-DPoP": ["read:me:connected_accounts"] }]
        };
        const { connection, from: from_, take = 10 } = request2;
        const _queryParams = {};
        if (connection !== void 0) {
          _queryParams["connection"] = typeof connection === "string" ? connection : toJson(connection);
        }
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        let _headers = mergeHeaders((_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : MyAccountEnvironment.Default, "connected-accounts/accounts"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          endpointMetadata: _metadata,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new MyAccountError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        switch (_response.error.reason) {
          case "non-json":
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.rawBody,
              rawResponse: _response.rawResponse
            });
          case "timeout":
            throw new MyAccountTimeoutError("Timeout exceeded when calling GET /connected-accounts/accounts.");
          case "unknown":
            throw new MyAccountError({
              message: _response.error.errorMessage,
              rawResponse: _response.rawResponse
            });
        }
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.accounts) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Delete a connected account belonging to the authenticated user.
   *
   * @param {MyAccount.ConnectedAccountId} id - The unique identifier of the connected account
   * @param {ConnectedAccounts.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyAccount.BadRequestError}
   * @throws {@link MyAccount.UnauthorizedError}
   * @throws {@link MyAccount.ForbiddenError}
   * @throws {@link MyAccount.TooManyRequestsError}
   *
   * @example
   *     await client.connectedAccounts.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter15(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = { security: [{ "Bearer-DPoP": ["delete:me:connected_accounts"] }] };
      let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyAccountEnvironment.Default, `connected-accounts/accounts/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new MyAccountError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyAccountError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyAccountTimeoutError("Timeout exceeded when calling DELETE /connected-accounts/accounts/{id}.");
        case "unknown":
          throw new MyAccountError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter15(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/Client.mjs
var MyAccountClient = class {
  constructor(_options) {
    this._options = _options;
  }
  get factors() {
    var _a;
    return (_a = this._factors) !== null && _a !== void 0 ? _a : this._factors = new Factors(this._options);
  }
  get authenticationMethods() {
    var _a;
    return (_a = this._authenticationMethods) !== null && _a !== void 0 ? _a : this._authenticationMethods = new AuthenticationMethods(this._options);
  }
  get connectedAccounts() {
    var _a;
    return (_a = this._connectedAccounts) !== null && _a !== void 0 ? _a : this._connectedAccounts = new ConnectedAccounts(this._options);
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/utils/base64url.mjs
function base64urlEncode(str) {
  const base64 = base64Encode(str);
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function base64urlEncodeJson(obj) {
  const jsonString = JSON.stringify(obj);
  return base64urlEncode(jsonString);
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/version.mjs
var SDK_VERSION = "1.0.0-beta.0";

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/utils/clientInfo.mjs
function generateClientInfo() {
  var _a, _b;
  const runtimeType = (_a = RUNTIME === null || RUNTIME === void 0 ? void 0 : RUNTIME.type) !== null && _a !== void 0 ? _a : "unknown";
  const runtimeKey = runtimeType === "workerd" ? "cloudflare-workers" : runtimeType;
  const runtimeVersion = (_b = RUNTIME === null || RUNTIME === void 0 ? void 0 : RUNTIME.version) !== null && _b !== void 0 ? _b : "unknown";
  return {
    name: "myaccount-js",
    version: SDK_VERSION,
    env: {
      [runtimeKey]: runtimeVersion
    }
  };
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/utils/auth0ClientTelemetry.mjs
var Auth0ClientTelemetry = class {
  constructor(options = {}) {
    this.clientInfo = options.clientInfo || generateClientInfo();
  }
  /**
   * Get the Auth0-Client header value for telemetry.
   * This method generates the telemetry header that should be included in API requests.
   * @returns The Auth0-Client header value or undefined if client name is invalid
   */
  getAuth0ClientHeader() {
    if (typeof this.clientInfo.name === "string" && this.clientInfo.name.length > 0) {
      return base64urlEncodeJson(this.clientInfo);
    }
    return void 0;
  }
  /**
   * Get headers object with Auth0-Client header included
   * @param existingHeaders - Existing headers to merge with
   * @returns Headers object with Auth0-Client header
   */
  getHeaders(existingHeaders = {}) {
    const auth0ClientHeader = this.getAuth0ClientHeader();
    if (auth0ClientHeader) {
      return Object.assign(Object.assign({}, existingHeaders), { "Auth0-Client": auth0ClientHeader });
    }
    return existingHeaders;
  }
};

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/wrappers/auth/Token.mjs
var __awaiter16 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createCoreTokenSupplier(tokenSupplier) {
  if (typeof tokenSupplier === "string") {
    return tokenSupplier;
  }
  if (typeof tokenSupplier === "function") {
    return (_a) => __awaiter16(this, [_a], void 0, function* ({ endpointMetadata }) {
      const scopes = extractScopesFromMetadata(endpointMetadata);
      const scope = scopes.join(" ");
      return yield tokenSupplier({ scope });
    });
  }
  throw new Error("Invalid token supplier provided");
}
function extractScopesFromMetadata(endpointMetadata) {
  if (!endpointMetadata.security)
    return [];
  const scopes = /* @__PURE__ */ new Set();
  for (const securityCollection of endpointMetadata.security) {
    for (const schemeScopes of Object.values(securityCollection)) {
      for (const scope of schemeScopes) {
        scopes.add(scope);
      }
    }
  }
  return [...scopes];
}

// ../../node_modules/.pnpm/@auth0+myaccount-js@1.0.0-beta.0/node_modules/@auth0/myaccount-js/dist/esm/wrappers/MyAccountClient.mjs
var __awaiter17 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var MyAccountClient2 = class extends MyAccountClient {
  /**
   * Creates a new MyAccount API client instance.
   *
   * @param _options - Configuration options for the MyAccount Client
   * @group MyAccount API
   */
  constructor(_options) {
    var _a;
    const sanitizedDomain = _options.domain.replace(/^https?:\/\//, "").replace(/\/$/, "");
    const baseUrl = `https://${sanitizedDomain}/me/v1`;
    const audience = `https://${sanitizedDomain}/me/`;
    const headers = createTelemetryHeaders(_options);
    const token = createTokenSupplier(_options);
    const fetcher3 = "fetcher" in _options && _options.fetcher ? createCoreFetcherSupplier(_options.fetcher, audience) : void 0;
    const clientOptions = Object.assign(Object.assign({ baseUrl: (_a = _options.baseUrl) !== null && _a !== void 0 ? _a : baseUrl, headers }, fetcher3 && { fetcher: fetcher3 }), token !== void 0 && { token });
    super(clientOptions);
  }
};
function isClientOptionsWithToken(_options) {
  return "token" in _options;
}
function isClientOptionsWithFetcher(_options) {
  return "fetcher" in _options;
}
function createTelemetryHeaders(_options) {
  var _a;
  const headers = Object.assign({}, (_a = _options.headers) !== null && _a !== void 0 ? _a : {});
  if (_options.telemetry !== false) {
    const telemetry = new Auth0ClientTelemetry({
      clientInfo: _options.clientInfo
    });
    const auth0ClientHeader = telemetry.getAuth0ClientHeader();
    if (auth0ClientHeader) {
      headers["Auth0-Client"] = auth0ClientHeader;
    }
  }
  return headers;
}
function createTokenSupplier(_options) {
  if (isClientOptionsWithToken(_options)) {
    return createCoreTokenSupplier(_options.token);
  }
  if (isClientOptionsWithFetcher(_options)) {
    return "";
  }
  throw new Error("MyAccountClient must be configured with either 'token' or 'fetcher' (that handles authorization headers)");
}
function createCoreFetcherSupplier(fetcherSupplier, audience) {
  return (args) => __awaiter17(this, void 0, void 0, function* () {
    const scopes = args.endpointMetadata ? extractScopesFromMetadata(args.endpointMetadata) : [];
    const authParams = scopes.length > 0 ? { scope: scopes, audience } : void 0;
    const init = {
      method: args.method,
      headers: args.headers,
      body: args.body ? JSON.stringify(args.body) : void 0,
      signal: args.abortSignal,
      credentials: args.withCredentials ? "include" : void 0
    };
    const response = yield fetcherSupplier(args.url, init, authParams);
    const responseBody = yield response.text();
    const rawResponse = {
      headers: response.headers,
      redirected: response.redirected,
      status: response.status,
      statusText: response.statusText,
      type: response.type,
      url: response.url
    };
    if (response.ok) {
      return {
        ok: true,
        body: responseBody ? JSON.parse(responseBody) : void 0,
        rawResponse
      };
    } else {
      return {
        ok: false,
        error: {
          reason: "status-code",
          statusCode: response.status,
          body: responseBody ? JSON.parse(responseBody) : void 0
        },
        rawResponse
      };
    }
  });
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/Supplier.mjs
var __awaiter18 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Supplier2 = {
  get: (supplier) => __awaiter18(void 0, void 0, void 0, function* () {
    if (typeof supplier === "function") {
      return supplier();
    } else {
      return supplier;
    }
  })
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/EndpointSupplier.mjs
var __awaiter19 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var EndpointSupplier2 = {
  get: (supplier, arg) => __awaiter19(void 0, void 0, void 0, function* () {
    if (typeof supplier === "function") {
      return supplier(arg);
    } else {
      return supplier;
    }
  })
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/json.mjs
var toJson2 = (value, replacer, space) => {
  return JSON.stringify(value, replacer, space);
};
function fromJson2(text2, reviver) {
  return JSON.parse(text2, reviver);
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/url/qs.mjs
var defaultQsOptions2 = {
  arrayFormat: "indices",
  encode: true
};
function encodeValue2(value, shouldEncode) {
  if (value === void 0) {
    return "";
  }
  if (value === null) {
    return "";
  }
  const stringValue = String(value);
  return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
}
function stringifyObject2(obj, prefix = "", options) {
  const parts = [];
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}[${key}]` : key;
    if (value === void 0) {
      continue;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        continue;
      }
      for (let i5 = 0; i5 < value.length; i5++) {
        const item = value[i5];
        if (item === void 0) {
          continue;
        }
        if (typeof item === "object" && !Array.isArray(item) && item !== null) {
          const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i5}]` : fullKey;
          parts.push(...stringifyObject2(item, arrayKey, options));
        } else {
          const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i5}]` : fullKey;
          const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
          parts.push(`${encodedKey}=${encodeValue2(item, options.encode)}`);
        }
      }
    } else if (typeof value === "object" && value !== null) {
      if (Object.keys(value).length === 0) {
        continue;
      }
      parts.push(...stringifyObject2(value, fullKey, options));
    } else {
      const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
      parts.push(`${encodedKey}=${encodeValue2(value, options.encode)}`);
    }
  }
  return parts;
}
function toQueryString2(obj, options) {
  if (obj == null || typeof obj !== "object") {
    return "";
  }
  const parts = stringifyObject2(obj, "", Object.assign(Object.assign({}, defaultQsOptions2), options));
  return parts.join("&");
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/createRequestUrl.mjs
function createRequestUrl2(baseUrl, queryParameters) {
  const queryString = toQueryString2(queryParameters, { arrayFormat: "repeat" });
  return queryString ? `${baseUrl}?${queryString}` : baseUrl;
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/BinaryResponse.mjs
function getBinaryResponse2(response) {
  const binaryResponse = {
    get bodyUsed() {
      return response.bodyUsed;
    },
    stream: () => response.body,
    arrayBuffer: response.arrayBuffer.bind(response),
    blob: response.blob.bind(response)
  };
  if ("bytes" in response && typeof response.bytes === "function") {
    binaryResponse.bytes = response.bytes.bind(response);
  }
  return binaryResponse;
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/ResponseWithBody.mjs
function isResponseWithBody2(response) {
  return response.body != null;
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/getResponseBody.mjs
var __awaiter20 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getResponseBody2(response, responseType) {
  return __awaiter20(this, void 0, void 0, function* () {
    if (!isResponseWithBody2(response)) {
      return void 0;
    }
    switch (responseType) {
      case "binary-response":
        return getBinaryResponse2(response);
      case "blob":
        return yield response.blob();
      case "arrayBuffer":
        return yield response.arrayBuffer();
      case "sse":
        return response.body;
      case "streaming":
        return response.body;
      case "text":
        return yield response.text();
    }
    const text2 = yield response.text();
    if (text2.length > 0) {
      try {
        let responseBody = fromJson2(text2);
        return responseBody;
      } catch (err) {
        return {
          ok: false,
          error: {
            reason: "non-json",
            statusCode: response.status,
            rawBody: text2
          }
        };
      }
    }
    return void 0;
  });
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/getErrorResponseBody.mjs
var __awaiter21 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getErrorResponseBody2(response) {
  return __awaiter21(this, void 0, void 0, function* () {
    var _a, _b, _c;
    let contentType = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (contentType == null || contentType.length === 0) {
      return getResponseBody2(response);
    }
    if (contentType.indexOf(";") !== -1) {
      contentType = (_c = (_b = contentType.split(";")[0]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
    }
    switch (contentType) {
      case "application/hal+json":
      case "application/json":
      case "application/ld+json":
      case "application/problem+json":
      case "application/vnd.api+json":
      case "text/json":
        const text2 = yield response.text();
        return text2.length > 0 ? fromJson2(text2) : void 0;
      default:
        if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
          const text3 = yield response.text();
          return text3.length > 0 ? fromJson2(text3) : void 0;
        }
        return yield response.text();
    }
  });
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/getFetchFn.mjs
var __awaiter22 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getFetchFn2() {
  return __awaiter22(this, void 0, void 0, function* () {
    return fetch;
  });
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/getRequestBody.mjs
var __awaiter23 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getRequestBody2(_a) {
  return __awaiter23(this, arguments, void 0, function* ({ body, type }) {
    if (type === "form") {
      return toQueryString2(body, { arrayFormat: "repeat", encode: true });
    }
    if (type.includes("json")) {
      return toJson2(body);
    } else {
      return body;
    }
  });
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/signals.mjs
var TIMEOUT2 = "timeout";
function getTimeoutSignal2(timeoutMs) {
  const controller = new AbortController();
  const abortId = setTimeout(() => controller.abort(TIMEOUT2), timeoutMs);
  return { signal: controller.signal, abortId };
}
function anySignal2(...args) {
  const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  const controller = new AbortController();
  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
      break;
    }
    signal.addEventListener("abort", () => controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
      signal: controller.signal
    });
  }
  return controller.signal;
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/makeRequest.mjs
var __awaiter24 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var makeRequest2 = (fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex) => __awaiter24(void 0, void 0, void 0, function* () {
  const signals = [];
  let timeoutAbortId = void 0;
  if (timeoutMs != null) {
    const { signal, abortId } = getTimeoutSignal2(timeoutMs);
    timeoutAbortId = abortId;
    signals.push(signal);
  }
  if (abortSignal != null) {
    signals.push(abortSignal);
  }
  let newSignals = anySignal2(signals);
  const response = yield fetchFn(url, {
    method,
    headers,
    body: requestBody,
    signal: newSignals,
    credentials: withCredentials ? "include" : void 0,
    // @ts-ignore
    duplex
  });
  if (timeoutAbortId != null) {
    clearTimeout(timeoutAbortId);
  }
  return response;
});

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/Headers.mjs
var Headers3;
if (typeof globalThis.Headers !== "undefined") {
  Headers3 = globalThis.Headers;
} else {
  Headers3 = class Headers5 {
    constructor(init) {
      this.headers = /* @__PURE__ */ new Map();
      if (init) {
        if (init instanceof Headers5) {
          init.forEach((value, key) => this.append(key, value));
        } else if (Array.isArray(init)) {
          for (const [key, value] of init) {
            if (typeof key === "string" && typeof value === "string") {
              this.append(key, value);
            } else {
              throw new TypeError("Each header entry must be a [string, string] tuple");
            }
          }
        } else {
          for (const [key, value] of Object.entries(init)) {
            if (typeof value === "string") {
              this.append(key, value);
            } else {
              throw new TypeError("Header values must be strings");
            }
          }
        }
      }
    }
    append(name, value) {
      const key = name.toLowerCase();
      const existing = this.headers.get(key) || [];
      this.headers.set(key, [...existing, value]);
    }
    delete(name) {
      const key = name.toLowerCase();
      this.headers.delete(key);
    }
    get(name) {
      const key = name.toLowerCase();
      const values = this.headers.get(key);
      return values ? values.join(", ") : null;
    }
    has(name) {
      const key = name.toLowerCase();
      return this.headers.has(key);
    }
    set(name, value) {
      const key = name.toLowerCase();
      this.headers.set(key, [value]);
    }
    forEach(callbackfn, thisArg) {
      const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
      this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
    }
    getSetCookie() {
      return this.headers.get("set-cookie") || [];
    }
    *entries() {
      for (const [key, values] of this.headers.entries()) {
        yield [key, values.join(", ")];
      }
    }
    *keys() {
      yield* this.headers.keys();
    }
    *values() {
      for (const values of this.headers.values()) {
        yield values.join(", ");
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
  };
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/RawResponse.mjs
var abortRawResponse2 = {
  headers: new Headers3(),
  redirected: false,
  status: 499,
  statusText: "Client Closed Request",
  type: "error",
  url: ""
};
var unknownRawResponse2 = {
  headers: new Headers3(),
  redirected: false,
  status: 0,
  statusText: "Unknown Error",
  type: "error",
  url: ""
};
function toRawResponse2(response) {
  return {
    headers: response.headers,
    redirected: response.redirected,
    status: response.status,
    statusText: response.statusText,
    type: response.type,
    url: response.url
  };
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/requestWithRetries.mjs
var __awaiter25 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var INITIAL_RETRY_DELAY2 = 1e3;
var MAX_RETRY_DELAY2 = 6e4;
var DEFAULT_MAX_RETRIES2 = 2;
var JITTER_FACTOR2 = 0.2;
function addPositiveJitter2(delay) {
  const jitterMultiplier = 1 + Math.random() * JITTER_FACTOR2;
  return delay * jitterMultiplier;
}
function addSymmetricJitter2(delay) {
  const jitterMultiplier = 1 + (Math.random() - 0.5) * JITTER_FACTOR2;
  return delay * jitterMultiplier;
}
function getRetryDelayFromHeaders2(response, retryAttempt) {
  const retryAfter = response.headers.get("Retry-After");
  if (retryAfter) {
    const retryAfterSeconds = parseInt(retryAfter, 10);
    if (!isNaN(retryAfterSeconds) && retryAfterSeconds > 0) {
      return Math.min(retryAfterSeconds * 1e3, MAX_RETRY_DELAY2);
    }
    const retryAfterDate = new Date(retryAfter);
    if (!isNaN(retryAfterDate.getTime())) {
      const delay = retryAfterDate.getTime() - Date.now();
      if (delay > 0) {
        return Math.min(Math.max(delay, 0), MAX_RETRY_DELAY2);
      }
    }
  }
  const rateLimitReset = response.headers.get("X-RateLimit-Reset");
  if (rateLimitReset) {
    const resetTime = parseInt(rateLimitReset, 10);
    if (!isNaN(resetTime)) {
      const delay = resetTime * 1e3 - Date.now();
      if (delay > 0) {
        return addPositiveJitter2(Math.min(delay, MAX_RETRY_DELAY2));
      }
    }
  }
  return addSymmetricJitter2(Math.min(INITIAL_RETRY_DELAY2 * Math.pow(2, retryAttempt), MAX_RETRY_DELAY2));
}
function requestWithRetries2(requestFn_1) {
  return __awaiter25(this, arguments, void 0, function* (requestFn, maxRetries = DEFAULT_MAX_RETRIES2) {
    let response = yield requestFn();
    for (let i5 = 0; i5 < maxRetries; ++i5) {
      if ([408, 429].includes(response.status) || response.status >= 500) {
        const delay = getRetryDelayFromHeaders2(response, i5);
        yield new Promise((resolve) => setTimeout(resolve, delay));
        response = yield requestFn();
      } else {
        break;
      }
    }
    return response;
  });
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/Fetcher.mjs
var __awaiter26 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
function getHeaders2(args) {
  return __awaiter26(this, void 0, void 0, function* () {
    var _a;
    const newHeaders = {};
    if (args.body !== void 0 && args.contentType != null) {
      newHeaders["Content-Type"] = args.contentType;
    }
    if (args.headers == null) {
      return newHeaders;
    }
    for (const [key, value] of Object.entries(args.headers)) {
      const result = yield EndpointSupplier2.get(value, { endpointMetadata: (_a = args.endpointMetadata) !== null && _a !== void 0 ? _a : {} });
      if (typeof result === "string") {
        newHeaders[key] = result;
        continue;
      }
      if (result == null) {
        continue;
      }
      newHeaders[key] = `${result}`;
    }
    return newHeaders;
  });
}
function fetcherImpl2(args) {
  return __awaiter26(this, void 0, void 0, function* () {
    var _a, _b;
    const url = createRequestUrl2(args.url, args.queryParameters);
    const requestBody = yield getRequestBody2({
      body: args.body,
      type: (_a = args.requestType) !== null && _a !== void 0 ? _a : "other"
    });
    const fetchFn = (_b = args.fetchFn) !== null && _b !== void 0 ? _b : yield getFetchFn2();
    try {
      const response = yield requestWithRetries2(() => __awaiter26(this, void 0, void 0, function* () {
        return makeRequest2(fetchFn, url, args.method, yield getHeaders2(args), requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
      }), args.maxRetries);
      if (response.status >= 200 && response.status < 400) {
        return {
          ok: true,
          body: yield getResponseBody2(response, args.responseType),
          headers: response.headers,
          rawResponse: toRawResponse2(response)
        };
      } else {
        return {
          ok: false,
          error: {
            reason: "status-code",
            statusCode: response.status,
            body: yield getErrorResponseBody2(response)
          },
          rawResponse: toRawResponse2(response)
        };
      }
    } catch (error) {
      if (args.abortSignal != null && args.abortSignal.aborted) {
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: "The user aborted a request"
          },
          rawResponse: abortRawResponse2
        };
      } else if (error instanceof Error && error.name === "AbortError") {
        return {
          ok: false,
          error: {
            reason: "timeout"
          },
          rawResponse: abortRawResponse2
        };
      } else if (error instanceof Error) {
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: error.message
          },
          rawResponse: unknownRawResponse2
        };
      }
      return {
        ok: false,
        error: {
          reason: "unknown",
          errorMessage: toJson2(error)
        },
        rawResponse: unknownRawResponse2
      };
    }
  });
}
var fetcher2 = fetcherImpl2;

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/fetcher/HttpResponsePromise.mjs
var __awaiter27 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var HttpResponsePromise2 = class _HttpResponsePromise extends Promise {
  constructor(promise) {
    super((resolve) => {
      resolve(void 0);
    });
    this.innerPromise = promise;
  }
  /**
   * Creates an `HttpResponsePromise` from a function that returns a promise.
   *
   * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
   * @param args - Arguments to pass to the function.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromFunction(fn, ...args) {
    return new _HttpResponsePromise(fn(...args));
  }
  /**
   * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
   *
   * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
   * @returns A function that returns an `HttpResponsePromise` instance.
   */
  static interceptFunction(fn) {
    return (...args) => {
      return _HttpResponsePromise.fromPromise(fn(...args));
    };
  }
  /**
   * Creates an `HttpResponsePromise` from an existing promise.
   *
   * @param promise - A promise resolving to a `WithRawResponse` object.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromPromise(promise) {
    return new _HttpResponsePromise(promise);
  }
  /**
   * Creates an `HttpResponsePromise` from an executor function.
   *
   * @param executor - A function that takes resolve and reject callbacks to create a promise.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromExecutor(executor) {
    const promise = new Promise(executor);
    return new _HttpResponsePromise(promise);
  }
  /**
   * Creates an `HttpResponsePromise` from a resolved result.
   *
   * @param result - A `WithRawResponse` object to resolve immediately.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromResult(result) {
    const promise = Promise.resolve(result);
    return new _HttpResponsePromise(promise);
  }
  unwrap() {
    if (!this.unwrappedPromise) {
      this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
    }
    return this.unwrappedPromise;
  }
  /** @inheritdoc */
  then(onfulfilled, onrejected) {
    return this.unwrap().then(onfulfilled, onrejected);
  }
  /** @inheritdoc */
  catch(onrejected) {
    return this.unwrap().catch(onrejected);
  }
  /** @inheritdoc */
  finally(onfinally) {
    return this.unwrap().finally(onfinally);
  }
  /**
   * Retrieves the data and raw response.
   *
   * @returns A promise resolving to a `WithRawResponse` object.
   */
  withRawResponse() {
    return __awaiter27(this, void 0, void 0, function* () {
      return yield this.innerPromise;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/runtime/runtime.mjs
var RUNTIME2 = evaluateRuntime2();
function evaluateRuntime2() {
  var _a, _b, _c, _d, _e;
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  if (isBrowser) {
    return {
      type: "browser",
      version: window.navigator.userAgent
    };
  }
  const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
  if (isCloudflare) {
    return {
      type: "workerd"
    };
  }
  const isEdgeRuntime = typeof EdgeRuntime === "string";
  if (isEdgeRuntime) {
    return {
      type: "edge-runtime"
    };
  }
  const isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" || ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
  if (isWebWorker) {
    return {
      type: "web-worker"
    };
  }
  const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  if (isDeno) {
    return {
      type: "deno",
      version: Deno.version.deno
    };
  }
  const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  if (isBun) {
    return {
      type: "bun",
      version: Bun.version
    };
  }
  const isNode2 = typeof process !== "undefined" && "version" in process && !!process.version && "versions" in process && !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
  if (isNode2) {
    return {
      type: "node",
      version: process.versions.node,
      parsedVersion: Number(process.versions.node.split(".")[0])
    };
  }
  const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  if (isReactNative) {
    return {
      type: "react-native"
    };
  }
  return {
    type: "unknown"
  };
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/url/index.mjs
var url_exports2 = {};
__export(url_exports2, {
  encodePathParam: () => encodePathParam2,
  join: () => join2,
  toQueryString: () => toQueryString2
});

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/url/encodePathParam.mjs
function encodePathParam2(param) {
  if (param === null) {
    return "null";
  }
  const typeofParam = typeof param;
  switch (typeofParam) {
    case "undefined":
      return "undefined";
    case "string":
    case "number":
    case "boolean":
      break;
    default:
      param = String(param);
      break;
  }
  return encodeURIComponent(param);
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/url/join.mjs
function join2(base, ...segments) {
  if (!base) {
    return "";
  }
  if (segments.length === 0) {
    return base;
  }
  if (base.includes("://")) {
    let url;
    try {
      url = new URL(base);
    } catch (_a) {
      return joinPath2(base, ...segments);
    }
    const lastSegment = segments[segments.length - 1];
    const shouldPreserveTrailingSlash = lastSegment && lastSegment.endsWith("/");
    for (const segment of segments) {
      const cleanSegment = trimSlashes2(segment);
      if (cleanSegment) {
        url.pathname = joinPathSegments2(url.pathname, cleanSegment);
      }
    }
    if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
      url.pathname += "/";
    }
    return url.toString();
  }
  return joinPath2(base, ...segments);
}
function joinPath2(base, ...segments) {
  if (segments.length === 0) {
    return base;
  }
  let result = base;
  const lastSegment = segments[segments.length - 1];
  const shouldPreserveTrailingSlash = lastSegment && lastSegment.endsWith("/");
  for (const segment of segments) {
    const cleanSegment = trimSlashes2(segment);
    if (cleanSegment) {
      result = joinPathSegments2(result, cleanSegment);
    }
  }
  if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
    result += "/";
  }
  return result;
}
function joinPathSegments2(left, right) {
  if (left.endsWith("/")) {
    return left + right;
  }
  return left + "/" + right;
}
function trimSlashes2(str) {
  if (!str)
    return str;
  let start = 0;
  let end = str.length;
  if (str.startsWith("/"))
    start = 1;
  if (str.endsWith("/"))
    end = str.length - 1;
  return start === 0 && end === str.length ? str : str.slice(start, end);
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/base64.mjs
function bytesToBase642(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}
function base64Encode2(input) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "utf8").toString("base64");
  }
  const bytes = new TextEncoder().encode(input);
  return bytesToBase642(bytes);
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/errors/MyOrganizationError.mjs
var MyOrganizationError = class _MyOrganizationError extends Error {
  constructor({ message, statusCode, body, rawResponse }) {
    super(buildMessage2({ message, statusCode, body }));
    Object.setPrototypeOf(this, _MyOrganizationError.prototype);
    this.statusCode = statusCode;
    this.body = body;
    this.rawResponse = rawResponse;
  }
};
function buildMessage2({ message, statusCode, body }) {
  let lines = [];
  if (message != null) {
    lines.push(message);
  }
  if (statusCode != null) {
    lines.push(`Status code: ${statusCode.toString()}`);
  }
  if (body != null) {
    lines.push(`Body: ${toJson2(body, void 0, 2)}`);
  }
  return lines.join("\n");
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/errors/MyOrganizationTimeoutError.mjs
var MyOrganizationTimeoutError = class _MyOrganizationTimeoutError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _MyOrganizationTimeoutError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/errors/UnauthorizedError.mjs
var UnauthorizedError2 = class _UnauthorizedError extends MyOrganizationError {
  constructor(body, rawResponse) {
    super({
      message: "UnauthorizedError",
      statusCode: 401,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/errors/ForbiddenError.mjs
var ForbiddenError2 = class _ForbiddenError extends MyOrganizationError {
  constructor(body, rawResponse) {
    super({
      message: "ForbiddenError",
      statusCode: 403,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _ForbiddenError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/errors/NotFoundError.mjs
var NotFoundError2 = class _NotFoundError extends MyOrganizationError {
  constructor(body, rawResponse) {
    super({
      message: "NotFoundError",
      statusCode: 404,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _NotFoundError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/errors/TooManyRequestsError.mjs
var TooManyRequestsError2 = class _TooManyRequestsError extends MyOrganizationError {
  constructor(body, rawResponse) {
    super({
      message: "TooManyRequestsError",
      statusCode: 429,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _TooManyRequestsError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/errors/BadRequestError.mjs
var BadRequestError2 = class _BadRequestError extends MyOrganizationError {
  constructor(body, rawResponse) {
    super({
      message: "BadRequestError",
      statusCode: 400,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _BadRequestError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/errors/ConflictError.mjs
var ConflictError = class _ConflictError extends MyOrganizationError {
  constructor(body, rawResponse) {
    super({
      message: "ConflictError",
      statusCode: 409,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, _ConflictError.prototype);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/environments.mjs
var MyOrganizationEnvironment = {
  Default: "https://%7BTENANT%7D.auth0.com/my-org"
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/core/headers.mjs
function mergeHeaders2(...headersArray) {
  const result = {};
  for (const [key, value] of headersArray.filter((headers) => headers != null).flatMap((headers) => Object.entries(headers))) {
    const insensitiveKey = key.toLowerCase();
    if (value != null) {
      result[insensitiveKey] = value;
    } else if (insensitiveKey in result) {
      delete result[insensitiveKey];
    }
  }
  return result;
}
function mergeOnlyDefinedHeaders2(...headersArray) {
  const result = {};
  for (const [key, value] of headersArray.filter((headers) => headers != null).flatMap((headers) => Object.entries(headers))) {
    const insensitiveKey = key.toLowerCase();
    if (value != null) {
      result[insensitiveKey] = value;
    }
  }
  return result;
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organizationDetails/client/Client.mjs
var __awaiter28 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var OrganizationDetails = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Retrieve details for an Organization.
   *
   * @param {OrganizationDetails.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organizationDetails.get()
   */
  get(requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter28(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:details"] },
          { OAuth2AuthCode: ["read:my_org:details"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "details"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /details.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Update the details of a specific Organization, such as display name and branding options.
   *
   * @param {MyOrganization.UpdateOrganizationDetailsRequestContent} request
   * @param {OrganizationDetails.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organizationDetails.update({
   *         name: "testorg",
   *         display_name: "Test Organization",
   *         branding: {
   *             logo_url: "http://example.com/logo.png",
   *             colors: {
   *                 primary: "#000000",
   *                 page_background: "#FFFFFF"
   *             }
   *         }
   *     })
   */
  update(request, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__update(request, requestOptions));
  }
  __update(request, requestOptions) {
    return __awaiter28(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["update:my_org:details"] },
          { OAuth2AuthCode: ["update:my_org:details"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "details"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling PATCH /details.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter28(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/configuration/resources/identityProviders/client/Client.mjs
var __awaiter29 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var IdentityProviders = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Retrieve the connection profile for the application. This will give the components all of the information they will need to be successful. The SDK provider for the components should manage fetching and caching this information for all components.
   *
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.configuration.identityProviders.get()
   */
  get(requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter29(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:configuration"] },
          { OAuth2AuthCode: ["read:my_org:configuration"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "config/identity-providers"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /config/identity-providers.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter29(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/configuration/client/Client.mjs
var __awaiter30 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Configuration = class {
  constructor(_options) {
    this._options = _options;
  }
  get identityProviders() {
    var _a;
    return (_a = this._identityProviders) !== null && _a !== void 0 ? _a : this._identityProviders = new IdentityProviders(this._options);
  }
  /**
   * Retrieve the configuration for the /my-org API. This will return all stored client information with the exception of attributes that are identifiers. Identifier attributes will be given their own endpoint that will return the full object. This will give the components all of the information they will need to be successful. The SDK provider for the components should manage fetching and caching this information for all components.
   *
   * @param {Configuration.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.configuration.get()
   */
  get(requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter30(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:configuration"] },
          { OAuth2AuthCode: ["read:my_org:configuration"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "config"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /config.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter30(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/domains/resources/verify/client/Client.mjs
var __awaiter31 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Verify = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Get a verification text and start the domain verification process for a particular domain.
   *
   * @param {MyOrganization.OrgDomainId} domainId
   * @param {Verify.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.domains.verify.create("domain_id")
   */
  create(domainId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__create(domainId, requestOptions));
  }
  __create(domainId, requestOptions) {
    return __awaiter31(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["update:my_org:domains"] },
          { OAuth2AuthCode: ["update:my_org:domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `domains/${url_exports2.encodePathParam(domainId)}/verify`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /domains/{domain_id}/verify.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter31(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/domains/resources/identityProviders/client/Client.mjs
var __awaiter32 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var IdentityProviders2 = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Retrieve the list of identity providers that have a specific organization domain alias.
   *
   * @param {MyOrganization.OrgDomainId} domainId
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.domains.identityProviders.get("domain_id")
   */
  get(domainId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(domainId, requestOptions));
  }
  __get(domainId, requestOptions) {
    return __awaiter32(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:domains", "read:my_org:identity_providers"] },
          { OAuth2AuthCode: ["read:my_org:domains", "read:my_org:identity_providers"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `domains/${url_exports2.encodePathParam(domainId)}/identity-providers`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /domains/{domain_id}/identity-providers.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter32(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/domains/client/Client.mjs
var __awaiter33 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Domains = class {
  constructor(_options) {
    this._options = _options;
  }
  get verify() {
    var _a;
    return (_a = this._verify) !== null && _a !== void 0 ? _a : this._verify = new Verify(this._options);
  }
  get identityProviders() {
    var _a;
    return (_a = this._identityProviders) !== null && _a !== void 0 ? _a : this._identityProviders = new IdentityProviders2(this._options);
  }
  /**
   * Lists all domains pending and verified for an organization.
   *
   * @param {Domains.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.domains.list()
   */
  list(requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter33(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:domains"] },
          { OAuth2AuthCode: ["read:my_org:domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "domains"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /domains.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Create a new domain for an organization.
   *
   * @param {MyOrganization.CreateOrganizationDomainRequestContent} request
   * @param {Domains.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.ConflictError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.domains.create({
   *         domain: "acme.com"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter33(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["create:my_org:domains"] },
          { OAuth2AuthCode: ["create:my_org:domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "domains"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /domains.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Retrieve a domain for an organization.
   *
   * @param {MyOrganization.OrgDomainId} domainId
   * @param {Domains.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.domains.get("domain_id")
   */
  get(domainId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(domainId, requestOptions));
  }
  __get(domainId, requestOptions) {
    return __awaiter33(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:domains"] },
          { OAuth2AuthCode: ["read:my_org:domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `domains/${url_exports2.encodePathParam(domainId)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /domains/{domain_id}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Remove a domain from this organization.
   *
   * @param {MyOrganization.OrgDomainId} domainId
   * @param {Domains.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.domains.delete("domain_id")
   */
  delete(domainId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__delete(domainId, requestOptions));
  }
  __delete(domainId, requestOptions) {
    return __awaiter33(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["delete:my_org:domains"] },
          { OAuth2AuthCode: ["delete:my_org:domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `domains/${url_exports2.encodePathParam(domainId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling DELETE /domains/{domain_id}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter33(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/identityProviders/resources/domains/client/Client.mjs
var __awaiter34 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Domains2 = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * Add a domain to the identity provider's list of domains for [Home Realm Discovery (HRD)](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authentication#home-realm-discovery). The domain passed must be claimed and verified by this organization.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {MyOrganization.CreateIdpDomainRequestContent} request
   * @param {Domains.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.ConflictError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.domains.create("idp_id", {
   *         domain: "my-domain.com"
   *     })
   */
  create(idpId, request, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__create(idpId, request, requestOptions));
  }
  __create(idpId, request, requestOptions) {
    return __awaiter34(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["create:my_org:identity_providers_domains"] },
          { OAuth2AuthCode: ["create:my_org:identity_providers_domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/domains`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /identity-providers/{idp_id}/domains.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Remove a domain from an identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {MyOrganization.OrgDomainName} domain
   * @param {Domains.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.domains.delete("idp_id", "domain")
   */
  delete(idpId, domain, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__delete(idpId, domain, requestOptions));
  }
  __delete(idpId, domain, requestOptions) {
    return __awaiter34(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["delete:my_org:identity_providers_domains"] },
          { OAuth2AuthCode: ["delete:my_org:identity_providers_domains"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/domains/${url_exports2.encodePathParam(domain)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling DELETE /identity-providers/{idp_id}/domains/{domain}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter34(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/identityProviders/resources/provisioning/resources/scimTokens/client/Client.mjs
var __awaiter35 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ScimTokens = class {
  constructor(_options) {
    this._options = _options;
  }
  /**
   * List the Provisioning SCIM tokens for this identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {ScimTokens.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.provisioning.scimTokens.list("idp_id")
   */
  list(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__list(idpId, requestOptions));
  }
  __list(idpId, requestOptions) {
    return __awaiter35(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:identity_providers_scim_tokens"] },
          { OAuth2AuthCode: ["read:my_org:identity_providers_scim_tokens"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/provisioning/scim-tokens`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /identity-providers/{idp_id}/provisioning/scim-tokens.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Create a Provisioning SCIM token for this identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {MyOrganization.CreateIdpProvisioningScimTokenRequestContent} request
   * @param {ScimTokens.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.provisioning.scimTokens.create("idp_id", {
   *         token_lifetime: 86400
   *     })
   */
  create(idpId, request = {}, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__create(idpId, request, requestOptions));
  }
  __create(idpId_1) {
    return __awaiter35(this, arguments, void 0, function* (idpId, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["create:my_org:identity_providers_scim_tokens"] },
          { OAuth2AuthCode: ["create:my_org:identity_providers_scim_tokens"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/provisioning/scim-tokens`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /identity-providers/{idp_id}/provisioning/scim-tokens.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Delete a Provisioning SCIM configuration for an identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {MyOrganization.IdpProvisioningScimTokenId} idpScimTokenId
   * @param {ScimTokens.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.provisioning.scimTokens.delete("idp_id", "idp_scim_token_id")
   */
  delete(idpId, idpScimTokenId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__delete(idpId, idpScimTokenId, requestOptions));
  }
  __delete(idpId, idpScimTokenId, requestOptions) {
    return __awaiter35(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["delete:my_org:identity_providers_scim_tokens"] },
          { OAuth2AuthCode: ["delete:my_org:identity_providers_scim_tokens"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/provisioning/scim-tokens/${url_exports2.encodePathParam(idpScimTokenId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling DELETE /identity-providers/{idp_id}/provisioning/scim-tokens/{idp_scim_token_id}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter35(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/identityProviders/resources/provisioning/client/Client.mjs
var __awaiter36 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var Provisioning = class {
  constructor(_options) {
    this._options = _options;
  }
  get scimTokens() {
    var _a;
    return (_a = this._scimTokens) !== null && _a !== void 0 ? _a : this._scimTokens = new ScimTokens(this._options);
  }
  /**
   * Retrieve the Provisioning configuration for this identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {Provisioning.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.provisioning.get("idp_id")
   */
  get(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(idpId, requestOptions));
  }
  __get(idpId, requestOptions) {
    return __awaiter36(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:identity_providers_provisioning"] },
          { OAuth2AuthCode: ["read:my_org:identity_providers_provisioning"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/provisioning`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /identity-providers/{idp_id}/provisioning.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Create the Provisioning configuration for this identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {Provisioning.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.provisioning.create("idp_id")
   */
  create(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__create(idpId, requestOptions));
  }
  __create(idpId, requestOptions) {
    return __awaiter36(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["create:my_org:identity_providers_provisioning"] },
          { OAuth2AuthCode: ["create:my_org:identity_providers_provisioning"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/provisioning`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /identity-providers/{idp_id}/provisioning.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Delete the Provisioning configuration for an identity provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {Provisioning.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.provisioning.delete("idp_id")
   */
  delete(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__delete(idpId, requestOptions));
  }
  __delete(idpId, requestOptions) {
    return __awaiter36(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["delete:my_org:identity_providers_provisioning"] },
          { OAuth2AuthCode: ["delete:my_org:identity_providers_provisioning"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/provisioning`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling DELETE /identity-providers/{idp_id}/provisioning.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter36(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/resources/identityProviders/client/Client.mjs
var __awaiter37 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var IdentityProviders3 = class {
  constructor(_options) {
    this._options = _options;
  }
  get domains() {
    var _a;
    return (_a = this._domains) !== null && _a !== void 0 ? _a : this._domains = new Domains2(this._options);
  }
  get provisioning() {
    var _a;
    return (_a = this._provisioning) !== null && _a !== void 0 ? _a : this._provisioning = new Provisioning(this._options);
  }
  /**
   * List the identity providers associated with this organization.
   *
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.list()
   */
  list(requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:identity_providers"] },
          { OAuth2AuthCode: ["read:my_org:identity_providers"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "identity-providers"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /identity-providers.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Create an identity provider associated with this organization.
   *
   * @param {MyOrganization.CreateIdentityProviderRequestContent} request
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.ConflictError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.create({
   *         name: "oidcIdp",
   *         strategy: "oidc",
   *         domains: ["mydomain.com"],
   *         display_name: "OIDC IdP",
   *         show_as_button: true,
   *         assign_membership_on_login: false,
   *         is_enabled: true,
   *         options: {
   *             type: "front_channel",
   *             client_id: "a8f3b2e7-5d1c-4f9a-8b0d-2e1c3a5b6f7d",
   *             client_secret: "KzQp2sVxR8nTgMjFhYcEWuLoIbDvUoC6A9B1zX7yWqFjHkGrP5sQdLmNp",
   *             discovery_url: "https://{yourDomain}/.well-known/openid-configuration"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["create:my_org:identity_providers"] },
          { OAuth2AuthCode: ["create:my_org:identity_providers"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, "identity-providers"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /identity-providers.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Retrieve the details for one particular identity-provider.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.get("idp_id")
   */
  get(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__get(idpId, requestOptions));
  }
  __get(idpId, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["read:my_org:identity_providers"] },
          { OAuth2AuthCode: ["read:my_org:identity_providers"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling GET /identity-providers/{idp_id}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Delete an identity provider from this organization.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.delete("idp_id")
   */
  delete(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__delete(idpId, requestOptions));
  }
  __delete(idpId, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["delete:my_org:identity_providers"] },
          { OAuth2AuthCode: ["delete:my_org:identity_providers"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling DELETE /identity-providers/{idp_id}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Update an identity provider associated with this organization.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {MyOrganization.UpdateIdentityProviderRequestContent} request
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.update("idp_id", {
   *         display_name: "OIDC IdP",
   *         show_as_button: true,
   *         assign_membership_on_login: false,
   *         is_enabled: true,
   *         options: {
   *             type: "front_channel",
   *             client_id: "a8f3b2e7-5d1c-4f9a-8b0d-2e1c3a5b6f7d",
   *             client_secret: "KzQp2sVxR8nTgMjFhYcEWuLoIbDvUoC6A9B1zX7yWqFjHkGrP5sQdLmNp",
   *             discovery_url: "https://{yourDomain}/.well-known/openid-configuration"
   *         }
   *     })
   */
  update(idpId, request, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__update(idpId, request, requestOptions));
  }
  __update(idpId, request, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["update:my_org:identity_providers"] },
          { OAuth2AuthCode: ["update:my_org:identity_providers"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling PATCH /identity-providers/{idp_id}.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  /**
   * Delete underlying identity provider from this organization.
   *
   * @param {MyOrganization.IdpId} idpId
   * @param {IdentityProviders.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link MyOrganization.BadRequestError}
   * @throws {@link MyOrganization.UnauthorizedError}
   * @throws {@link MyOrganization.ForbiddenError}
   * @throws {@link MyOrganization.NotFoundError}
   * @throws {@link MyOrganization.TooManyRequestsError}
   *
   * @example
   *     await client.organization.identityProviders.detach("idp_id")
   */
  detach(idpId, requestOptions) {
    return HttpResponsePromise2.fromPromise(this.__detach(idpId, requestOptions));
  }
  __detach(idpId, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _metadata = {
        security: [
          { OAuth2ClientCredentials: ["update:my_org:identity_providers_detach"] },
          { OAuth2AuthCode: ["update:my_org:identity_providers_detach"] }
        ]
      };
      let _headers = mergeHeaders2((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders2({ Authorization: yield this._getAuthorizationHeader(_metadata) }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher2)({
        url: url_exports2.join((_d = (_c = yield Supplier2.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier2.get(this._options.environment)) !== null && _d !== void 0 ? _d : MyOrganizationEnvironment.Default, `identity-providers/${url_exports2.encodePathParam(idpId)}/detach`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        endpointMetadata: _metadata,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError2(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError2(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError2(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError2(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError2(_response.error.body, _response.rawResponse);
          default:
            throw new MyOrganizationError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      switch (_response.error.reason) {
        case "non-json":
          throw new MyOrganizationError({
            statusCode: _response.error.statusCode,
            body: _response.error.rawBody,
            rawResponse: _response.rawResponse
          });
        case "timeout":
          throw new MyOrganizationTimeoutError("Timeout exceeded when calling POST /identity-providers/{idp_id}/detach.");
        case "unknown":
          throw new MyOrganizationError({
            message: _response.error.errorMessage,
            rawResponse: _response.rawResponse
          });
      }
    });
  }
  _getAuthorizationHeader(endpointMetadata) {
    return __awaiter37(this, void 0, void 0, function* () {
      return `Bearer ${yield EndpointSupplier2.get(this._options.token, { endpointMetadata })}`;
    });
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/api/resources/organization/client/Client.mjs
var Organization = class {
  constructor(_options) {
    this._options = _options;
  }
  get configuration() {
    var _a;
    return (_a = this._configuration) !== null && _a !== void 0 ? _a : this._configuration = new Configuration(this._options);
  }
  get domains() {
    var _a;
    return (_a = this._domains) !== null && _a !== void 0 ? _a : this._domains = new Domains(this._options);
  }
  get identityProviders() {
    var _a;
    return (_a = this._identityProviders) !== null && _a !== void 0 ? _a : this._identityProviders = new IdentityProviders3(this._options);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/Client.mjs
var MyOrganizationClient = class {
  constructor(_options) {
    this._options = _options;
  }
  get organizationDetails() {
    var _a;
    return (_a = this._organizationDetails) !== null && _a !== void 0 ? _a : this._organizationDetails = new OrganizationDetails(this._options);
  }
  get organization() {
    var _a;
    return (_a = this._organization) !== null && _a !== void 0 ? _a : this._organization = new Organization(this._options);
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/utils/base64url.mjs
function base64urlEncode2(str) {
  const base64 = base64Encode2(str);
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function base64urlEncodeJson2(obj) {
  const jsonString = JSON.stringify(obj);
  return base64urlEncode2(jsonString);
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/version.mjs
var SDK_VERSION2 = "1.0.0-beta.2";

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/utils/clientInfo.mjs
function generateClientInfo2() {
  var _a, _b;
  const runtimeType = (_a = RUNTIME2 === null || RUNTIME2 === void 0 ? void 0 : RUNTIME2.type) !== null && _a !== void 0 ? _a : "unknown";
  const runtimeKey = runtimeType === "workerd" ? "cloudflare-workers" : runtimeType;
  const runtimeVersion = (_b = RUNTIME2 === null || RUNTIME2 === void 0 ? void 0 : RUNTIME2.version) !== null && _b !== void 0 ? _b : "unknown";
  return {
    name: "myorganization-js",
    version: SDK_VERSION2,
    env: {
      [runtimeKey]: runtimeVersion
    }
  };
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/utils/auth0ClientTelemetry.mjs
var Auth0ClientTelemetry2 = class {
  constructor(options = {}) {
    this.clientInfo = options.clientInfo || generateClientInfo2();
  }
  /**
   * Get the Auth0-Client header value for telemetry.
   * This method generates the telemetry header that should be included in API requests.
   * @returns The Auth0-Client header value or undefined if client name is invalid
   */
  getAuth0ClientHeader() {
    if (typeof this.clientInfo.name === "string" && this.clientInfo.name.length > 0) {
      return base64urlEncodeJson2(this.clientInfo);
    }
    return void 0;
  }
  /**
   * Get headers object with Auth0-Client header included
   * @param existingHeaders - Existing headers to merge with
   * @returns Headers object with Auth0-Client header
   */
  getHeaders(existingHeaders = {}) {
    const auth0ClientHeader = this.getAuth0ClientHeader();
    if (auth0ClientHeader) {
      return Object.assign(Object.assign({}, existingHeaders), { "Auth0-Client": auth0ClientHeader });
    }
    return existingHeaders;
  }
};

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/wrappers/auth/Token.mjs
var __awaiter38 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createCoreTokenSupplier2(tokenSupplier) {
  if (typeof tokenSupplier === "string") {
    return tokenSupplier;
  }
  if (typeof tokenSupplier === "function") {
    return (_a) => __awaiter38(this, [_a], void 0, function* ({ endpointMetadata }) {
      const scopes = extractScopesFromMetadata2(endpointMetadata);
      const scope = scopes.join(" ");
      return yield tokenSupplier({ scope });
    });
  }
  throw new Error("Invalid token supplier provided");
}
function extractScopesFromMetadata2(endpointMetadata) {
  if (!endpointMetadata.security)
    return [];
  const scopes = /* @__PURE__ */ new Set();
  for (const securityCollection of endpointMetadata.security) {
    for (const schemeScopes of Object.values(securityCollection)) {
      for (const scope of schemeScopes) {
        scopes.add(scope);
      }
    }
  }
  return [...scopes];
}

// ../../node_modules/.pnpm/@auth0+myorganization-js@1.0.0-beta.2/node_modules/@auth0/myorganization-js/dist/esm/wrappers/MyOrganizationClient.mjs
var __awaiter39 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var MyOrganizationClient2 = class extends MyOrganizationClient {
  /**
   * Creates a new MyOrganization API client instance.
   *
   * @param _options - Configuration options for the MyOrganizationClient Client
   * @group MyOrganization API
   */
  constructor(_options) {
    const sanitizedDomain = _options.domain.replace(/^https?:\/\//, "").replace(/\/$/, "");
    const baseUrl = `https://${sanitizedDomain}/my-org`;
    const audience = `${baseUrl}/`;
    const headers = createTelemetryHeaders2(_options);
    const token = createTokenSupplier2(_options);
    const fetcher3 = "fetcher" in _options && _options.fetcher ? createCoreFetcherSupplier2(_options.fetcher, audience) : void 0;
    const clientOptions = Object.assign(Object.assign({ baseUrl: _options.baseUrl || baseUrl, headers }, fetcher3 && { fetcher: fetcher3 }), token !== void 0 && { token });
    super(clientOptions);
  }
};
function isClientOptionsWithToken2(_options) {
  return "token" in _options;
}
function isClientOptionsWithTokenProvider(_options) {
  return "tokenProvider" in _options;
}
function isClientOptionsWithFetcher2(_options) {
  return "fetcher" in _options;
}
function createTelemetryHeaders2(_options) {
  var _a;
  const headers = Object.assign({}, (_a = _options.headers) !== null && _a !== void 0 ? _a : {});
  if (_options.telemetry !== false) {
    const telemetry = new Auth0ClientTelemetry2({
      clientInfo: _options.clientInfo
    });
    const auth0ClientHeader = telemetry.getAuth0ClientHeader();
    if (auth0ClientHeader) {
      headers["Auth0-Client"] = auth0ClientHeader;
    }
  }
  return headers;
}
function createTokenSupplier2(_options) {
  if (isClientOptionsWithToken2(_options)) {
    return createCoreTokenSupplier2(_options.token);
  }
  if (isClientOptionsWithTokenProvider(_options)) {
    return () => _options.tokenProvider.getToken();
  }
  if (isClientOptionsWithFetcher2(_options)) {
    return "";
  }
  throw new Error("MyOrganizationClient must be configured with either 'token', 'tokenProvider', or 'fetcher' (that handles authorization headers)");
}
function createCoreFetcherSupplier2(fetcherSupplier, audience) {
  return (args) => __awaiter39(this, void 0, void 0, function* () {
    const scopes = args.endpointMetadata ? extractScopesFromMetadata2(args.endpointMetadata) : [];
    const authParams = scopes.length > 0 ? { scope: scopes, audience } : void 0;
    const init = {
      method: args.method,
      headers: args.headers,
      body: args.body ? JSON.stringify(args.body) : void 0,
      signal: args.abortSignal,
      credentials: args.withCredentials ? "include" : void 0
    };
    const response = yield fetcherSupplier(args.url, init, authParams);
    const responseBody = yield response.text();
    const rawResponse = {
      headers: response.headers,
      redirected: response.redirected,
      status: response.status,
      statusText: response.statusText,
      type: response.type,
      url: response.url
    };
    if (response.ok) {
      return {
        ok: true,
        body: responseBody ? JSON.parse(responseBody) : void 0,
        rawResponse
      };
    } else {
      return {
        ok: false,
        error: {
          reason: "status-code",
          statusCode: response.status,
          body: responseBody ? JSON.parse(responseBody) : void 0
        },
        rawResponse
      };
    }
  });
}

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_2) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i5 = 0;
          while (i5 < issue.path.length) {
            const el = issue.path[i5];
            const terminal = i5 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i5++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3;
  }
  get maxLength() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3;
  }
  get maxValue() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max3 = null;
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      } else if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return Number.isFinite(min3) && Number.isFinite(max3);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3;
  }
  get maxValue() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3 != null ? new Date(min3) : null;
  }
  get maxDate() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3 != null ? new Date(max3) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i5) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i5));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i5) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i5));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ; else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a4, b2) {
  const aType = getParsedType(a4);
  const bType = getParsedType(b2);
  if (a4 === b2) {
    return { valid: true, data: a4 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a4, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a4[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a4.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a4.length; index2++) {
      const itemA = a4[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b2) {
    return { valid: true, data: a4 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i5) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i5)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size4, message) {
    return this.min(size4, message).max(size4, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a4, b2) {
    return new _ZodPipeline({
      in: a4,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r5 = check(data);
      if (r5 instanceof Promise) {
        return r5.then((r6) => {
          if (!r6) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r5) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: ((arg) => ZodString.create({ ...arg, coerce: true })),
  number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
  boolean: ((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  })),
  bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
  date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
};
var NEVER = INVALID;

// ../core/dist/index.mjs
var dA = d({ "./translations/en-US.json": () => Promise.resolve().then(() => (init_en_US_WLJW6PYP(), en_US_WLJW6PYP_exports)), "./translations/ja.json": () => Promise.resolve().then(() => (init_ja_NAZSAUWF(), ja_NAZSAUWF_exports)) });
var u = { VAR_REGEX: /\${(\w+)}/g, COMPONENT_REGEX: /<(\w+)>(.*?)<\/\1>/g, getNestedValue(A, e2) {
  let t3 = A, r5 = e2.split(".");
  for (let o5 of r5) {
    if (t3 === null || typeof t3 != "object" || Array.isArray(t3) || !Object.prototype.hasOwnProperty.call(t3, o5)) return;
    t3 = t3[o5];
  }
  return t3;
}, substitute(A, e2) {
  return !e2 || !A.includes("${") ? A : (u.VAR_REGEX.lastIndex = 0, A.replace(u.VAR_REGEX, (t3, r5) => String(e2[r5] ?? "")));
}, parseComponents(A, e2) {
  if (!e2 || !A.includes("<")) return [A];
  let t3 = [], r5 = 0;
  u.COMPONENT_REGEX.lastIndex = 0;
  let o5;
  for (; (o5 = u.COMPONENT_REGEX.exec(A)) !== null; ) {
    let [a4, i5, n4] = o5, d2 = o5.index;
    d2 > r5 && t3.push(A.slice(r5, d2));
    let p = e2 ? e2[i5] : void 0;
    p ? typeof p == "function" ? t3.push(p(n4)) : t3.push(p) : t3.push(n4), r5 = d2 + a4.length;
  }
  return r5 < A.length && t3.push(A.slice(r5)), t3.length === 1 && typeof t3[0] == "string" ? [t3[0]] : t3;
}, createEnhancedTranslator(A, e2, t3) {
  let r5 = u.createTranslator(A, e2, t3), o5 = r5;
  return o5.trans = (a4, i5 = {}) => {
    let { components: n4, vars: d2, fallback: p } = i5, c = r5(a4, d2, p);
    return u.parseComponents(c, n4);
  }, o5;
}, createTranslator(A, e2, t3) {
  let r5 = `${A}.`, o5 = t3 && Object.keys(t3).length > 0;
  return (a4, i5, n4) => {
    let d2 = r5 + a4;
    if (o5) {
      let c = u.getNestedValue(t3, a4);
      if (c !== void 0) return u.substitute(String(c), i5);
    }
    if (!e2) return n4 || `${r5}${a4}`;
    let p = e2 ? u.getNestedValue(e2, d2) : void 0;
    return p !== void 0 ? u.substitute(String(p), i5) : n4 || (e2 ? a4 : `${r5}${a4}`);
  };
}, async loadTranslations(A, e2) {
  if (e2?.has(A)) return e2.get(A);
  try {
    let t3 = await dA(`./translations/${A}.json`), r5 = t3.default ?? t3;
    return e2 && e2.set(A, r5), r5;
  } catch {
    return e2 && e2.set(A, null), null;
  }
}, async loadTranslationsWithFallback(A, e2, t3) {
  let r5 = await u.loadTranslations(A, t3);
  return r5 || e2 && e2 !== A && (r5 = await u.loadTranslations(e2, t3), r5) ? r5 : A !== "en-US" && e2 !== "en-US" ? u.loadTranslations("en-US", t3) : null;
} };
async function P(A = {}) {
  let e2 = A.currentLanguage ?? "en-US", t3 = A.fallbackLanguage ?? "en-US", r5 = /* @__PURE__ */ new Map(), o5 = await u.loadTranslationsWithFallback(e2, t3, r5), a4 = e2, i5 = t3, n4 = o5;
  return { get currentLanguage() {
    return a4;
  }, get fallbackLanguage() {
    return i5;
  }, get translator() {
    return (p, c) => u.createEnhancedTranslator(p, n4, c);
  }, get commonTranslator() {
    return u.createEnhancedTranslator("common", n4);
  }, getCurrentTranslations() {
    return n4;
  }, async changeLanguage(p, c) {
    try {
      a4 = p, i5 = c ?? i5, n4 = await u.loadTranslationsWithFallback(a4, i5, r5);
    } catch (C) {
      throw new Error(`Failed to change language to '${p}': ${C instanceof Error ? C.message : "Unknown error"}`);
    }
  } };
}
function U(A, e2) {
  let t3 = "", r5 = (o5) => {
    t3 = o5;
  };
  if (A.authProxyUrl) {
    let a4 = `${A.authProxyUrl.replace(/\/$/, "")}/me`, i5 = async (n4, d2) => fetch(n4, { ...d2, headers: { ...d2?.headers, ...d2?.body && { "Content-Type": "application/json" }, ...t3 && { "auth0-scope": t3 } } });
    return { client: new MyAccountClient2({ domain: "", baseUrl: a4.trim(), telemetry: false, fetcher: i5 }), setLatestScopes: r5 };
  } else if (A.domain) {
    let o5 = async (a4, i5) => {
      let n4 = await e2.getToken(t3, "me"), d2 = new Headers(i5?.headers);
      return i5?.body && !d2.has("Content-Type") && d2.set("Content-Type", "application/json"), n4 && d2.set("Authorization", `Bearer ${n4}`), fetch(a4, { ...i5, headers: d2 });
    };
    return { client: new MyAccountClient2({ domain: A.domain.trim(), fetcher: o5 }), setLatestScopes: r5 };
  }
  throw new Error("Missing domain or proxy URL for MyAccountClient");
}
function W(A, e2) {
  let t3 = "", r5 = (o5) => {
    t3 = o5;
  };
  if (A.authProxyUrl) {
    let a4 = `${A.authProxyUrl.replace(/\/$/, "")}/my-org`, i5 = async (n4, d2) => fetch(n4, { ...d2, headers: { ...d2?.headers, ...d2?.body && { "Content-Type": "application/json" }, ...t3 && { "auth0-scope": t3 } } });
    return { client: new MyOrganizationClient2({ domain: "", baseUrl: a4.trim(), telemetry: false, fetcher: i5 }), setLatestScopes: r5 };
  } else if (A.domain) {
    let o5 = async (a4, i5) => {
      let n4 = await e2.getToken(t3, "my-org"), d2 = new Headers(i5?.headers);
      return i5?.body && !d2.has("Content-Type") && d2.set("Content-Type", "application/json"), n4 && d2.set("Authorization", `Bearer ${n4}`), fetch(a4, { ...i5, headers: d2 });
    };
    return { client: new MyOrganizationClient2({ domain: A.domain.trim(), fetcher: o5 }), setLatestScopes: r5 };
  }
  throw new Error("Missing domain or proxy URL for MyOrgClient");
}
var b = { toURL(A) {
  let e2 = A.endsWith("/") ? A : `${A}/`;
  return e2.startsWith("http://") || e2.startsWith("https://") ? e2 : `https://${e2}`;
} };
var O = /* @__PURE__ */ new Map();
var pA = /* @__PURE__ */ new Set(["consent_required", "login_required", "mfa_required"]);
var y = { buildAudience(A, e2) {
  let t3 = b.toURL(A);
  return t3 ? `${t3}${e2}/` : "";
}, createRequestKey(A, e2) {
  return `${A}:${e2}`;
}, isCoreClientAuthInitialized(A) {
  if (!A) throw new Error("TokenUtils: auth in CoreClient is not initialized.");
}, isCoreClientContextInterfaceInitialized(A) {
  if (!A || !A.contextInterface) throw new Error("TokenUtils: contextInterface in CoreClient is not initialized.");
}, validateTokenRequest(A) {
  if (!A.domain) throw new Error("TokenUtils: Auth0 domain is not configured");
}, isProxyMode(A) {
  return !!A.authProxyUrl;
}, async fetchToken(A, e2, t3, r5) {
  try {
    return (await A.getAccessTokenSilently({ authorizationParams: { audience: t3, scope: e2 }, detailedResponse: true, ...r5 ? { cacheMode: "off" } : {} })).access_token;
  } catch (o5) {
    if (typeof o5 == "object" && o5 !== null && "error" in o5 && pA.has(o5.error)) {
      let i5 = o5.error === "login_required" ? "login" : "consent", n4 = await A.getAccessTokenWithPopup({ authorizationParams: { audience: t3, scope: e2, prompt: i5 } });
      if (!n4) throw new Error("getAccessTokenWithPopup: Access token is not defined");
      return n4;
    }
    throw new Error("getAccessToken: failed", { cause: o5 });
  }
} };
function N(A) {
  return { async getToken(e2, t3, r5 = false) {
    if (y.isCoreClientAuthInitialized(A), y.isProxyMode(A)) return Promise.resolve(void 0);
    y.isCoreClientContextInterfaceInitialized(A), y.validateTokenRequest(A);
    let o5 = y.buildAudience(A.domain, t3), a4 = y.createRequestKey(e2, o5);
    r5 && O.delete(a4);
    let i5 = O.get(a4);
    if (i5) return i5;
    let n4 = y.fetchToken(A.contextInterface, e2, o5, r5);
    O.set(a4, n4);
    try {
      return await n4;
    } finally {
      O.delete(a4);
    }
  } };
}
function Z(A) {
  return !!A.authProxyUrl;
}
async function uA(A, e2) {
  let t3 = await P(e2 || { currentLanguage: "en-US", fallbackLanguage: "en-US" }), r5 = A;
  if (A.offlineMode) return { ...{ auth: r5, i18nService: t3, async getToken() {
  }, isProxyMode() {
    return false;
  }, ensureScopes: async () => {
  } }, myAccountApiClient: void 0, myOrgApiClient: void 0, getMyAccountApiClient() {
    throw new Error("API clients are not available in docs/demo mode (skipApiClients=true)");
  }, getMyOrgApiClient() {
    throw new Error("API clients are not available in docs/demo mode (skipApiClients=true)");
  } };
  let o5 = N(r5), { client: a4, setLatestScopes: i5 } = W(r5, o5), { client: n4, setLatestScopes: d2 } = U(r5, o5);
  return { ...{ auth: r5, i18nService: t3, async getToken(c, C, E = false) {
    return o5.getToken(c, C, E);
  }, isProxyMode() {
    return Z(r5);
  }, ensureScopes: async (c, C) => {
    if (Z(r5) && r5.authProxyUrl) C === "my-org" && i5(c), C === "me" && d2(c);
    else {
      if (!r5.domain) throw new Error("Authentication domain is missing, cannot initialize SPA service.");
      if (C === "my-org" && i5(c), C === "me" && d2(c), !await o5.getToken(c, C, true)) throw new Error(`Failed to retrieve token for audience: ${C}`);
    }
  } }, myAccountApiClient: n4, myOrgApiClient: a4, getMyAccountApiClient() {
    if (!n4) throw new Error("myAccountApiClient is not enabled. Please use it within Auth0ComponentProvider.");
    return n4;
  }, getMyOrgApiClient() {
    if (!a4) throw new Error("myOrgApiClient is not enabled. Please ensure you are in an Auth0 Organization context.");
    return a4;
  } };
}
var mA = (A, e2) => external_exports.object({ contact: external_exports.string().email({ message: "Please enter a valid email address" }) });
mA();
var CA = /^\+?[0-9\s\-()]{8,25}$/;
var fA = (A, e2) => external_exports.object({ contact: external_exports.string().regex(CA, { message: "Please enter a valid phone number" }) });
fA();
var h = (A = {}) => {
  let { required: e2 = true, regex: t3, minLength: r5, maxLength: o5, errorMessage: a4 } = A, i5 = external_exports.string();
  if (e2) {
    let n4 = r5 && r5 > 0 ? r5 : 1;
    return i5 = i5.min(n4, a4 || `Minimum ${n4} characters required`), o5 && (i5 = i5.max(o5, `Maximum ${o5} characters allowed`)), t3 && (i5 = i5.regex(t3, a4 || "Invalid format")), i5;
  }
  return external_exports.string().optional().refine((n4) => n4 ? !(r5 && n4.length < r5 || o5 && n4.length > o5 || t3 && !t3.test(n4)) : true, { message: a4 || "Invalid format" });
};
var V = (A = {}) => {
  let { required: e2 = false, regex: t3, errorMessage: r5 } = A, o5 = r5 || "Please enter a valid HTTP";
  if (t3) return e2 ? external_exports.string().min(1, o5).regex(t3, o5) : external_exports.string().optional().refine((i5) => !i5 || t3.test(i5), { message: o5 });
  let a4 = (i5) => {
    let n4 = external_exports.string().url().safeParse(i5).success, d2 = i5.startsWith("http://") || i5.startsWith("https://");
    return n4 && d2;
  };
  return e2 ? external_exports.string().min(1, o5).refine(a4, { message: o5 }) : external_exports.string().optional().refine((i5) => !i5 || a4(i5), { message: o5 });
};
var G = /^(?:https?:\/\/)?(?:[\w-]+\.)*[\w-]+(?:\.\w{2,})?(?::\d{1,5})?(?:\/[\w\-./?%&=]*)?$/i;
var K = (A = {}) => {
  let { required: e2 = true, regex: t3, errorMessage: r5 } = A, o5 = r5 || "Please enter a valid domain (e.g., example.com or https://example.com)";
  return t3 ? e2 ? external_exports.string().min(1, o5).regex(t3, o5) : external_exports.string().optional().refine((a4) => !a4 || t3.test(a4), { message: o5 }) : e2 ? external_exports.string().min(1, o5).regex(G, o5) : external_exports.string().optional().refine((a4) => !a4 || G.test(a4), { message: o5 });
};
var l3 = { url: { defaultError: "Please enter a valid URL", regex: /^https?:\/\/.+/ }, userIdAttribute: { defaultError: "Please enter a valid user ID attribute", regex: /^[a-zA-Z_][a-zA-Z0-9_]*$/ } };
var g = (A, e2 = {}, t3) => h({ required: e2.required ?? false, regex: e2.regex ?? A.regex ?? void 0, errorMessage: e2.errorMessage ?? t3 ?? A.defaultError, minLength: e2.minLength, maxLength: e2.maxLength });
var yA = (A = {}) => {
  let { name: e2 = {}, displayName: t3 = {}, primaryColor: r5 = {}, logoURL: o5 = {}, backgroundColor: a4 = {} } = A, i5 = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, n4 = "Invalid color format", d2 = r5.regex || i5, p = r5.errorMessage || n4, c = a4.regex || i5, C = a4.errorMessage || n4;
  return external_exports.object({ name: h({ required: true, errorMessage: e2.errorMessage }), display_name: h({ required: t3.required ?? true, regex: t3.regex, errorMessage: t3.errorMessage, minLength: t3.minLength, maxLength: t3.maxLength }), branding: external_exports.object({ logo_url: V({ required: false, regex: o5.regex, errorMessage: o5.errorMessage }), colors: external_exports.object({ primary: external_exports.string().regex(d2, p), page_background: external_exports.string().regex(c, C) }) }) });
};
yA();
var m = { ADFS: "adfs", GOOGLE_APPS: "google-apps", OIDC: "oidc", OKTA: "okta", PINGFEDERATE: "pingfederate", SAMLP: "samlp", WAAD: "waad" };
var J = Object.values(m);
var _ = (A = {}) => {
  let { strategy: e2 = {} } = A;
  return external_exports.object({ strategy: external_exports.enum(J, { required_error: e2.errorMessage || "Please select a provider strategy", invalid_type_error: e2.errorMessage || "Please select a valid provider strategy" }) });
};
var $ = (A = {}) => {
  let { name: e2 = {}, displayName: t3 = {} } = A;
  return external_exports.object({ name: external_exports.string({ required_error: e2.errorMessage || "Please enter a valid provider name" }).min(1, "Provider name is required").regex(e2.regex || /^[a-zA-Z0-9](-[a-zA-Z0-9]|[a-zA-Z0-9])*$/, "The name of the connection. Must start and end with an alphanumeric character and can only contain alphanumeric characters and '-'. Max length 128"), display_name: external_exports.string({ required_error: t3.errorMessage || "Please enter a valid display name" }).min(1, "Display name is required").regex(t3.regex || /.*/, t3.errorMessage || "Please enter a valid display name") });
};
var IA = (A = {}) => {
  let e2 = _(A), t3 = $(A);
  return e2.merge(t3);
};
_();
$();
IA();
var eA = (A = {}) => {
  let { userIdAttribute: e2 = {}, scimEndpointUrl: t3 = {} } = A;
  return external_exports.object({ userIdAttribute: g(l3.userIdAttribute, { ...e2, required: e2.required ?? true }, e2.errorMessage || "User ID attribute is required"), scimEndpointUrl: g(l3.url, { ...t3, required: t3.required ?? false }, t3.errorMessage || "Must be a valid URL").optional() });
};
var kA = (A = {}) => eA(A);
eA();
kA();
var OA = (A, e2, t3) => {
  let r5 = A?.[e2];
  return r5 ? { ...r5, errorMessage: r5.errorMessage || t3 } : { errorMessage: t3 };
};
var hA = (A = {}, e2 = "Please enter a valid domain (e.g., example.com or https://example.com)") => {
  let t3 = OA(A, "domainUrl", e2);
  return external_exports.object({ domain_url: K({ required: true, ...t3 }) });
};
hA();
var tA = (A = { common: {}, light: {}, dark: {} }, e2 = false) => ({ variables: { ...A?.common || {}, ...e2 ? A?.dark || {} : A?.light || {} } });
var Wr = (A = {}, e2 = false) => {
  let t3 = A.variables;
  return { variables: tA(t3, e2).variables, classes: A.classes };
};
function br(A, e2 = "light", t3 = "default") {
  let r5 = e2 === "dark", o5 = document.documentElement;
  o5.dataset.theme = t3, r5 ? o5.classList.add("dark") : o5.classList.remove("dark");
  let { variables: a4 } = tA(A, r5);
  for (let [i5, n4] of Object.entries(a4)) typeof n4 == "string" && o5.style.setProperty(i5, n4);
}
var defaultStyleOverrides = { common: {}, light: {}, dark: {} };
var ThemeContext = React.createContext({
  isDarkMode: false,
  variables: defaultStyleOverrides,
  loader: null
});
var ThemeProvider = ({ themeSettings, children }) => {
  const { variables, loader, mode, theme } = React.useMemo(
    () => ({
      variables: themeSettings?.variables ?? defaultStyleOverrides,
      loader: themeSettings?.loader ?? null,
      mode: themeSettings?.mode,
      theme: themeSettings?.theme
    }),
    [themeSettings]
  );
  React.useEffect(() => {
    br(variables, mode, theme);
  }, [variables, mode, theme]);
  return /* @__PURE__ */ jsx(ThemeContext.Provider, { value: { isDarkMode: mode === "dark", variables, loader }, children });
};

// src/hooks/use-theme.ts
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}
var Toaster3 = ({ ...props }) => {
  const { isDarkMode } = useTheme();
  const theme = isDarkMode ? "dark" : "light";
  return /* @__PURE__ */ jsx(Toaster, { theme, className: "toaster group", ...props });
};

// ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r3(e2) {
  var t3, f, n4 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n4 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o5 = e2.length;
    for (t3 = 0; t3 < o5; t3++) e2[t3] && (f = r3(e2[t3])) && (n4 && (n4 += " "), n4 += f);
  } else for (f in e2) e2[f] && (n4 && (n4 += " "), n4 += f);
  return n4;
}
function clsx() {
  for (var e2, t3, f = 0, n4 = "", o5 = arguments.length; f < o5; f++) (e2 = arguments[f]) && (t3 = r3(e2)) && (n4 && (n4 += " "), n4 += t3);
  return n4;
}

// ../../node_modules/.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx;
var cva = (base, config2) => (props) => {
  var _config_compoundVariants;
  if ((config2 === null || config2 === void 0 ? void 0 : config2.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config2;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config2 === null || config2 === void 0 ? void 0 : (_config_compoundVariants = config2.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};

// ../../node_modules/.pnpm/tailwind-merge@3.4.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs
var concatArrays = (array1, array2) => {
  const combinedArray = new Array(array1.length + array2.length);
  for (let i5 = 0; i5 < array1.length; i5++) {
    combinedArray[i5] = array1[i5];
  }
  for (let i5 = 0; i5 < array2.length; i5++) {
    combinedArray[array1.length + i5] = array2[i5];
  }
  return combinedArray;
};
var createClassValidatorObject = (classGroupId, validator) => ({
  classGroupId,
  validator
});
var createClassPartObject = (nextPart = /* @__PURE__ */ new Map(), validators = null, classGroupId) => ({
  nextPart,
  validators,
  classGroupId
});
var CLASS_PART_SEPARATOR = "-";
var EMPTY_CONFLICTS = [];
var ARBITRARY_PROPERTY_PREFIX = "arbitrary..";
var createClassGroupUtils = (config2) => {
  const classMap = createClassMap(config2);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config2;
  const getClassGroupId = (className) => {
    if (className.startsWith("[") && className.endsWith("]")) {
      return getGroupIdForArbitraryProperty(className);
    }
    const classParts = className.split(CLASS_PART_SEPARATOR);
    const startIndex = classParts[0] === "" && classParts.length > 1 ? 1 : 0;
    return getGroupRecursive(classParts, startIndex, classMap);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    if (hasPostfixModifier) {
      const modifierConflicts = conflictingClassGroupModifiers[classGroupId];
      const baseConflicts = conflictingClassGroups[classGroupId];
      if (modifierConflicts) {
        if (baseConflicts) {
          return concatArrays(baseConflicts, modifierConflicts);
        }
        return modifierConflicts;
      }
      return baseConflicts || EMPTY_CONFLICTS;
    }
    return conflictingClassGroups[classGroupId] || EMPTY_CONFLICTS;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, startIndex, classPartObject) => {
  const classPathsLength = classParts.length - startIndex;
  if (classPathsLength === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[startIndex];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  if (nextClassPartObject) {
    const result = getGroupRecursive(classParts, startIndex + 1, nextClassPartObject);
    if (result) return result;
  }
  const validators = classPartObject.validators;
  if (validators === null) {
    return void 0;
  }
  const classRest = startIndex === 0 ? classParts.join(CLASS_PART_SEPARATOR) : classParts.slice(startIndex).join(CLASS_PART_SEPARATOR);
  const validatorsLength = validators.length;
  for (let i5 = 0; i5 < validatorsLength; i5++) {
    const validatorObj = validators[i5];
    if (validatorObj.validator(classRest)) {
      return validatorObj.classGroupId;
    }
  }
  return void 0;
};
var getGroupIdForArbitraryProperty = (className) => className.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const content = className.slice(1, -1);
  const colonIndex = content.indexOf(":");
  const property = content.slice(0, colonIndex);
  return property ? ARBITRARY_PROPERTY_PREFIX + property : void 0;
})();
var createClassMap = (config2) => {
  const {
    theme,
    classGroups
  } = config2;
  return processClassGroups(classGroups, theme);
};
var processClassGroups = (classGroups, theme) => {
  const classMap = createClassPartObject();
  for (const classGroupId in classGroups) {
    const group = classGroups[classGroupId];
    processClassesRecursively(group, classMap, classGroupId, theme);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  const len = classGroup.length;
  for (let i5 = 0; i5 < len; i5++) {
    const classDefinition = classGroup[i5];
    processClassDefinition(classDefinition, classPartObject, classGroupId, theme);
  }
};
var processClassDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  if (typeof classDefinition === "string") {
    processStringDefinition(classDefinition, classPartObject, classGroupId);
    return;
  }
  if (typeof classDefinition === "function") {
    processFunctionDefinition(classDefinition, classPartObject, classGroupId, theme);
    return;
  }
  processObjectDefinition(classDefinition, classPartObject, classGroupId, theme);
};
var processStringDefinition = (classDefinition, classPartObject, classGroupId) => {
  const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
  classPartObjectToEdit.classGroupId = classGroupId;
};
var processFunctionDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  if (isThemeGetter(classDefinition)) {
    processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
    return;
  }
  if (classPartObject.validators === null) {
    classPartObject.validators = [];
  }
  classPartObject.validators.push(createClassValidatorObject(classGroupId, classDefinition));
};
var processObjectDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  const entries = Object.entries(classDefinition);
  const len = entries.length;
  for (let i5 = 0; i5 < len; i5++) {
    const [key, value] = entries[i5];
    processClassesRecursively(value, getPart(classPartObject, key), classGroupId, theme);
  }
};
var getPart = (classPartObject, path) => {
  let current = classPartObject;
  const parts = path.split(CLASS_PART_SEPARATOR);
  const len = parts.length;
  for (let i5 = 0; i5 < len; i5++) {
    const part = parts[i5];
    let next = current.nextPart.get(part);
    if (!next) {
      next = createClassPartObject();
      current.nextPart.set(part, next);
    }
    current = next;
  }
  return current;
};
var isThemeGetter = (func) => "isThemeGetter" in func && func.isThemeGetter === true;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ Object.create(null);
  let previousCache = /* @__PURE__ */ Object.create(null);
  const update = (key, value) => {
    cache[key] = value;
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ Object.create(null);
    }
  };
  return {
    get(key) {
      let value = cache[key];
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache[key]) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (key in cache) {
        cache[key] = value;
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var EMPTY_MODIFIERS = [];
var createResultObject = (modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition, isExternal) => ({
  modifiers,
  hasImportantModifier,
  baseClassName,
  maybePostfixModifierPosition,
  isExternal
});
var createParseClassName = (config2) => {
  const {
    prefix,
    experimentalParseClassName
  } = config2;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    const len = className.length;
    for (let index2 = 0; index2 < len; index2++) {
      const currentCharacter = className[index2];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + 1;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") bracketDepth++;
      else if (currentCharacter === "]") bracketDepth--;
      else if (currentCharacter === "(") parenDepth++;
      else if (currentCharacter === ")") parenDepth--;
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.slice(modifierStart);
    let baseClassName = baseClassNameWithImportantModifier;
    let hasImportantModifier = false;
    if (baseClassNameWithImportantModifier.endsWith(IMPORTANT_MODIFIER)) {
      baseClassName = baseClassNameWithImportantModifier.slice(0, -1);
      hasImportantModifier = true;
    } else if (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)
    ) {
      baseClassName = baseClassNameWithImportantModifier.slice(1);
      hasImportantModifier = true;
    }
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return createResultObject(modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition);
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.slice(fullPrefix.length)) : createResultObject(EMPTY_MODIFIERS, false, className, void 0, true);
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var createSortModifiers = (config2) => {
  const modifierWeights = /* @__PURE__ */ new Map();
  config2.orderSensitiveModifiers.forEach((mod, index2) => {
    modifierWeights.set(mod, 1e6 + index2);
  });
  return (modifiers) => {
    const result = [];
    let currentSegment = [];
    for (let i5 = 0; i5 < modifiers.length; i5++) {
      const modifier = modifiers[i5];
      const isArbitrary = modifier[0] === "[";
      const isOrderSensitive = modifierWeights.has(modifier);
      if (isArbitrary || isOrderSensitive) {
        if (currentSegment.length > 0) {
          currentSegment.sort();
          result.push(...currentSegment);
          currentSegment = [];
        }
        result.push(modifier);
      } else {
        currentSegment.push(modifier);
      }
    }
    if (currentSegment.length > 0) {
      currentSegment.sort();
      result.push(...currentSegment);
    }
    return result;
  };
};
var createConfigUtils = (config2) => ({
  cache: createLruCache(config2.cacheSize),
  parseClassName: createParseClassName(config2),
  sortModifiers: createSortModifiers(config2),
  ...createClassGroupUtils(config2)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = modifiers.length === 0 ? "" : modifiers.length === 1 ? modifiers[0] : sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.indexOf(classId) > -1) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i5 = 0; i5 < conflictGroups.length; ++i5) {
      const group = conflictGroups[i5];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
var twJoin = (...classLists) => {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < classLists.length) {
    if (argument = classLists[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
var createTailwindMerge = (createConfigFirst, ...createConfigRest) => {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall;
  const initTailwindMerge = (classList) => {
    const config2 = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config2);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  };
  const tailwindMerge = (classList) => {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  };
  functionToCall = initTailwindMerge;
  return (...args) => functionToCall(twJoin(...args));
};
var fallbackThemeArr = [];
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || fallbackThemeArr;
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber = (value) => !!value && !Number.isNaN(Number(value));
var isInteger = (value) => !!value && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position" || label === "percentage";
var isLabelImage = (label) => label === "image" || label === "url";
var isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: scaleBgSize()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: scaleColor()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: scaleBgSize()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// src/lib/theme-utils.ts
function cn2(...inputs) {
  return twMerge(clsx(inputs));
}
var spinnerVariants = cva(
  "inline-block h-8 w-8 animate-spin rounded-full border-2 border-transparent",
  {
    variants: {
      variant: {
        solid: "!border-t-current",
        dots: "animate-[spin_5s_linear_infinite] border-6 border-dotted border-current",
        pulse: "animate-pulse bg-current"
      },
      size: {
        sm: "size-4",
        md: "size-8",
        lg: "size-12"
      },
      colorScheme: {
        primary: "text-primary",
        foreground: "text-primary-foreground",
        muted: "text-muted-foreground"
      }
    },
    defaultVariants: {
      variant: "solid",
      size: "md",
      colorScheme: "primary"
    }
  }
);
function Spinner({ variant, size: size4, colorScheme, className, ...props }) {
  return /* @__PURE__ */ jsx("div", { className: cn2(spinnerVariants({ variant, size: size4, colorScheme }), className), ...props, children: /* @__PURE__ */ jsx("span", { className: "sr-only", children: "Loading..." }) });
}
var CoreClientContext = React.createContext({
  coreClient: null
});
var useCoreClient = () => {
  const context = React.useContext(CoreClientContext);
  if (!context) {
    throw new Error("useCoreClient must be used within Auth0ComponentProvider");
  }
  return context;
};
var useCoreClientInitialization = ({
  authDetails,
  i18nOptions
}) => {
  const [coreClient, setCoreClient] = React.useState(null);
  const { domain, authProxyUrl } = authDetails;
  React.useEffect(() => {
    const initializeCoreClient = async () => {
      try {
        const initializedCoreClient = await uA(authDetails, i18nOptions);
        setCoreClient(initializedCoreClient);
      } catch (error) {
        console.error(error);
      }
    };
    initializeCoreClient();
  }, [domain, authProxyUrl, i18nOptions]);
  return coreClient;
};
var ScopeManagerContext = createContext({
  registerScopes: () => {
  },
  isReady: false,
  ensured: { me: "", "my-org": "" }
});
var ScopeManagerProvider = ({ children }) => {
  const { coreClient } = useCoreClient();
  const [scopeRegistry, setScopeRegistry] = useState(() => ({
    me: /* @__PURE__ */ new Set(),
    "my-org": /* @__PURE__ */ new Set()
  }));
  const [ensured, setEnsured] = useState({
    me: "",
    "my-org": ""
  });
  const [isReady, setIsReady] = useState(false);
  const registerScopes = useCallback((audience, scopes) => {
    if (!scopes?.trim()) return;
    const newScopes = scopes.split(/\s+/).map((s3) => s3.trim()).filter(Boolean);
    if (newScopes.length === 0) return;
    setScopeRegistry((currentRegistry) => {
      const audienceSet = currentRegistry[audience];
      let changed = false;
      const nextAudienceSet = new Set(audienceSet);
      newScopes.forEach((scope) => {
        if (!nextAudienceSet.has(scope)) {
          nextAudienceSet.add(scope);
          changed = true;
        }
      });
      if (changed) {
        return {
          ...currentRegistry,
          [audience]: nextAudienceSet
        };
      }
      return currentRegistry;
    });
  }, []);
  useEffect(() => {
    if (!coreClient) return;
    const ensureAllScopesSequential = async () => {
      let hasScopes = false;
      let anyUpdated = false;
      for (const audience of ["me", "my-org"]) {
        const scopes = Array.from(scopeRegistry[audience]).sort();
        const scopeString = scopes.join(" ");
        if (scopes.length > 0 && scopeString.trim()) {
          hasScopes = true;
          if (scopeString !== ensured[audience]) {
            try {
              await coreClient.ensureScopes(scopeString, audience);
              anyUpdated = true;
            } catch (error) {
              console.error(`Failed to ensure scopes for ${audience}: ${scopeString}`, error);
            }
          }
        }
      }
      if (anyUpdated) {
        setEnsured({
          me: Array.from(scopeRegistry.me).sort().join(" "),
          "my-org": Array.from(scopeRegistry["my-org"]).sort().join(" ")
        });
      }
      setIsReady(hasScopes);
    };
    ensureAllScopesSequential();
  }, [coreClient, scopeRegistry, ensured]);
  const contextValue = React__default.useMemo(
    () => ({ registerScopes, isReady, ensured }),
    [registerScopes, isReady, ensured]
  );
  return /* @__PURE__ */ jsx(ScopeManagerContext.Provider, { value: contextValue, children });
};
var Auth0ComponentProvider = ({
  i18n,
  authDetails,
  themeSettings = {
    theme: "default",
    mode: "light",
    variables: {
      common: {},
      light: {},
      dark: {}
    }
  },
  loader,
  children
}) => {
  const memoizedAuthDetails = React.useMemo(
    () => ({
      ...authDetails,
      contextInterface: void 0
    }),
    [authDetails]
  );
  const coreClient = useCoreClientInitialization({
    authDetails: memoizedAuthDetails,
    i18nOptions: i18n
  });
  const coreClientValue = React.useMemo(
    () => ({
      coreClient
    }),
    [coreClient]
  );
  return /* @__PURE__ */ jsxs(
    ThemeProvider,
    {
      themeSettings: {
        mode: themeSettings.mode,
        variables: themeSettings.variables,
        loader,
        theme: themeSettings.theme
      },
      children: [
        /* @__PURE__ */ jsx(Toaster3, { position: "top-right" }),
        /* @__PURE__ */ jsx(
          React.Suspense,
          {
            fallback: loader || /* @__PURE__ */ jsx("div", { className: "flex items-center justify-center min-h-[200px]", children: /* @__PURE__ */ jsx(Spinner, {}) }),
            children: /* @__PURE__ */ jsx(CoreClientContext.Provider, { value: coreClientValue, children: /* @__PURE__ */ jsx(ScopeManagerProvider, { children }) })
          }
        )
      ]
    }
  );
};
function useTranslator(namespace, overrides) {
  const { coreClient } = useCoreClient();
  if (!coreClient) {
    throw new Error(
      "useTranslator must be used within Auth0ComponentProvider with initialized CoreClient"
    );
  }
  const translator = useMemo(() => {
    return coreClient.i18nService.translator(namespace, overrides);
  }, [coreClient, namespace, overrides]);
  const changeLanguage = useCallback(
    async (language, fallbackLanguage) => {
      await coreClient.i18nService.changeLanguage(language, fallbackLanguage);
    },
    [coreClient]
  );
  return {
    t: translator,
    changeLanguage,
    currentLanguage: coreClient.i18nService.currentLanguage,
    fallbackLanguage: coreClient.i18nService.fallbackLanguage
  };
}

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
var toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
var mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
var hasA11yProp = (props) => {
  for (const prop in props) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/Icon.js
var Icon = forwardRef(
  ({
    color = "currentColor",
    size: size4 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => createElement(
    "svg",
    {
      ref,
      ...defaultAttributes,
      width: size4,
      height: size4,
      stroke: color,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size4) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef(
    ({ className, ...props }, ref) => createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  Component.displayName = toPascalCase(iconName);
  return Component;
};

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/arrow-left.js
var __iconNode = [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
];
var ArrowLeft = createLucideIcon("arrow-left", __iconNode);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/chevron-down.js
var __iconNode2 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
var ChevronDown = createLucideIcon("chevron-down", __iconNode2);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/chevron-up.js
var __iconNode3 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]];
var ChevronUp = createLucideIcon("chevron-up", __iconNode3);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/copy.js
var __iconNode4 = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
];
var Copy = createLucideIcon("copy", __iconNode4);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/ellipsis.js
var __iconNode5 = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
];
var Ellipsis = createLucideIcon("ellipsis", __iconNode5);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/eye.js
var __iconNode6 = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
];
var Eye = createLucideIcon("eye", __iconNode6);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/message-square.js
var __iconNode7 = [
  ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]
];
var MessageSquare = createLucideIcon("message-square", __iconNode7);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/pencil-line.js
var __iconNode8 = [
  ["path", { d: "M12 20h9", key: "t2du7b" }],
  [
    "path",
    {
      d: "M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z",
      key: "1ykcvy"
    }
  ],
  ["path", { d: "m15 5 3 3", key: "1w25hb" }]
];
var PencilLine = createLucideIcon("pencil-line", __iconNode8);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/plus.js
var __iconNode9 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
];
var Plus = createLucideIcon("plus", __iconNode9);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/refresh-ccw.js
var __iconNode10 = [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
];
var RefreshCcw = createLucideIcon("refresh-ccw", __iconNode10);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/trash-2.js
var __iconNode11 = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
];
var Trash2 = createLucideIcon("trash-2", __iconNode11);

// ../../node_modules/.pnpm/lucide-react@0.511.0_react@19.2.1/node_modules/lucide-react/dist/esm/icons/x.js
var __iconNode12 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
];
var X = createLucideIcon("x", __iconNode12);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i5 = 0; i5 < cleanups.length; i5++) {
          const cleanup = cleanups[i5];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i5], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = React[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot22 = React.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    const childrenArray = React.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React.Children.count(newElement) > 1) return React.Children.only(null);
          return React.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = React.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    if (React.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React.cloneElement(children, props2);
    }
    return React.Children.count(children) > 1 ? React.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
  return React.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var buttonVariants = cva(
  "focus-visible:ring-ring aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive theme-default:active:scale-[0.99] relative box-border inline-flex shrink-0 items-center justify-center gap-2 overflow-hidden text-sm font-medium whitespace-nowrap transition-all duration-150 ease-in-out outline-none focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  {
    variants: {
      variant: {
        primary: "shadow-button-resting hover:shadow-button-hover hover:border-primary/50 border-primary bg-primary text-primary-foreground hover:bg-primary/90 theme-default:before:from-primary-foreground/0 theme-default:before:to-primary-foreground/15 theme-default:before:absolute theme-default:before:top-0 theme-default:before:left-0 theme-default:before:block theme-default:before:h-full theme-default:before:w-full theme-default:before:bg-gradient-to-t theme-default:before:content-[''] border",
        outline: "dark:bg-muted/50 hover:text-accent-foreground shadow-button-outlined-resting hover:shadow-button-outlined-hover hover:border-accent bg-background hover:bg-muted text-primary border-primary/35 theme-default:before:from-primary/5 theme-default:before:to-primary/0 theme-default:before:absolute theme-default:before:top-0 theme-default:before:left-0 theme-default:before:block theme-default:before:h-full theme-default:before:w-full theme-default:before:bg-gradient-to-t theme-default:before:content-[''] border",
        ghost: "hover:bg-muted text-primary bg-transparent",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90 shadow-button-destructive-resting hover:shadow-button-destructive-hover border-destructive-border/25 hover:border-destructive-border/50 theme-default:before:to-primary-foreground/50 theme-default:before:absolute theme-default:before:top-0 theme-default:before:left-0 theme-default:before:block theme-default:before:h-full theme-default:before:w-full theme-default:before:bg-gradient-to-t theme-default:before:content-[''] theme-default:border",
        link: "text-foreground underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 rounded-2xl px-4 py-2.5 has-[>svg]:px-3",
        xs: "h-7 rounded-md px-2 py-1.5 text-xs has-[>svg]:px-2",
        sm: "h-8 gap-1.5 rounded-xl px-3 py-2 text-xs has-[>svg]:px-2.5",
        lg: "h-12 rounded-3xl px-6 py-3 text-base has-[>svg]:px-4",
        icon: "size-7 rounded-xl"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "default"
    }
  }
);
function Button({
  className,
  variant,
  size: size4,
  as,
  ...props
}) {
  const Comp = as ? Slot : "button";
  return /* @__PURE__ */ jsx(Comp, { className: cn2(buttonVariants({ variant, size: size4 }), className), ...props });
}

// ../../node_modules/.pnpm/@tanstack+table-core@8.21.3/node_modules/@tanstack/table-core/build/lib/index.mjs
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d2) {
  return d2 instanceof Function;
}
function isNumberArray(d2) {
  return Array.isArray(d2) && d2.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index2) => deps[index2] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c\u23F1 ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: process.env.NODE_ENV === "development" && key,
    onChange
  };
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells", "cell.getContext"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (process.env.NODE_ENV !== "production" && result === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (process.env.NODE_ENV !== "production") {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d2) => d2.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
var debug = "debugHeaders";
function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h2) => {
        if (h2.subHeaders && h2.subHeaders.length) {
          h2.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h2);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
var Headers4 = {
  createTable: (table) => {
    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, "getHeaderGroups"));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
    table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getFooterGroups"));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getRightFooterGroups"));
    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getFlatHeaders"));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d2) => d2.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index2) => createHeader(table, column, {
    depth: maxDepth,
    index: index2
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
var createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => flattenBy(row.subRows, (d2) => d2.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let i5 = 0; i5 < table._features.length; i5++) {
    const feature = table._features[i5];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
var ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return void 0;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min3, max3] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min3 && rowValue <= max3;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min3 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max3 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min3 > max3) {
    const temp = min3;
    min3 = max3;
    max3 = temp;
  }
  return [min3, max3];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
var ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
      );
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d2) => d2.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find((d2) => d2.id === column.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d2) => d2.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d2) => {
            if (d2.id === column.id) {
              return newFilterObj;
            }
            return d2;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
          const column = leafColumns.find((d2) => d2.id === filter.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min = (columnId, _leafRows, childRows) => {
  let min3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
      min3 = value;
    }
  });
  return min3;
};
var max = (columnId, _leafRows, childRows) => {
  let max3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
      max3 = value;
    }
  });
  return max3;
};
var extent = (columnId, _leafRows, childRows) => {
  let min3;
  let max3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min3 === void 0) {
        if (value >= value) min3 = max3 = value;
      } else {
        if (min3 > value) min3 = value;
        if (max3 < value) max3 = value;
      }
    }
  });
  return [min3, max3];
};
var mean = (columnId, leafRows) => {
  let count4 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count4, sum2 += value;
    }
  });
  if (count4) return sum2 / count4;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a4, b2) => a4 - b2);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d2) => d2.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d2) => d2.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
var ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d2) => d2 !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup) return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g2) => leafColumns.find((col) => col.id === g2)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var ColumnOrdering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo((position) => [_getVisibleLeafColumns(table, position)], (columns) => columns.findIndex((d2) => d2.id === column.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
    column.getIsFirstColumn = (position) => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = (position) => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d2) => d2.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
  }
};
var getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
var ColumnPinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position) => {
      const columnIds = column.getLeafColumns().map((d2) => d2.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds]
          };
        }
        if (position === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d2) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d2.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d2) => d2.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d2) => left == null ? void 0 : left.includes(d2));
      const isRight = leafColumnIds.some((d2) => right == null ? void 0 : right.includes(d2));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allCells.filter((d2) => !leftAndRight.includes(d2.column.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
      const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allColumns.filter((d2) => !leftAndRight.includes(d2.id));
    }, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
  }
};
function safelyAccessDocument(_document) {
  return _document || (typeof document !== "undefined" ? document : null);
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
    column.getAfter = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _2,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return (e2) => {
        if (!column || !canResize) {
          return;
        }
        e2.persist == null || e2.persist();
        if (isTouchStartEvent(e2)) {
          if (e2.touches && e2.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d2) => [d2.column.id, d2.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e2) ? Math.round(e2.touches[0].clientX) : e2.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = safelyAccessDocument(_contextDocument);
        const mouseEvents = {
          moveHandler: (e3) => onMove(e3.clientX),
          upHandler: (e3) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e3.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e3) => {
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onMove(e3.touches[0].clientX);
            return false;
          },
          upHandler: (e3) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onEnd((_e$touches$ = e3.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e2)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
var passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean") return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop3 = () => {
    };
    window.addEventListener("test", noop3, options);
    window.removeEventListener("test", noop3);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e2) {
  return e2.type === "touchstart";
}
var ColumnVisibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some((c) => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e2) => {
        column.toggleVisibility == null || column.toggleVisibility(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d2) => d2.getIsVisible()).map((d2) => d2.id).join("_")], (columns) => {
        return columns.filter((d2) => d2.getIsVisible == null ? void 0 : d2.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns", key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e2) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e2.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
var GlobalFaceting = {
  createTable: (table) => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
var GlobalFiltering = {
  getInitialState: (state) => {
    return {
      globalFilter: void 0,
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
  }
};
var RowExpanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e2) => {
        e2.persist == null || e2.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id) => {
        const splitId = id.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _2,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var RowPagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_2, i5) => i5);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable", "getPageOptions"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};
var getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
var RowPinning = {
  getInitialState: (state) => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
        let {
          id
        } = _ref;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)]
          };
        }
        if (position === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d2) => top == null ? void 0 : top.includes(d2));
      const isBottom = rowIds.some((d2) => bottom == null ? void 0 : bottom.includes(d2));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position) return -1;
      const visiblePinnedRowIds = (_ref4 = position === "top" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5) => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: (table) => {
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d2) => ({
        ...d2,
        position
      }));
    };
    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows", "getTopRows"));
    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows", "getBottomRows"));
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d2) => !topAndBottom.has(d2.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterRows"));
  }
};
var RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d2) => d2.getIsSelected() || d2.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllRowsSelected(e2.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllPageRowsSelected(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e2) => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e2.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a4 = rowA.getValue(columnId);
  const b2 = rowB.getValue(columnId);
  return a4 > b2 ? 1 : a4 < b2 ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a4, b2) {
  return a4 === b2 ? 0 : a4 > b2 ? 1 : -1;
}
function toString(a4) {
  if (typeof a4 === "number") {
    if (isNaN(a4) || a4 === Infinity || a4 === -Infinity) {
      return "";
    }
    return String(a4);
  }
  if (typeof a4 === "string") {
    return a4;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a4 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b2 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a4.length && b2.length) {
    const aa = a4.shift();
    const bb = b2.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a4.length - b2.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var RowSorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e2) => {
        return e2.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d2) => d2.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d2) => d2.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d2) => {
            if (d2.id === column.id) {
              return {
                ...d2,
                desc: nextDesc
              };
            }
            return d2;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d2) => d2.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d2) => d2.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d2) => d2.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e2) => {
        if (!canSort) return;
        e2.persist == null || e2.persist();
        column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e2) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
var builtInFeatures = [
  Headers4,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  //depends on ColumnFaceting
  GlobalFiltering,
  //depends on ColumnFiltering
  RowSorting,
  ColumnGrouping,
  //depends on RowSorting
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(options) {
  var _options$_features, _options$initialState;
  if (process.env.NODE_ENV !== "production" && (options.debugAll || options.debugTable)) {
    console.info("Creating Table Instance...");
  }
  const _features = [...builtInFeatures, ...(_options$_features = options._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index2, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index2, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index2].join(".") : index2}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          if (process.env.NODE_ENV !== "production") {
            throw new Error(`getRow could not find row with ID: ${id}`);
          }
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns", "getAllLeafColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (process.env.NODE_ENV !== "production" && !column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index2 = 0; index2 < table._features.length; index2++) {
    const feature = table._features[index2];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i5 = 0; i5 < originalRows.length; i5++) {
        const row = createRow(table, table._getRowId(originalRows[i5], i5, parentRow), originalRows[i5], i5, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i5], i5);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      if (!column) return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = rows.map((row) => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i5 = 0; i5 < availableSorting.length; i5 += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i5];
          const columnInfo = columnInfoById[sortEntry.id];
          const sortUndefined = columnInfo.sortUndefined;
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;
          if (sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === void 0;
            const bUndefined = bValue === void 0;
            if (aUndefined || bUndefined) {
              if (sortUndefined === "first") return aUndefined ? -1 : 1;
              if (sortUndefined === "last") return aUndefined ? 1 : -1;
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, getMemoOptions(table.options, "debugTable", "getSortedRowModel", () => table._autoResetPageIndex()));
}

// ../../node_modules/.pnpm/@tanstack+react-table@8.21.3_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@tanstack/react-table/build/lib/index.mjs
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /* @__PURE__ */ React.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = React.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}
var badgeVariants = cva(
  "theme-default:shadow-xs box-border inline-flex items-center overflow-clip rounded-2xl border border-transparent font-medium",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground theme-default:border-primary",
        secondary: "bg-muted text-muted-foreground theme-default:border-muted-foreground/25",
        outline: "border-border",
        info: "bg-info text-info-foreground theme-default:border-info-foreground/25",
        success: "bg-success theme-default:border-success-foreground/25 text-success-foreground",
        warning: "bg-warning theme-default:border-warning-foreground/25 text-warning-foreground",
        destructive: "bg-destructive theme-default:border-destructive-foreground/25 text-destructive-foreground"
      },
      size: {
        sm: "px-1.5 py-0.5 text-xs",
        md: "px-2 py-1 text-sm",
        lg: "px-2.5 py-1.5 text-sm"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md"
    }
  }
);
function Badge({
  className,
  variant,
  size: size4,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "span";
  return /* @__PURE__ */ jsx(
    Comp,
    {
      "data-slot": "badge",
      className: cn2(badgeVariants({ variant, size: size4 }), className),
      ...props
    }
  );
}
function InlineCode({ children, className }) {
  return /* @__PURE__ */ jsx(
    "code",
    {
      className: cn2(
        "bg-background theme-default:shadow-input-resting theme-default:bg-secondary shadow-bevel-xs relative rounded-lg px-[0.35rem] py-[0.2rem] font-mono text-sm font-medium tracking-tight",
        className
      ),
      children
    }
  );
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function createContext22(rootComponentName, defaultContext) {
  const Context = React.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = React.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsx(Context.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsx(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var useLayoutEffect2 = globalThis?.document ? React.useLayoutEffect : () => {
};
var useInsertionEffect = React[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = React.useRef(prop !== void 0);
    React.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction2(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React.useState(defaultProp);
  const prevValueRef = React.useRef(value);
  const onChangeRef = React.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction2(value) {
  return typeof value === "function";
}
function usePrevious(value) {
  const ref = React.useRef({ value, previous: value });
  return React.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
function useSize(element) {
  const [size4, setSize] = React.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}
// @__NO_SIDE_EFFECTS__
function createSlot2(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone2(ownerName);
  const Slot22 = React.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React.Children.count(newElement) > 1) return React.Children.only(null);
          return React.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone2(ownerName) {
  const SlotClone = React.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React.isValidElement(children)) {
      const childrenRef = getElementRef2(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React.cloneElement(children, props2);
    }
    return React.Children.count(children) > 1 ? React.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsx(Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER2;
  return Slottable2;
}
function isSlottable2(child) {
  return React.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot4 = createSlot2(`Primitive.${node}`);
  const Node2 = React.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot4 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}
var SWITCH_NAME = "Switch";
var [createSwitchContext] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return /* @__PURE__ */ jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsx(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsx(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsx(
      Primitive.span,
      {
        "data-state": getState(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BUBBLE_INPUT_NAME = "SwitchBubbleInput";
var SwitchBubbleInput = React.forwardRef(
  ({
    __scopeSwitch,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME;
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
var Root = Switch;
var Thumb = SwitchThumb;
function Switch2({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    Root,
    {
      "data-slot": "switch",
      className: cn2(
        "theme-default:shadow-switch-resting data-[state=checked]:from-primary-foreground/0 data-[state=checked]:to-primary-foreground/25 from-primary-foreground/50 to-primary-foreground/0 bg-accent/50 hover:bg-accent/75 data-[state=checked]:hover:bg-primary theme-default:hover:shadow-switch-hover data-[state=checked]:bg-primary focus-visible:ring-ring focus-within:ring-ring relative h-7 w-[46px] rounded-full bg-gradient-to-l transition-all duration-150 ease-in-out focus-visible:ring-4 active:scale-95 disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx(
        Thumb,
        {
          "data-slot": "switch-thumb",
          className: cn2(
            "dark:bg-primary dark:shadow-switch-thumb-dark data-[state=checked]:dark:bg-background bg-background to-background/0 from-primary/5 shadow-switch-thumb data-[state=checked]:bg-background pointer-events-none absolute top-[4px] left-[4px] h-5 w-5 rounded-full bg-gradient-to-t transition-transform duration-150 ease-in-out data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
var Table = React__default.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx("div", { className: "shadow-bevel-sm w-full overflow-clip rounded-2xl", children: /* @__PURE__ */ jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsx("table", { ref, className: cn2("w-full border-collapse table-fixed", className), ...props }) }) }));
Table.displayName = "Table";
var TableHeader = React__default.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx("thead", { ref, className: cn2("bg-muted text-primary text-sm", className), ...props }));
TableHeader.displayName = "TableHeader";
var TableBody = React__default.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx("tbody", { ref, className: cn2("[&_tr:last-child]:border-0", className), ...props }));
TableBody.displayName = "TableBody";
var TableRow = React__default.forwardRef(
  ({ className, disableHover, ...props }, ref) => /* @__PURE__ */ jsx(
    "tr",
    {
      ref,
      className: cn2(
        !disableHover && "hover:bg-muted/50",
        "border-border/50 border-b text-sm transition-colors",
        className
      ),
      ...props
    }
  )
);
TableRow.displayName = "TableRow";
var TableHead = React__default.forwardRef(
  ({ className, children, isSortable, sortDirection, ...props }, ref) => {
    const showSortIcon = isSortable !== void 0 && sortDirection !== void 0;
    return /* @__PURE__ */ jsx(
      "th",
      {
        ref,
        className: cn2(
          "hover:bg-accent/10 border-border/50 border-b px-4 py-2 text-left",
          isSortable && "group cursor-pointer select-none",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-1", children: [
          children,
          showSortIcon && /* @__PURE__ */ jsxs("div", { className: "ml-2 flex items-center", children: [
            sortDirection === false && /* @__PURE__ */ jsx(ChevronDown, { className: "text-muted-foreground h-4 w-4 opacity-0 transition-opacity duration-200 group-hover:opacity-100" }),
            sortDirection === "asc" && /* @__PURE__ */ jsx(ChevronUp, { className: "h-4 w-4" }),
            sortDirection === "desc" && /* @__PURE__ */ jsx(ChevronDown, { className: "h-4 w-4" })
          ] })
        ] })
      }
    );
  }
);
TableHead.displayName = "TableHead";
var TableCell = React__default.forwardRef(
  ({ className, ...props }, ref) => /* @__PURE__ */ jsx("td", { ref, className: cn2("px-4 py-2", className), ...props })
);
TableCell.displayName = "TableCell";
function useCallbackRef(callback) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React.useContext(DismissableLayerContext);
    const [node, setNode] = React.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = React.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {
  const context = React.useContext(DismissableLayerContext);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React.useRef(false);
  const handleClickRef = React.useRef(() => {
  });
  React.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React.useRef(false);
  React.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var useReactId = React[" useId ".trim().toString()] || (() => void 0);
var count2 = 0;
function useId(deterministicId) {
  const [id, setId] = React.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count2++));
  }, [deterministicId]);
  return (id ? `radix-${id}` : "");
}

// ../../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}

// ../../node_modules/.pnpm/@floating-ui+core@1.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i5 = 0; i5 < validMiddleware.length; i5++) {
    const {
      name,
      fn
    } = validMiddleware[i5];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i5 = -1;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a4, b2) => a4.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b2) => a4[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../node_modules/.pnpm/@floating-ui+dom@1.7.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a4, b2) {
  return a4.x === b2.x && a4.y === b2.y && a4.width === b2.width && a4.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? useLayoutEffect : noop;
function deepEqual(a4, b2) {
  if (a4 === b2) {
    return true;
  }
  if (typeof a4 !== typeof b2) {
    return false;
  }
  if (typeof a4 === "function" && a4.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i5;
  let keys;
  if (a4 && b2 && typeof a4 === "object") {
    if (Array.isArray(a4)) {
      length = a4.length;
      if (length !== b2.length) return false;
      for (i5 = length; i5-- !== 0; ) {
        if (!deepEqual(a4[i5], b2[i5])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a4);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i5 = length; i5-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i5])) {
        return false;
      }
    }
    for (i5 = length; i5-- !== 0; ) {
      const key = keys[i5];
      if (key === "_owner" && a4.$$typeof) {
        continue;
      }
      if (!deepEqual(a4[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a4 !== a4 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME = "Arrow";
var Arrow = React.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root2 = Arrow;
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React.useState(null);
  return /* @__PURE__ */ jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React.useRef(null);
    React.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : /* @__PURE__ */ jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsx(
          Root2,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;
var PORTAL_NAME = "Portal";
var Portal = React.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM__default.createPortal(/* @__PURE__ */ jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;
function useStateMachine(initialState, machine) {
  return React.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef3(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React.useState();
  const stylesRef = React.useRef(null);
  const prevPresentRef = React.useRef(present);
  const prevAnimationNameRef = React.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef3(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME2 = "VisuallyHidden";
var VisuallyHidden = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME2;
var Root3 = VisuallyHidden;
var [createTooltipContext] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React.useRef(true);
  const isPointerInTransitRef = React.useRef(false);
  const skipDelayTimerRef = React.useRef(0);
  React.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React.useState(null);
  const contentId = useId();
  const openTimerRef = React.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsx(Root22, { ...popperScope, children: /* @__PURE__ */ jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React.useRef(false);
    const hasPointerMoveOpenedRef = React.useRef(false);
    const handlePointerUp = React.useCallback(() => isPointerDownRef.current = false, []);
    React.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME2, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME2, __scopeTooltip);
  return /* @__PURE__ */ jsx(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "TooltipContent";
var TooltipContent = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
    return /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME2, props.__scopeTooltip);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable = createSlottable("TooltipContent");
var TooltipContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxs(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsx(Slottable, { children }),
              /* @__PURE__ */ jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsx(Root3, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME2;
var ARROW_NAME2 = "TooltipArrow";
var TooltipArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME2,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsx(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME2;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y: y2 } = point;
  let inside = false;
  for (let i5 = 0, j = polygon.length - 1; i5 < polygon.length; j = i5++) {
    const ii = polygon[i5];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y2 !== yj > y2 && x < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a4, b2) => {
    if (a4.x < b2.x) return -1;
    else if (a4.x > b2.x) return 1;
    else if (a4.y < b2.y) return -1;
    else if (a4.y > b2.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i5 = 0; i5 < points.length; i5++) {
    const p = points[i5];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r5 = upperHull[upperHull.length - 2];
      if ((q.x - r5.x) * (p.y - r5.y) >= (q.y - r5.y) * (p.x - r5.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i5 = points.length - 1; i5 >= 0; i5--) {
    const p = points[i5];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r5 = lowerHull[lowerHull.length - 2];
      if ((q.x - r5.x) * (p.y - r5.y) >= (q.y - r5.y) * (p.x - r5.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root32 = Tooltip;
var Trigger = TooltipTrigger;
var Portal2 = TooltipPortal;
var Content2 = TooltipContent;
var Arrow22 = TooltipArrow;
var tooltipVariants = cva(
  "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 shadow-bevel-lg z-50 w-fit rounded-xl px-2 py-1 text-sm text-balance",
  {
    variants: {
      position: {
        top: "origin-bottom",
        bottom: "origin-top",
        left: "origin-left",
        right: "origin-right"
      }
    },
    defaultVariants: {
      position: "top"
    }
  }
);
function Tooltip2({ children, ...props }) {
  return /* @__PURE__ */ jsx(Provider, { children: /* @__PURE__ */ jsx(Root32, { ...props, children }) });
}
function TooltipTrigger2({
  asChild = true,
  ...props
}) {
  return /* @__PURE__ */ jsx(Trigger, { asChild, ...props });
}
var TooltipContent2 = React.forwardRef(({ className, side = "top", position, sideOffset = 8, children, ...props }, ref) => {
  return /* @__PURE__ */ jsx(Portal2, { children: /* @__PURE__ */ jsxs(
    Content2,
    {
      ref,
      side,
      sideOffset,
      className: cn2(tooltipVariants({ position: position || side }), className),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx(Arrow22, { className: "fill-popover" })
      ]
    }
  ) });
});
TooltipContent2.displayName = Content2.displayName;
var ALIGNMENT_CLASSES = {
  text: {
    left: "text-left",
    center: "text-center",
    right: "text-right"
  }};
var isEmpty = (value) => {
  return value === null || value === void 0 || value === "";
};
var formatDate = (value, format = "medium") => {
  const date = new Date(value);
  if (isNaN(date.getTime())) return "Invalid Date";
  switch (format) {
    case "short":
      return date.toLocaleDateString();
    case "long":
      return date.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
    case "relative": {
      const now = /* @__PURE__ */ new Date();
      const diffTime = date.getTime() - now.getTime();
      const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      if (Math.abs(diffDays) === 0) return "Today";
      if (diffDays === 1) return "Tomorrow";
      if (diffDays === -1) return "Yesterday";
      if (diffDays > 0) return `In ${diffDays} days`;
      return `${Math.abs(diffDays)} days ago`;
    }
    case "medium":
    default:
      return date.toLocaleDateString(void 0, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
  }
};
var DEFAULT_COPY_LABELS = {
  copyTooltip: "Copy to clipboard",
  copiedTooltip: "Copied!"
};
function CopyButton({
  value,
  labels = DEFAULT_COPY_LABELS
}) {
  const [copied, setCopied] = useState(false);
  const [tooltipOpen, setTooltipOpen] = useState(false);
  const handleCopy = async (e2) => {
    e2.stopPropagation();
    if (!value) return;
    try {
      await navigator.clipboard.writeText(String(value));
      setCopied(true);
      setTooltipOpen(true);
      setTimeout(() => {
        setCopied(false);
        setTooltipOpen(false);
      }, 2e3);
    } catch (error) {
      console.error("Failed to copy text:", error);
    }
  };
  return /* @__PURE__ */ jsxs(InlineCode, { className: "w-full flex items-center justify-between gap-2 pr-1", children: [
    /* @__PURE__ */ jsx("span", { className: "truncate text-muted-foreground", children: String(value) }),
    /* @__PURE__ */ jsxs(Tooltip2, { open: tooltipOpen, onOpenChange: setTooltipOpen, children: [
      /* @__PURE__ */ jsx(TooltipTrigger2, { asChild: true, children: /* @__PURE__ */ jsx(
        Button,
        {
          variant: "ghost",
          size: "sm",
          onClick: handleCopy,
          className: "h-6 w-6 p-0 hover:bg-muted/50 shrink-0",
          "aria-label": copied ? labels.copiedTooltip : labels.copyTooltip,
          children: /* @__PURE__ */ jsx(Copy, { className: "h-3 w-3" })
        }
      ) }),
      /* @__PURE__ */ jsx(TooltipContent2, { children: /* @__PURE__ */ jsx("p", { children: copied ? labels.copiedTooltip : labels.copyTooltip }) })
    ] })
  ] });
}
function renderTextColumn(item, value, column) {
  if (column.render) {
    return column.render(item, value);
  }
  return /* @__PURE__ */ jsx("span", { className: "text-muted-foreground", children: String(value) });
}
function renderDateColumn(item, value, column) {
  if (column.render) {
    return column.render(item, value);
  }
  const formattedDate = formatDate(value, column.format);
  return /* @__PURE__ */ jsx("span", { className: "text-muted-foreground", title: new Date(value).toISOString(), children: formattedDate });
}
function renderSwitchColumn(item, value, column) {
  const handleToggle = (checked) => {
    column.onToggle?.(checked, item);
  };
  return /* @__PURE__ */ jsx("div", { onClick: (e2) => e2.stopPropagation(), children: /* @__PURE__ */ jsx(Switch2, { checked: !!value, onCheckedChange: handleToggle }) });
}
function renderButtonColumn(item, column) {
  const handleClick = (e2) => {
    e2.stopPropagation();
    column.onClick(item);
  };
  return /* @__PURE__ */ jsx(Button, { variant: column.variant, size: "sm", onClick: handleClick, children: column.buttonText });
}
function renderBadgeColumn(value, column) {
  return /* @__PURE__ */ jsx(Badge, { variant: column.variant, children: String(value) });
}
function renderCopyColumn(value) {
  return /* @__PURE__ */ jsx(CopyButton, { value });
}
function EmptyState({ title, subtitle, action }) {
  return /* @__PURE__ */ jsxs("div", { className: "text-center py-12", children: [
    /* @__PURE__ */ jsx("h3", { className: "text-md font-medium text-foreground mb-2", children: title }),
    subtitle && /* @__PURE__ */ jsx("p", { className: "text-sm text-muted-foreground mb-4", children: subtitle }),
    action && /* @__PURE__ */ jsx(Button, { variant: action.variant, onClick: action.onClick, children: action.label })
  ] });
}
function DataTable({
  data,
  columns,
  loading = false,
  loader,
  emptyState,
  onRowClick,
  className,
  headerAlign = "left"
}) {
  const [sorting, setSorting] = useState([]);
  const tableColumns = useMemo(() => {
    return columns.map((column, index2) => {
      return {
        id: `column-${index2}`,
        accessorKey: column.accessorKey,
        header: column.title,
        size: column.width ? isNaN(Number(column.width)) ? void 0 : Number(column.width) : void 0,
        enableSorting: column.enableSorting !== false && !!column.accessorKey,
        meta: {
          headerAlign: column.headerAlign || headerAlign || "left",
          column
        },
        cell: ({ getValue, row }) => {
          const value = getValue();
          const item = row.original;
          if (column.type === "actions") {
            return /* @__PURE__ */ jsx("div", { onClick: (e2) => e2.stopPropagation(), children: column.render(item) });
          }
          if (column.type === "custom") {
            return /* @__PURE__ */ jsx(Fragment, { children: column.render(item, value) });
          }
          if (column.type === "switch") {
            return renderSwitchColumn(item, value, column);
          }
          if (column.type === "button") {
            return renderButtonColumn(item, column);
          }
          if (isEmpty(value)) {
            return null;
          }
          switch (column.type) {
            case "text":
              return renderTextColumn(item, value, column);
            case "date":
              return renderDateColumn(item, value, column);
            case "copy":
              return renderCopyColumn(value);
            case "badge":
              return renderBadgeColumn(value, column);
            default:
              return /* @__PURE__ */ jsx("span", { className: "text-foreground", children: String(value) });
          }
        }
      };
    });
  }, [columns, headerAlign]);
  const table = useReactTable({
    data,
    columns: tableColumns,
    state: {
      sorting
    },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    manualPagination: true
  });
  if (loading) {
    return /* @__PURE__ */ jsx("div", { className: cn2("w-full flex items-center justify-center py-8", className), children: loader || /* @__PURE__ */ jsx(Spinner, {}) });
  }
  return /* @__PURE__ */ jsx("div", { className: cn2("w-full", className), children: /* @__PURE__ */ jsxs(Table, { children: [
    /* @__PURE__ */ jsx(TableHeader, { children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ jsx(TableRow, { children: headerGroup.headers.map((header) => {
      const canSort = header.column.getCanSort();
      const sortDirection = header.column.getIsSorted();
      const meta = header.column.columnDef.meta;
      return /* @__PURE__ */ jsx(
        TableHead,
        {
          className: cn2(
            canSort && "hover:bg-muted/50",
            "transition-colors",
            ALIGNMENT_CLASSES.text[meta.headerAlign]
          ),
          style: {
            width: meta.column.width,
            minWidth: meta.column.width,
            maxWidth: meta.column.width
          },
          onClick: canSort ? header.column.getToggleSortingHandler() : void 0,
          isSortable: canSort,
          sortDirection,
          children: flexRender(header.column.columnDef.header, header.getContext())
        },
        header.id
      );
    }) }, headerGroup.id)) }),
    /* @__PURE__ */ jsx(TableBody, { children: table.getRowModel().rows.length === 0 ? /* @__PURE__ */ jsx(TableRow, { disableHover: true, children: /* @__PURE__ */ jsx(TableCell, { colSpan: columns.length, children: /* @__PURE__ */ jsx(
      EmptyState,
      {
        ...emptyState ?? {
          title: "No data available",
          subtitle: "There are no items to display."
        }
      }
    ) }) }) : table.getRowModel().rows.map((row) => /* @__PURE__ */ jsx(
      TableRow,
      {
        className: cn2(
          onRowClick && "cursor-pointer hover:bg-muted/50",
          "transition-colors"
        ),
        onClick: () => onRowClick?.(row.original),
        children: row.getVisibleCells().map((cell) => {
          const meta = cell.column.columnDef.meta;
          return /* @__PURE__ */ jsx(
            TableCell,
            {
              className: "text-left",
              style: {
                width: meta.column.width,
                minWidth: meta.column.width,
                maxWidth: meta.column.width
              },
              children: flexRender(cell.column.columnDef.cell, cell.getContext())
            },
            cell.id
          );
        })
      },
      row.id
    )) })
  ] }) });
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var count3 = 0;
function useFocusGuards() {
  React.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count3++;
    return () => {
      if (count3 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count3--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
      s3 = arguments[i5];
      for (var p in s3) if (Object.prototype.hasOwnProperty.call(s3, p)) t3[p] = s3[p];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s3, e2) {
  var t3 = {};
  for (var p in s3) if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
    t3[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p = Object.getOwnPropertySymbols(s3); i5 < p.length; i5++) {
      if (e2.indexOf(p[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i5]))
        t3[p[i5]] = s3[p[i5]];
    }
  return t3;
}
function __spreadArray(to, from, pack) {
  for (var i5 = 0, l4 = from.length, ar2; i5 < l4; i5++) {
    if (ar2 || !(i5 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i5);
      ar2[i5] = from[i5];
    }
  }
  return to.concat(ar2 || Array.prototype.slice.call(from));
}

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.2.7_react@19.2.1/node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef2(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../../node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.2.7_react@19.2.1/node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a4) {
  return a4;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.1/node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.1/node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.1/node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported2 = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported2 = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported2 = false;
  }
}
var options;
var nonPassive = passiveSupported2 ? { passive: false } : false;

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y2) {
  return x[0] === y2[0] && x[1] === y2[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef)).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.2.7_react@19.2.1/node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/.pnpm/aria-hidden@1.2.6/node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var DIALOG_NAME = "Dialog";
var [createDialogContext] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React.useRef(null);
  const contentRef = React.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME2 = "DialogTrigger";
var DialogTrigger = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME2, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME3 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME3, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME3, __scopeDialog);
  return /* @__PURE__ */ jsx(PortalProvider2, { scope: __scopeDialog, forceMount, children: React.Children.map(children, (child) => /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot2 = createSlot2("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsx(Combination_default, { as: Slot2, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsx(
        Primitive.div,
        {
          "data-state": getState2(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React.useRef(false);
    const hasPointerDownOutsideRef = React.useRef(false);
    return /* @__PURE__ */ jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState2(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root4 = Dialog;
var Portal3 = DialogPortal;
var Overlay = DialogOverlay;
var Content3 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;
function Dialog2({ ...props }) {
  return /* @__PURE__ */ jsx(Root4, { "data-slot": "dialog", ...props });
}
function DialogPortal2({ ...props }) {
  return /* @__PURE__ */ jsx(Portal3, { "data-slot": "dialog-portal", ...props });
}
function DialogOverlay2({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    Overlay,
    {
      "data-slot": "dialog-overlay",
      className: cn2(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 duration-200 ease-in-out",
        className
      ),
      ...props
    }
  );
}
function DialogContent2({
  className,
  children,
  showCloseButton = true,
  ...props
}) {
  return /* @__PURE__ */ jsxs(DialogPortal2, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ jsx(DialogOverlay2, {}),
    /* @__PURE__ */ jsxs(
      Content3,
      {
        "data-slot": "dialog-content",
        className: cn2(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 shadow-bevel-2xl rounded-5xl fixed top-[50%] left-[50%] z-[999] grid w-full translate-x-[-50%] translate-y-[-50%] gap-4 p-6 duration-200 ease-in-out sm:max-w-lg",
          className
        ),
        ...props,
        children: [
          children,
          showCloseButton && /* @__PURE__ */ jsx(
            Close,
            {
              asChild: true,
              "data-slot": "dialog-close",
              className: "ring-offset-background absolute top-4 right-4",
              children: /* @__PURE__ */ jsxs(Button, { variant: "ghost", size: "icon", children: [
                /* @__PURE__ */ jsx(X, {}),
                /* @__PURE__ */ jsx("span", { className: "sr-only", children: "Close" })
              ] })
            }
          )
        ]
      }
    )
  ] });
}
function DialogHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: cn2("flex flex-col gap-2 text-center sm:text-left", className),
      ...props
    }
  );
}
function DialogFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: cn2("flex flex-row gap-2 justify-end", className),
      ...props
    }
  );
}
function DialogTitle2({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    Title,
    {
      "data-slot": "dialog-title",
      className: cn2("text-lg text-primary leading-none font-semibold", className),
      ...props
    }
  );
}
function DialogDescription2({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    Description,
    {
      "data-slot": "dialog-description",
      className: cn2("text-muted-foreground text-sm", className),
      ...props
    }
  );
}
var DEFAULT_NEXT_ACTION = {
  type: "submit",
  label: "Save",
  variant: "primary",
  onClick: () => {
  }
};
var DEFAULT_PREVIOUS_ACTION = {
  label: "Cancel",
  variant: "outline",
  onClick: () => {
  }
};
var FormActions = ({
  hasUnsavedChanges = false,
  isLoading = false,
  nextAction,
  previousAction,
  className,
  showPrevious = true,
  showNext = true,
  showUnsavedChanges = true,
  align = "right",
  unsavedChangesText = "Unsaved changes"
}) => {
  const nextButtonProps = React.useMemo(
    () => ({ ...DEFAULT_NEXT_ACTION, ...nextAction }),
    [nextAction]
  );
  const previousButtonProps = React.useMemo(
    () => ({ ...DEFAULT_PREVIOUS_ACTION, ...previousAction }),
    [previousAction]
  );
  const handleNextClick = React.useCallback(
    (e2) => {
      nextButtonProps.onClick(e2.nativeEvent);
    },
    [nextButtonProps.onClick]
  );
  const handlePreviousClick = React.useCallback(
    (e2) => {
      previousButtonProps.onClick(e2.nativeEvent);
    },
    [previousButtonProps.onClick]
  );
  const showUnsavedIndicator = showUnsavedChanges && hasUnsavedChanges;
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn2(
        "flex flex-row items-center gap-2 p-2",
        align === "right" ? "justify-end" : "justify-start",
        className
      ),
      children: [
        showUnsavedIndicator && /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsx(
            "div",
            {
              className: "w-2 h-2 rounded-full bg-orange-500 transition-colors",
              "aria-hidden": "true"
            }
          ),
          /* @__PURE__ */ jsx("span", { className: "text-sm text-muted-foreground", children: unsavedChangesText })
        ] }),
        showPrevious && /* @__PURE__ */ jsx(
          Button,
          {
            type: "button",
            variant: previousButtonProps.variant,
            size: previousButtonProps.size,
            onClick: handlePreviousClick,
            disabled: previousButtonProps.disabled || isLoading,
            className: "FormActions-previous",
            children: previousButtonProps.label
          }
        ),
        showNext && /* @__PURE__ */ jsx(
          Button,
          {
            type: nextButtonProps.type,
            variant: nextButtonProps.variant,
            size: nextButtonProps.size,
            disabled: nextButtonProps.disabled || isLoading,
            className: "FormActions-next",
            ...nextButtonProps.type !== "submit" && { onClick: handleNextClick },
            children: isLoading ? /* @__PURE__ */ jsx(
              Spinner,
              {
                colorScheme: nextButtonProps.variant === "destructive" ? "primary" : "foreground",
                size: "sm",
                "aria-hidden": "true"
              }
            ) : /* @__PURE__ */ jsxs(Fragment, { children: [
              nextButtonProps.icon && /* @__PURE__ */ jsx("span", { className: "mr-2", "aria-hidden": "true", children: nextButtonProps.icon }),
              nextButtonProps.label
            ] })
          }
        )
      ]
    }
  );
};
var Modal = ({
  open,
  onOpenChange,
  title,
  description,
  content,
  modalActions,
  className,
  showCloseButton
}) => {
  const hasHeader = title || description;
  const actions = {
    hasUnsavedChanges: true,
    showPrevious: true,
    showUnsavedChanges: false,
    previousAction: {
      label: "Cancel",
      variant: "outline",
      onClick: () => onOpenChange(false)
    },
    nextAction: {
      label: "Confirm",
      variant: "primary",
      onClick: () => onOpenChange(false)
    },
    ...modalActions
  };
  return /* @__PURE__ */ jsx(Dialog2, { open, onOpenChange, children: /* @__PURE__ */ jsxs(DialogContent2, { className, showCloseButton, children: [
    hasHeader && /* @__PURE__ */ jsxs(DialogHeader, { children: [
      title && /* @__PURE__ */ jsx(DialogTitle2, { children: title }),
      description && /* @__PURE__ */ jsx(DialogDescription2, { children: description })
    ] }),
    content && /* @__PURE__ */ jsx("div", { className: "py-4", children: content }),
    /* @__PURE__ */ jsx(DialogFooter, { children: /* @__PURE__ */ jsx(FormActions, { ...actions }) })
  ] }) });
};
Modal.displayName = "Modal";
function DomainConfigureProvidersModal({
  className,
  customMessages,
  domain,
  providers,
  isOpen,
  isLoading,
  isLoadingSwitch,
  onClose,
  onToggleSwitch,
  onOpenProvider,
  onCreateProvider
}) {
  const { t: t3 } = useTranslator("domain_management.domain_configure_providers.modal", customMessages);
  const handleToggleSwitch = React__default.useCallback(
    (provider, newCheckedValue) => {
      onToggleSwitch(domain, provider, newCheckedValue);
    },
    [domain, onToggleSwitch]
  );
  const columns = React__default.useMemo(
    () => [
      {
        type: "text",
        accessorKey: "display_name",
        title: t3("table.columns.name"),
        width: "25%",
        render: (provider) => /* @__PURE__ */ jsx("div", { className: "font-medium", children: provider.display_name })
      },
      {
        type: "text",
        accessorKey: "strategy",
        title: t3("table.columns.provider"),
        width: "40%",
        render: (provider) => /* @__PURE__ */ jsx("div", { className: "text-muted-foreground", children: provider.strategy })
      },
      {
        type: "actions",
        title: "",
        width: "30%",
        render: (provider) => /* @__PURE__ */ jsxs("div", { className: "flex items-center justify-end gap-4 min-w-0", children: [
          onOpenProvider && /* @__PURE__ */ jsx(
            Button,
            {
              type: "button",
              variant: "outline",
              size: "sm",
              onClick: () => onOpenProvider(provider),
              children: t3("table.actions.view_provider_button_text")
            }
          ),
          /* @__PURE__ */ jsx(
            Switch2,
            {
              checked: provider.is_associated ?? false,
              onCheckedChange: (checked) => handleToggleSwitch(provider, checked),
              disabled: isLoadingSwitch
            }
          )
        ] })
      }
    ],
    [t3, onOpenProvider, isLoadingSwitch, handleToggleSwitch]
  );
  return /* @__PURE__ */ jsx(
    Modal,
    {
      open: isOpen,
      onOpenChange: (open) => !open && onClose(),
      className: "p-10",
      title: t3("title", { domain: domain?.domain ?? "" }),
      content: domain && /* @__PURE__ */ jsxs("div", { className: cn2("space-y-6", className), children: [
        /* @__PURE__ */ jsx("p", { className: "text-sm text-muted-foreground text-(length:--font-size-paragraph)", children: t3("description", { domain: domain?.domain ?? "" }) }),
        /* @__PURE__ */ jsx(
          DataTable,
          {
            columns,
            data: providers,
            loading: isLoading,
            emptyState: {
              title: t3("table.empty_message"),
              action: onCreateProvider ? {
                label: t3("table.actions.add_provider_button_text"),
                variant: "outline",
                onClick: onCreateProvider
              } : void 0
            }
          }
        )
      ] }),
      modalActions: {
        showNext: false,
        previousAction: {
          label: t3("actions.close_button_text"),
          onClick: onClose
        }
      }
    }
  );
}
var r4 = (t3, r5, o5) => {
  if (t3 && "reportValidity" in t3) {
    const s3 = get(o5, r5);
    t3.setCustomValidity(s3 && s3.message || ""), t3.reportValidity();
  }
};
var o3 = (e2, t3) => {
  for (const o5 in t3.fields) {
    const s3 = t3.fields[o5];
    s3 && s3.ref && "reportValidity" in s3.ref ? r4(s3.ref, o5, e2) : s3 && s3.refs && s3.refs.forEach((t4) => r4(t4, o5, e2));
  }
};
var s = (r5, s3) => {
  s3.shouldUseNativeValidation && o3(r5, s3);
  const n4 = {};
  for (const o5 in r5) {
    const f = get(s3.fields, o5), c = Object.assign(r5[o5] || {}, { ref: f && f.ref });
    if (i3(s3.names || Object.keys(r5), o5)) {
      const r6 = Object.assign({}, get(n4, o5));
      set(r6, "root", c), set(n4, o5, r6);
    } else set(n4, o5, c);
  }
  return n4;
};
var i3 = (e2, t3) => {
  const r5 = n3(t3);
  return e2.some((e3) => n3(e3).match(`^${r5}\\.\\d+`));
};
function n3(e2) {
  return e2.replace(/\]|\[/g, "");
}
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer2(inst, def);
    for (const k in _2.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _2.prototype[k].bind(inst) });
    }
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _2(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_2, "name", { value: name });
  return _2;
}
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  return globalConfig;
}

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/util.js
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var parse2 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);

// ../../node_modules/.pnpm/@hookform+resolvers@5.2.2_react-hook-form@7.66.1_react@19.2.1_/node_modules/@hookform/resolvers/zod/dist/zod.mjs
function t2(r5, e2) {
  try {
    var o5 = r5();
  } catch (r6) {
    return e2(r6);
  }
  return o5 && o5.then ? o5.then(void 0, e2) : o5;
}
function s2(r5, e2) {
  for (var n4 = {}; r5.length; ) {
    var t3 = r5[0], s3 = t3.code, i5 = t3.message, a4 = t3.path.join(".");
    if (!n4[a4]) if ("unionErrors" in t3) {
      var u2 = t3.unionErrors[0].errors[0];
      n4[a4] = { message: u2.message, type: u2.code };
    } else n4[a4] = { message: i5, type: s3 };
    if ("unionErrors" in t3 && t3.unionErrors.forEach(function(e3) {
      return e3.errors.forEach(function(e4) {
        return r5.push(e4);
      });
    }), e2) {
      var c = n4[a4].types, f = c && c[t3.code];
      n4[a4] = appendErrors(a4, e2, n4, s3, f ? [].concat(f, t3.message) : t3.message);
    }
    r5.shift();
  }
  return n4;
}
function i4(r5, e2) {
  for (var n4 = {}; r5.length; ) {
    var t3 = r5[0], s3 = t3.code, i5 = t3.message, a4 = t3.path.join(".");
    if (!n4[a4]) if ("invalid_union" === t3.code && t3.errors.length > 0) {
      var u2 = t3.errors[0][0];
      n4[a4] = { message: u2.message, type: u2.code };
    } else n4[a4] = { message: i5, type: s3 };
    if ("invalid_union" === t3.code && t3.errors.forEach(function(e3) {
      return e3.forEach(function(e4) {
        return r5.push(e4);
      });
    }), e2) {
      var c = n4[a4].types, f = c && c[t3.code];
      n4[a4] = appendErrors(a4, e2, n4, s3, f ? [].concat(f, t3.message) : t3.message);
    }
    r5.shift();
  }
  return n4;
}
function a3(o5, a4, u2) {
  if (void 0 === u2 && (u2 = {}), (function(r5) {
    return "_def" in r5 && "object" == typeof r5._def && "typeName" in r5._def;
  })(o5)) return function(n4, i5, c) {
    try {
      return Promise.resolve(t2(function() {
        return Promise.resolve(o5["sync" === u2.mode ? "parse" : "parseAsync"](n4, a4)).then(function(e2) {
          return c.shouldUseNativeValidation && o3({}, c), { errors: {}, values: u2.raw ? Object.assign({}, n4) : e2 };
        });
      }, function(r5) {
        if ((function(r6) {
          return Array.isArray(null == r6 ? void 0 : r6.issues);
        })(r5)) return { values: {}, errors: s(s2(r5.errors, !c.shouldUseNativeValidation && "all" === c.criteriaMode), c) };
        throw r5;
      }));
    } catch (r5) {
      return Promise.reject(r5);
    }
  };
  if ((function(r5) {
    return "_zod" in r5 && "object" == typeof r5._zod;
  })(o5)) return function(s3, c, f) {
    try {
      return Promise.resolve(t2(function() {
        return Promise.resolve(("sync" === u2.mode ? parse2 : parseAsync)(o5, s3, a4)).then(function(e2) {
          return f.shouldUseNativeValidation && o3({}, f), { errors: {}, values: u2.raw ? Object.assign({}, s3) : e2 };
        });
      }, function(r5) {
        if ((function(r6) {
          return r6 instanceof $ZodError;
        })(r5)) return { values: {}, errors: s(i4(r5.issues, !f.shouldUseNativeValidation && "all" === f.criteriaMode), f) };
        throw r5;
      }));
    } catch (r5) {
      return Promise.reject(r5);
    }
  };
  throw new Error("Invalid input: not a Zod schema");
}
function Label({ children, className, ...props }) {
  return /* @__PURE__ */ jsx(
    "label",
    {
      className: cn2(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      ),
      ...props,
      children
    }
  );
}
var Form = FormProvider;
var FormFieldContext = React.createContext({});
var FormField = ({
  ...props
}) => {
  return /* @__PURE__ */ jsx(FormFieldContext.Provider, { value: { name: props.name }, children: /* @__PURE__ */ jsx(
    Controller,
    {
      ...props,
      render: ({ field, fieldState, formState }) => {
        const { onChange, onBlur, ...rest } = field;
        return props.render({
          field: {
            ...rest,
            onChange: (...args) => {
              onChange(...args);
            },
            onBlur: (...args) => {
              onBlur(...args);
            }
          },
          fieldState,
          formState
        });
      }
    }
  ) });
};
var useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState } = useFormContext();
  const formState = useFormState({ name: fieldContext.name });
  const fieldState = getFieldState(fieldContext.name, formState);
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const { id } = itemContext;
  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState
  };
};
var FormItemContext = React.createContext({});
function FormItem({ className, ...props }) {
  const id = React.useId();
  return /* @__PURE__ */ jsx(FormItemContext.Provider, { value: { id }, children: /* @__PURE__ */ jsx("div", { "data-slot": "form-item", className: cn2("grid gap-2", className), ...props }) });
}
function FormControl({ ...props }) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
  return /* @__PURE__ */ jsx(
    Slot,
    {
      "data-slot": "form-control",
      id: formItemId,
      "aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
      "aria-invalid": !!error,
      ...props
    }
  );
}
function FormMessage({ className, ...props }) {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message ?? "") : props.children;
  if (!body) {
    return null;
  }
  return /* @__PURE__ */ jsx(
    "p",
    {
      "data-slot": "form-message",
      id: formMessageId,
      className: cn2("text-destructive-foreground text-sm", className),
      ...props,
      children: body
    }
  );
}
var textFieldVariants = cva(
  "bg-input aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive relative box-border inline-flex w-full shrink-0 cursor-text items-center justify-center gap-2 overflow-hidden rounded-2xl text-sm transition-[color,box-shadow] duration-150 ease-in-out outline-none disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
  {
    variants: {
      variant: {
        default: "border-border/50 text-input-foreground shadow-input-resting hover:shadow-input-hover hover:border-primary/25 focus-within:border-border focus-within:ring-primary/15 focus-within:ring-4",
        error: "border-destructive-border/50 text-destructive-foreground shadow-input-destructive-resting hover:shadow-input-destructive-hover hover:border-destructive-border/25 focus-within:ring-destructive-border/15 focus-within:ring-4"
      },
      size: {
        default: "h-10",
        sm: "h-9",
        lg: "h-11"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var TextField = React.forwardRef(
  ({ className, variant, size: size4, error, helperText, startAdornment, endAdornment, ...props }, ref) => {
    const isDisabled = props.disabled;
    const WrapperComponent = props.id ? "div" : "label";
    return /* @__PURE__ */ jsxs("div", { className: "flex w-full flex-col", children: [
      /* @__PURE__ */ jsxs(
        WrapperComponent,
        {
          className: cn2(
            textFieldVariants({ variant: error ? "error" : variant, size: size4 }),
            "group items-center gap-0.5",
            isDisabled && "bg-input-muted text-input-muted-foreground cursor-not-allowed opacity-50",
            isDisabled && variant === "default" && "bg-input-muted",
            startAdornment && "pl-[5px]",
            endAdornment && "pr-[5px]",
            className
          ),
          children: [
            startAdornment && /* @__PURE__ */ jsx("div", { className: "[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", children: startAdornment }),
            /* @__PURE__ */ jsx(
              "input",
              {
                className: cn2(
                  "w-full flex-1 bg-transparent px-3 py-2 outline-none file:border-0 file:bg-transparent file:text-sm file:font-medium",
                  isDisabled && "bg-input-muted text-input-muted-foreground cursor-not-allowed opacity-50",
                  startAdornment && "pl-0",
                  endAdornment && "pr-0",
                  size4 === "default" && "h-10",
                  size4 === "sm" && "h-9",
                  size4 === "lg" && "h-11"
                ),
                ref,
                ...props
              }
            ),
            endAdornment && /* @__PURE__ */ jsx("div", { className: "[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", children: endAdornment })
          ]
        }
      ),
      helperText && /* @__PURE__ */ jsx(
        "p",
        {
          className: cn2(
            "mt-1.5 px-2 text-xs",
            error ? "text-destructive-foreground" : "text-muted-foreground"
          ),
          children: helperText
        }
      )
    ] });
  }
);
TextField.displayName = "TextField";
function DomainCreateModal({
  translatorKey = "domain_management.domain_create.modal",
  className,
  customMessages,
  isOpen,
  isLoading,
  schema,
  onClose,
  onCreate
}) {
  const { t: t3 } = useTranslator(translatorKey, customMessages);
  const domainCreateSchema = React.useMemo(
    () => hA(schema, t3("field.error")),
    [schema, t3]
  );
  const form = useForm({
    resolver: a3(domainCreateSchema),
    defaultValues: {
      domain_url: ""
    },
    mode: "onChange"
  });
  const handleCreate = React.useCallback(
    async (values) => {
      if (!values.domain_url) return;
      await onCreate(values.domain_url);
      form.reset();
    },
    [form, onCreate]
  );
  const handleClose = React.useCallback(() => {
    form.reset();
    onClose();
  }, [form, onClose]);
  const onSubmit = React.useCallback(
    (e2) => {
      e2.preventDefault();
      form.handleSubmit(handleCreate)();
    },
    [form, handleCreate]
  );
  return /* @__PURE__ */ jsx(
    Modal,
    {
      open: isOpen,
      onOpenChange: (open) => !open && handleClose(),
      className: cn2("p-10", className),
      title: t3("title"),
      content: /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(Form, { ...form, children: /* @__PURE__ */ jsx("form", { id: "domain-create-form", onSubmit, children: /* @__PURE__ */ jsx(
        FormField,
        {
          control: form.control,
          name: "domain_url",
          render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
            /* @__PURE__ */ jsx(
              Label,
              {
                htmlFor: "domain-url",
                className: "text-sm text-(length:--font-size-label) font-medium",
                children: t3("field.label")
              }
            ),
            /* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(
              TextField,
              {
                id: "domain-url",
                type: "text",
                placeholder: t3("field.placeholder"),
                className: "mt-2",
                ...field
              }
            ) }),
            /* @__PURE__ */ jsx(FormMessage, {})
          ] })
        }
      ) }) }) }),
      modalActions: {
        isLoading,
        nextAction: {
          type: "button",
          label: t3("actions.create_button_text"),
          variant: "primary",
          disabled: isLoading,
          onClick: (e2) => {
            e2.preventDefault();
            form.handleSubmit(handleCreate)();
          }
        },
        previousAction: {
          label: t3("actions.cancel_button_text"),
          onClick: handleClose
        }
      }
    }
  );
}
var getDescriptionKey = (domain) => {
  return domain?.status === "pending" ? "description.pending" : "description.verified";
};
function DomainDeleteModal({
  translatorKey = "domain_management.domain_delete.modal",
  className,
  customMessages,
  domain,
  isOpen,
  isLoading,
  onClose,
  onDelete
}) {
  const { t: t3 } = useTranslator(translatorKey, customMessages);
  const handleDelete = React__default.useCallback(() => {
    if (domain) {
      onDelete(domain);
    }
  }, [onDelete, domain]);
  return /* @__PURE__ */ jsx(
    Modal,
    {
      open: isOpen,
      onOpenChange: (open) => !open && onClose(),
      className: cn2("p-10", className),
      title: t3("title"),
      content: /* @__PURE__ */ jsx("div", { className: "space-y-6", children: /* @__PURE__ */ jsx("p", { className: "text-sm text-muted-foreground text-(length:--font-size-paragraph)", children: t3(getDescriptionKey(domain), { domainName: domain?.domain }) }) }),
      modalActions: {
        isLoading,
        nextAction: {
          type: "button",
          label: t3("actions.delete_button_text"),
          variant: "destructive",
          disabled: isLoading,
          onClick: handleDelete
        },
        previousAction: {
          label: t3("actions.cancel_button_text"),
          onClick: onClose
        }
      }
    }
  );
}
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope3] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React__default.useRef(null);
    const itemMap = React__default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
  const CollectionSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsx(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
  const CollectionItemSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React__default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React__default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection3(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React__default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a4, b2) => orderedNodes.indexOf(a4.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection3,
    createCollectionScope3
  ];
}
var DirectionContext = React.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsx(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsx(
      Collection.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root5 = RovingFocusGroup;
var Item = RovingFocusGroupItem;
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope2 = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope2(__scopeMenu);
  const [content, setContent] = React.useState(null);
  const isUsingKeyboardRef = React.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsx(Root22, { ...popperScope, children: /* @__PURE__ */ jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME2 = "MenuAnchor";
var MenuAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope2(__scopeMenu);
    return /* @__PURE__ */ jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME2;
var PORTAL_NAME4 = "MenuPortal";
var [PortalProvider3, usePortalContext3] = createMenuContext(PORTAL_NAME4, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME4, __scopeMenu);
  return /* @__PURE__ */ jsx(PortalProvider3, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME4 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME4);
var MenuContent = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME4, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME4, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME4, props.__scopeMenu);
    return /* @__PURE__ */ jsx(Collection2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(Collection2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME4, props.__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME4, props.__scopeMenu);
  return /* @__PURE__ */ jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot3 = createSlot2("MenuContent.ScrollLock");
var MenuContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME4, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME4, __scopeMenu);
    const popperScope = usePopperScope2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React.useState(null);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React.useRef(0);
    const searchRef = React.useRef("");
    const pointerGraceTimerRef = React.useRef(0);
    const pointerGraceIntentRef = React.useRef(null);
    const pointerDirRef = React.useRef("right");
    const lastPointerXRef = React.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot3, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React.useCallback((event) => {
      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
    }, []);
    return /* @__PURE__ */ jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) return;
            contentRef.current?.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              event.preventDefault();
              contentRef.current?.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsx(
                  Root5,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsx(
                      Content,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst3(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME4;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME2, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME2, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          props.onPointerDown?.(event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          if (!isPointerDownRef.current) event.currentTarget?.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME2;
var MenuItemImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME2, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React.useState(false);
    const [textContent, setTextContent] = React.useState("");
    React.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsx(
      Collection2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsx(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef(onValueChange);
    return /* @__PURE__ */ jsx(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => context.onValueChange?.(value),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return /* @__PURE__ */ jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME3 = "MenuArrow";
var MenuArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope2(__scopeMenu);
    return /* @__PURE__ */ jsx(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const openTimerRef = React.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          props.onClick?.(event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            clearOpenTimer();
            const contentRect = context.content?.getBoundingClientRect();
            if (contentRect) {
              const side = context.content?.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            context.content?.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME4, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME4, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME4, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsx(Collection2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(Collection2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            subContext.trigger?.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon2(point, polygon) {
  const { x, y: y2 } = point;
  let inside = false;
  for (let i5 = 0, j = polygon.length - 1; i5 < polygon.length; j = i5++) {
    const ii = polygon[i5];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y2 !== yj > y2 && x < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon2(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root33 = Menu;
var Anchor2 = MenuAnchor;
var Portal4 = MenuPortal;
var Content22 = MenuContent;
var Group = MenuGroup;
var Label2 = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow23 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return /* @__PURE__ */ jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsx(Root33, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME3 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME3, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME5 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(Portal4, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME5;
var CONTENT_NAME5 = "DropdownMenuContent";
var DropdownMenuContent = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME5, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React.useRef(false);
    return /* @__PURE__ */ jsx(
      Content22,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME5;
var GROUP_NAME3 = "DropdownMenuGroup";
var DropdownMenuGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "DropdownMenuLabel";
var DropdownMenuLabel = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsx(Label2, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME3 = "DropdownMenuItem";
var DropdownMenuItem = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsx(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME3;
var CHECKBOX_ITEM_NAME2 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME2 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME4 = "DropdownMenuArrow";
var DropdownMenuArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsx(Arrow23, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME4;
var SUB_TRIGGER_NAME2 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME2;
var Root23 = DropdownMenu;
var Trigger3 = DropdownMenuTrigger;
var Portal22 = DropdownMenuPortal;
var Content23 = DropdownMenuContent;
var Item22 = DropdownMenuItem;
function DropdownMenu2({ ...props }) {
  return /* @__PURE__ */ jsx(Root23, { "data-slot": "dropdown-menu", ...props });
}
function DropdownMenuPortal2({
  ...props
}) {
  return /* @__PURE__ */ jsx(Portal22, { "data-slot": "dropdown-menu-portal", ...props });
}
function DropdownMenuTrigger2({
  className,
  variant,
  size: size4,
  ...props
}) {
  return /* @__PURE__ */ jsx(Trigger3, { asChild: true, ...props, children: /* @__PURE__ */ jsx(
    Button,
    {
      "data-slot": "dropdown-menu-trigger",
      className: cn2(buttonVariants({ variant, size: size4 }), className),
      children: props.children
    }
  ) });
}
function DropdownMenuContent2({
  className,
  sideOffset = 4,
  ...props
}) {
  return /* @__PURE__ */ jsx(Portal22, { children: /* @__PURE__ */ jsx(
    Content23,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset,
      className: cn2(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 shadow-bevel-xl z-50 min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-2xl p-1 outline-none",
        className
      ),
      ...props
    }
  ) });
}
function DropdownMenuItem2({
  className,
  inset,
  variant = "default",
  ...props
}) {
  return /* @__PURE__ */ jsx(
    Item22,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": inset,
      "data-variant": variant,
      className: cn2(
        "focus:bg-muted hover:bg-muted/50 focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-xl px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      ),
      ...props
    }
  );
}
function DomainTableActionsColumn({
  customMessages = {},
  readOnly = false,
  domain,
  onView,
  onConfigure,
  onVerify,
  onDelete
}) {
  const { t: t3 } = useTranslator("domain_management.domain_table", customMessages);
  const handleView = React.useCallback(() => {
    onConfigure(domain);
  }, [domain, onView]);
  const handleConfigure = React.useCallback(() => {
    onConfigure(domain);
  }, [domain, onConfigure]);
  const handleVerify = React.useCallback(() => {
    onVerify(domain);
  }, [domain, onVerify]);
  const handleDelete = React.useCallback(() => {
    onDelete(domain);
  }, [domain, onDelete]);
  return /* @__PURE__ */ jsx("div", { className: "flex items-center justify-end gap-4 min-w-0", children: /* @__PURE__ */ jsxs(DropdownMenu2, { children: [
    /* @__PURE__ */ jsx(DropdownMenuTrigger2, { className: "h-8 w-8 p-0 rounded-xl bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 shadow-sm transition-all duration-200 hover:bg-gray-50 dark:hover:bg-gray-800 hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500", children: /* @__PURE__ */ jsx(Ellipsis, { className: "h-4 w-4 text-gray-600 dark:text-gray-400" }) }),
    /* @__PURE__ */ jsx(DropdownMenuPortal2, { children: /* @__PURE__ */ jsxs(DropdownMenuContent2, { align: "end", children: [
      domain.status === "verified" && /* @__PURE__ */ jsxs(DropdownMenuItem2, { onClick: handleConfigure, disabled: readOnly, children: [
        /* @__PURE__ */ jsx(PencilLine, { className: "mr-2 h-4 w-4" }),
        t3("table.actions.configure_button_text")
      ] }),
      domain.status === "pending" && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs(DropdownMenuItem2, { onClick: handleView, disabled: readOnly, children: [
          /* @__PURE__ */ jsx(Eye, { className: "mr-2 h-4 w-4" }),
          t3("table.actions.view_button_text")
        ] }),
        /* @__PURE__ */ jsxs(DropdownMenuItem2, { onClick: handleVerify, disabled: readOnly, children: [
          /* @__PURE__ */ jsx(RefreshCcw, { className: "mr-2 h-4 w-4" }),
          t3("table.actions.verify_button_text")
        ] })
      ] }),
      /* @__PURE__ */ jsxs(
        DropdownMenuItem2,
        {
          onClick: handleDelete,
          className: "text-destructive-foreground focus:text-destructive-foreground",
          disabled: readOnly,
          children: [
            /* @__PURE__ */ jsx(Trash2, { className: "mr-2 h-4 w-4 text-destructive-foreground focus:text-destructive-foreground" }),
            t3("table.actions.delete_button_text")
          ]
        }
      )
    ] }) })
  ] }) });
}
var alertVariants = cva(
  "shadow-input-hover bg-input relative grid w-full grid-cols-[0_1fr] items-start gap-y-0.5 overflow-clip rounded-3xl p-3 text-sm has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] has-[>svg]:gap-x-3 [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "text-foreground border-b-2 border-transparent",
        info: "text-info-foreground [&>svg]:text-info-foreground",
        success: "text-success-foreground [&>svg]:text-success-foreground",
        warning: "text-warning-foreground [&>svg]:text-warning-foreground",
        destructive: "text-destructive-foreground [&>svg]:text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Alert({
  className,
  variant,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "alert",
      role: "alert",
      className: cn2(alertVariants({ variant }), className),
      ...props
    }
  );
}
function AlertDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "alert-description",
      className: cn2(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      ),
      ...props
    }
  );
}
var CopyableTextField = React.forwardRef(
  ({
    onCopy,
    copyButtonClassName,
    tooltipSide = "top",
    tooltipAlign = "end",
    readOnly = true,
    endAdornment,
    showCopyButton = true,
    ...props
  }, ref) => {
    const { t: t3 } = useTranslator("common");
    const [tooltipText, setTooltipText] = React.useState(t3("copy"));
    const [tooltipOpen, setTooltipOpen] = React.useState(false);
    const handleCopy = async () => {
      if (props.value) {
        await navigator.clipboard.writeText(String(props.value));
        setTooltipText(t3("copied"));
        setTooltipOpen(true);
        setTimeout(() => {
          setTooltipText(t3("copy"));
          setTooltipOpen(false);
        }, 1e3);
        onCopy?.();
      }
    };
    const copyButton = /* @__PURE__ */ jsxs(Tooltip2, { open: tooltipOpen, onOpenChange: setTooltipOpen, children: [
      /* @__PURE__ */ jsx(TooltipTrigger2, { asChild: true, children: /* @__PURE__ */ jsx(
        Button,
        {
          type: "button",
          variant: "ghost",
          size: "icon",
          className: cn2("h-8 w-8", copyButtonClassName),
          onClick: handleCopy,
          "aria-label": t3("copy"),
          children: /* @__PURE__ */ jsx(Copy, { className: "h-4 w-4", "aria-hidden": "true" })
        }
      ) }),
      /* @__PURE__ */ jsx(TooltipContent2, { side: tooltipSide, align: tooltipAlign, sideOffset: 5, className: "z-[1000]", children: tooltipText })
    ] });
    return /* @__PURE__ */ jsx(
      TextField,
      {
        ref,
        readOnly,
        ...props,
        endAdornment: showCopyButton ? endAdornment ? /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-1", children: [
          endAdornment,
          copyButton
        ] }) : copyButton : endAdornment
      }
    );
  }
);
CopyableTextField.displayName = "CopyableTextField";
function DomainVerifyModal({
  translatorKey = "domain_management.domain_verify.modal",
  className,
  customMessages,
  isOpen,
  isLoading,
  domain,
  error,
  onClose,
  onVerify,
  onDelete
}) {
  const { t: t3 } = useTranslator(translatorKey, customMessages);
  const handleVerify = React__default.useCallback(() => {
    if (domain) {
      onVerify(domain);
    }
  }, [onVerify, domain]);
  const handleDelete = React__default.useCallback(() => {
    if (domain) {
      onDelete(domain);
    }
  }, [onDelete, domain]);
  return /* @__PURE__ */ jsx(
    Modal,
    {
      open: isOpen,
      onOpenChange: (open) => !open && onClose(),
      className: "p-10",
      title: t3("title", { domainName: domain?.domain }),
      content: /* @__PURE__ */ jsxs("div", { className: cn2("space-y-4", className), children: [
        error && /* @__PURE__ */ jsxs(Alert, { variant: "destructive", children: [
          /* @__PURE__ */ jsx(MessageSquare, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsx(AlertDescription, { className: "text-destructive-foreground", children: error })
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsx(Label, { htmlFor: "txt-record-name", className: "text-sm font-medium", children: t3("txt_record_name.label") }),
          /* @__PURE__ */ jsx(
            CopyableTextField,
            {
              id: "txt-record-name",
              value: domain?.verification_host || "",
              readOnly: true,
              className: "text-sm"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsx(Label, { htmlFor: "txt-record-content", className: "text-sm font-medium", children: t3("txt_record_content.label") }),
          /* @__PURE__ */ jsx(
            CopyableTextField,
            {
              id: "txt-record-content",
              value: domain?.verification_txt || "",
              readOnly: true,
              className: "text-sm"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "space-y-2 pt-4 border-t border-gray-200", children: [
          /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsx("span", { className: "text-sm text-foreground font-medium", children: t3("verification_status.label") }),
            /* @__PURE__ */ jsx(Badge, { variant: "warning", children: t3("verification_status.pending") })
          ] }),
          /* @__PURE__ */ jsx("p", { className: cn2("text-sm text-muted-foreground text-(length:--font-size-paragraph"), children: t3("verification_status.description") })
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "flex gap-2 pt-2", children: [
          /* @__PURE__ */ jsx(Button, { variant: "outline", onClick: handleVerify, disabled: isLoading, children: isLoading ? /* @__PURE__ */ jsx(Spinner, { size: "sm" }) : t3("actions.verify_button_text") }),
          /* @__PURE__ */ jsx(Button, { variant: "destructive", onClick: handleDelete, disabled: isLoading, children: t3("actions.delete_button_text") })
        ] })
      ] }),
      modalActions: {
        showNext: false,
        previousAction: {
          label: t3("actions.done_button_text"),
          onClick: onClose,
          variant: "primary"
        }
      }
    }
  );
}
var WithTooltip = ({ trigger, tooltip }) => /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsxs(Tooltip2, { children: [
  /* @__PURE__ */ jsx(TooltipTrigger2, { asChild: true, children: /* @__PURE__ */ jsx("div", { children: trigger }) }),
  /* @__PURE__ */ jsx(TooltipContent2, { children: tooltip.content })
] }) });
var ButtonAction = ({
  icon: Icon2,
  className,
  label,
  onClick,
  disabled,
  variant,
  size: size4
}) => /* @__PURE__ */ jsxs(
  Button,
  {
    onClick,
    disabled,
    variant,
    size: size4,
    className: cn2("flex items-center gap-2 w-full sm:w-auto sm:min-w-fit", className),
    "aria-label": label,
    children: [
      Icon2 && /* @__PURE__ */ jsx(Icon2, { className: "h-4 w-4 flex-shrink-0", "aria-hidden": "true" }),
      /* @__PURE__ */ jsx("span", { className: "truncate", children: label })
    ]
  }
);
var SwitchAction = ({
  className,
  "aria-label": ariaLabel,
  checked,
  onCheckedChange,
  disabled
}) => /* @__PURE__ */ jsx("div", { className: cn2("flex items-center gap-2", className), children: /* @__PURE__ */ jsx(
  Switch2,
  {
    checked,
    onCheckedChange,
    disabled,
    "aria-label": ariaLabel
  }
) });
var Header = React.forwardRef(({ title, description, backButton, actions, isLoading, className, ...props }, ref) => {
  const BackIcon = backButton?.icon || ArrowLeft;
  const renderAction = (action, index2) => {
    const key = `action-${index2}`;
    if (isLoading) {
      return /* @__PURE__ */ jsx(Spinner, { className: "w-4 h-4" });
    }
    if (action.hidden) {
      return null;
    }
    const actionElement = action.type === "switch" ? /* @__PURE__ */ jsx(SwitchAction, { ...action }, key) : /* @__PURE__ */ jsx(ButtonAction, { ...action }, key);
    if (action.tooltip) {
      return /* @__PURE__ */ jsx(WithTooltip, { trigger: actionElement, tooltip: action.tooltip }, `tooltip-${key}`);
    }
    return actionElement;
  };
  return /* @__PURE__ */ jsxs(
    "div",
    {
      ref,
      className: cn2("w-full mb-8", className),
      role: "banner",
      "aria-label": title ? `${title} header` : "Header",
      ...props,
      children: [
        backButton && /* @__PURE__ */ jsxs(
          Button,
          {
            variant: "link",
            onClick: backButton.onClick,
            size: "default",
            className: "flex items-center text-sm mb-3",
            "aria-label": backButton.text || "Go back",
            children: [
              /* @__PURE__ */ jsx(BackIcon, { className: "h-4 w-4", "aria-hidden": "true" }),
              backButton.text && /* @__PURE__ */ jsx("span", { children: backButton.text })
            ]
          }
        ),
        /* @__PURE__ */ jsxs("div", { className: "flex items-start justify-between gap-4", children: [
          /* @__PURE__ */ jsxs("div", { className: "flex flex-col min-w-0 flex-1", children: [
            title && /* @__PURE__ */ jsx(
              "h1",
              {
                className: cn2(
                  "text-xl sm:text-2xl text-primary md:text-4xl font-bold leading-tight break-words text-left text-(length:--font-size-page-header) mb-0"
                ),
                children: title
              }
            ),
            description && /* @__PURE__ */ jsx(
              "p",
              {
                className: cn2(
                  "text-base text-muted-foreground leading-relaxed break-words text-left text-(length:--font-size-page-description) mt-2"
                ),
                children: description
              }
            )
          ] }),
          actions && actions.length > 0 && /* @__PURE__ */ jsx("div", { className: "flex-shrink-0 flex items-start gap-2 mt-1", children: actions.map(renderAction) })
        ] })
      ]
    }
  );
});
Header.displayName = "Header";

// src/lib/my-org/domain-management.ts
function getStatusBadgeVariant(status) {
  switch (status) {
    case "verified":
      return "success";
    case "pending":
      return "warning";
    case "failed":
      return "destructive";
    default:
      return "outline";
  }
}
function DomainTableView({
  customMessages = {},
  schema,
  hideHeader = false,
  readOnly = false,
  createAction,
  onOpenProvider,
  onCreateProvider,
  styling = {
    variables: { common: {}, light: {}, dark: {} },
    classes: {}
  },
  logic
}) {
  const { isDarkMode } = useTheme();
  const { t: t3 } = useTranslator("domain_management", customMessages);
  const { state, actions, domainTableActions } = logic;
  const {
    // State variables and methods
    showCreateModal,
    showConfigureModal,
    showVerifyModal,
    showDeleteModal,
    verifyError,
    selectedDomain,
    setShowCreateModal,
    setShowConfigureModal,
    setShowDeleteModal
  } = state;
  const {
    // Handlers
    handleCreate,
    handleVerify,
    handleDelete,
    handleToggleSwitch,
    handleCloseVerifyModal,
    handleCreateClick,
    handleConfigureClick,
    handleVerifyClick,
    handleDeleteClick
  } = actions;
  const {
    domains,
    providers,
    isCreating,
    isVerifying,
    isFetching,
    isLoadingProviders,
    isDeleting
  } = domainTableActions;
  const currentStyles = React.useMemo(
    () => Wr(styling, isDarkMode),
    [styling, isDarkMode]
  );
  const columns = React.useMemo(
    () => [
      {
        type: "text",
        accessorKey: "domain",
        title: t3("domain_table.table.columns.domain"),
        width: "35%",
        render: (domain) => /* @__PURE__ */ jsx("div", { className: "font-medium", children: domain.domain })
      },
      {
        type: "text",
        accessorKey: "status",
        title: t3("domain_table.table.columns.status"),
        width: "25%",
        render: (domain) => /* @__PURE__ */ jsx(Badge, { variant: getStatusBadgeVariant(domain.status), size: "sm", children: t3(`shared.domain_statuses.${domain.status}`) })
      },
      {
        type: "actions",
        title: "",
        width: "20%",
        render: (domain) => /* @__PURE__ */ jsx(
          DomainTableActionsColumn,
          {
            domain,
            readOnly,
            customMessages,
            onView: handleConfigureClick,
            onConfigure: handleConfigureClick,
            onVerify: handleVerifyClick,
            onDelete: handleDeleteClick
          }
        )
      }
    ],
    [t3, readOnly, customMessages, handleConfigureClick, handleVerifyClick, handleDeleteClick]
  );
  return /* @__PURE__ */ jsxs("div", { style: currentStyles.variables, children: [
    !hideHeader && /* @__PURE__ */ jsx("div", { className: currentStyles.classes?.["DomainTable-header"], children: /* @__PURE__ */ jsx(
      Header,
      {
        title: t3("domain_table.header.title"),
        description: t3("domain_table.header.description"),
        actions: [
          {
            type: "button",
            label: t3("domain_table.header.create_button_text"),
            onClick: () => handleCreateClick(),
            icon: Plus,
            disabled: createAction?.disabled || readOnly || isFetching
          }
        ]
      }
    ) }),
    /* @__PURE__ */ jsx(
      DataTable,
      {
        columns,
        data: domains,
        loading: isFetching,
        emptyState: { title: t3("domain_table.table.empty_message") },
        className: currentStyles.classes?.["DomainTable-table"]
      }
    ),
    /* @__PURE__ */ jsx(
      DomainCreateModal,
      {
        className: currentStyles.classes?.["DomainTable-createModal"],
        isOpen: showCreateModal,
        isLoading: isCreating,
        schema: schema?.create,
        onClose: () => setShowCreateModal(false),
        onCreate: handleCreate,
        customMessages: customMessages.create
      }
    ),
    /* @__PURE__ */ jsx(
      DomainConfigureProvidersModal,
      {
        className: currentStyles.classes?.["DomainTable-configureModal"],
        domain: selectedDomain,
        providers,
        isOpen: showConfigureModal,
        isLoading: isLoadingProviders,
        isLoadingSwitch: false,
        onClose: () => setShowConfigureModal(false),
        onToggleSwitch: handleToggleSwitch,
        onOpenProvider,
        onCreateProvider,
        customMessages: customMessages.configure
      }
    ),
    /* @__PURE__ */ jsx(
      DomainVerifyModal,
      {
        className: currentStyles.classes?.["DomainTable-verifyModal"],
        isOpen: showVerifyModal,
        isLoading: isVerifying,
        domain: selectedDomain,
        error: verifyError,
        onClose: handleCloseVerifyModal,
        onVerify: handleVerify,
        onDelete: handleDeleteClick,
        customMessages: customMessages.verify
      }
    ),
    /* @__PURE__ */ jsx(
      DomainDeleteModal,
      {
        className: currentStyles.classes?.["DomainTable-deleteModal"],
        domain: selectedDomain,
        isOpen: showDeleteModal,
        isLoading: isDeleting,
        onClose: () => setShowDeleteModal(false),
        onDelete: handleDelete,
        customMessages: customMessages.delete
      }
    )
  ] });
}
/*! Bundled license information:

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/arrow-left.js:
lucide-react/dist/esm/icons/chevron-down.js:
lucide-react/dist/esm/icons/chevron-up.js:
lucide-react/dist/esm/icons/copy.js:
lucide-react/dist/esm/icons/ellipsis.js:
lucide-react/dist/esm/icons/eye.js:
lucide-react/dist/esm/icons/message-square.js:
lucide-react/dist/esm/icons/pencil-line.js:
lucide-react/dist/esm/icons/plus.js:
lucide-react/dist/esm/icons/refresh-ccw.js:
lucide-react/dist/esm/icons/trash-2.js:
lucide-react/dist/esm/icons/x.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.511.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

@tanstack/table-core/build/lib/index.mjs:
  (**
     * table-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)

@tanstack/react-table/build/lib/index.mjs:
  (**
     * react-table
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)
*/

export { Auth0ComponentProvider, DomainTableView, useCoreClient };
