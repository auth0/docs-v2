import { Prerequisites } from "/snippets/get-started/prerequisites/call-others-api.jsx";
import { AccountAndAppSteps } from "/snippets/get-started/prerequisites/account-app-steps.jsx";
import { DownloadQuickstartButton } from "/snippets/download-quickstart/DownloadQuickstartButton.jsx";

<Prerequisites
  createAuth0ApplicationStep={{
    applicationType: "Single Page Web Applications",
    callbackUrl: "http://localhost:5173/auth/callback",
    logoutUrl: "http://localhost:5173",
    allowedWebOrigins: "http://localhost:5173",
    enableTokenVaultGrant: true,
    enableRefreshTokenGrant: true,
  }}
  createAuth0ApiStep={{}}
  createResourceServerClientStep={{}}
  tokenExchangeGrantStep={{
    applicationName: "Single Page Web Application",
  }}
/>

### Key differences from Next.js approach

This React SPA implementation differs from the <a href="/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-next-js" target="_blank">Next.js example</a> in a few important ways:

1. **Token Vault Access Token Exchange**: Instead of using refresh tokens, the React SPA implementation exchanges the SPA's access token for a third-party access token.
2. **Client-Side Authorization**: Client login and step-up authorization are handled client-side using `@auth0/auth0-spa-js`.
3. **Resource Server Client**: Requires a special Resource Server Client configured for token exchange with Token Vault.
4. **Interrupt Handling**: The React client manages tool access errors and step-up authorization using interrupts that trigger a pop-up for re-authorization.


### Download sample app
Start by downloading and extracting the sample app. Then open in your preferred IDE.
<DownloadQuickstartButton
  category="call-others-apis-on-users-behalf"
  framework="langchain-react-spa-js"
/>

### Install dependencies

In the root directory of your project, you have the following client and server dependencies:

**Client dependencies:**

- `@auth0/auth0-spa-js`: Auth0 SPA SDK for client-side authentication
- `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents
- `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module

**Server dependencies:**

- `@hono/node-server`: Node.js server adapter for Hono
- `hono`: Lightweight web framework
- `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module
- `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider
- `googleapis`: Node.js client for Google APIs
- `jose`: JavaScript Object Signing and Encryption library for JWT verification
To install all the client and server dependencies, navigate to the root directory of your project and run the following command:
```bash wrap lines
# Install all client & server dependencies from the root directory of the project.
npm install
```

### Update the environment files

Add separate `.env` files with environment variables for the client and server.

#### Client (client/.env)

```bash .env wrap lines
VITE_AUTH0_DOMAIN=your-auth0-domain
VITE_AUTH0_CLIENT_ID=your-spa-client-id
VITE_AUTH0_AUDIENCE=your-api-identifier
VITE_API_URL=http://localhost:3001
```

#### Server (server/.env)

```bash .env wrap lines
AUTH0_DOMAIN=your-auth0-domain
AUTH0_AUDIENCE=your-api-identifier
AUTH0_CLIENT_ID=your-resource-server-client-id
AUTH0_CLIENT_SECRET=your-resource-server-client-secret
OPENAI_API_KEY=your-openai-api-key
PORT=3001
```

### Configure the SPA for step-up authorization

Unlike the <a href="/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-next-js" target="_blank">Next.js example</a>, which uses refresh tokens, this React SPA approach uses **access tokens** for token exchange with Token Vault. The SPA handles step-up authorization using Auth0 SPA SDK's `loginWithPopup()` method to display the consent screen and allow the user to grant additional permissions.

Create `client/src/components/TokenVaultConsentPopup.tsx`:

```tsx client/src/components/TokenVaultConsentPopup.tsx wrap lines
import { getAuth0Client } from "../lib/auth0";
import { Button } from "./ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";

import type { Auth0InterruptionUI } from "@auth0/ai-vercel/react";
interface TokenVaultConsentPopupProps {
  interrupt: Auth0InterruptionUI;
}

export function TokenVaultConsentPopup({
  interrupt,
}: TokenVaultConsentPopupProps) {
  const [isLoading, setIsLoading] = useState(false);

  const { connection, requiredScopes, resume } = interrupt;

  // Use Auth0 SPA SDK to request additional connection/scopes
  const startFederatedLogin = useCallback(async () => {
    try {
      setIsLoading(true);

      // Filter out empty scopes
      const validScopes = requiredScopes.filter(
        (scope: string) => scope && scope.trim() !== ""
      );

      const auth0Client = getAuth0Client();

      // Use getTokenWithPopup for step-up authorization to request additional scopes
      await auth0Client.getTokenWithPopup({
        authorizationParams: {
          prompt: "consent", // Required for Google Calendar scopes
          connection: connection, // e.g., "google-oauth2"
          connection_scope: validScopes.join(" "), // Google-specific scopes
          access_type: "offline",
        },
      });

      // The Auth0 client should automatically use the new token, but we should trigger
      // a refresh to ensure the latest token is cached.
      await auth0Client.getTokenSilently();

      setIsLoading(false);

      // Resume the interrupted tool after successful authorization
      if (typeof resume === "function") {
        resume();
      }
    } catch (error) {
      setIsLoading(false);

      if (typeof resume === "function") {
        resume();
      }
    }
  }, [connection, requiredScopes, resume]);

  if (isLoading) {
    return (
      <Card className="w-full">
        <CardContent className="flex items-center justify-center p-6">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-2"></div>
            <p className="text-sm text-muted-foreground">
              Connecting to {connection.replace("-", " ")}...
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full border-yellow-200 bg-yellow-50">
      <CardHeader>
        <CardTitle className="text-lg text-yellow-800">
          Authorization Required
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-yellow-700">
          To access your {connection.replace("-", " ")} data, you need to authorize this application.
        </p>
        <p className="text-xs text-yellow-600">
          Required permissions:{" "}
          {requiredScopes
            .filter((scope: string) => scope && scope.trim() !== "")
            .join(", ")}
        </p>
        <Button onClick={startFederatedLogin} className="w-full">
          Authorize {connection.replace("-", " ")}
        </Button>
      </CardContent>
    </Card>
  );
}
```

#### Create tools with integrated Token Vault support for retrieving third-party access tokens

Next, create a tool that accesses Token Vault to fetch a Google access token to list all the Google Calendars a user has access to.

Create `server/src/lib/tools/listUserCalendars.ts`:

```ts server/src/lib/tools/listUserCalendars.ts wrap lines
import { tool } from "ai";
import { google } from "googleapis";
import { z } from "zod";

import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";

import type { ToolWrapper } from "@auth0/ai-vercel";

/**
 * Tool: listUserCalendars
 * Lists all calendars the user has access to.
 * Uses the enhanced @auth0/ai SDK for token exchange with Token Vault.
 */
export const createListUserCalendarsTool = (
  googleCalendarWrapper: ToolWrapper
) =>
  googleCalendarWrapper(
    tool({
      description: "List all calendars the user has access to",
      inputSchema: z.object({}),
      execute: async () => {
        // Get the access token from Token Vault using the enhanced SDK
        const token = getAccessTokenFromTokenVault();

        const calendar = google.calendar("v3");
        const auth = new google.auth.OAuth2();
        auth.setCredentials({ access_token: token });

        const res = await calendar.calendarList.list({ auth });

        const calendars =
          res.data.items?.map((cal) => ({
            id: cal.id,
            name: cal.summary,
            accessRole: cal.accessRole,
          })) ?? [];

        return calendars;
      },
    })
  );
```

#### Configure the API server with Google connection wrapper for calendar tools

Instantiate an instance of `Auth0AI` with a pre-configured resource client. Then, create a wrapper for the Google Calendar Tool that sets up the token exchange. This allows you to directly exchange an Auth0 access token for a Google access token from Token Vault with the necessary Calendar scopes.

Create `server/src/lib/auth0.ts`:

```ts server/src/lib/auth0.ts wrap lines
import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
import { Auth0AI } from "@auth0/ai-vercel";

import type { Context } from "hono";

import type { ToolWrapper } from "@auth0/ai-vercel";
// Create an Auth0AI instance configured with reserver client credentials
const auth0AI = new Auth0AI({
  auth0: {
    domain: process.env.AUTH0_DOMAIN!,
    clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!, // Resource server client ID for token exchange
    clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!, // Resource server client secret
  },
});

// Enhanced token exchange with Token Vault, setup with access token support
// This demonstrates the new API pattern where access tokens can be used directly
export const createGoogleCalendarTool = (c: Context): ToolWrapper => {
  const accessToken = c.get("auth")?.token;
  if (!accessToken) {
    throw new Error("Access token not available in auth context");
  }
  return auth0AI.withTokenVault({
    accessToken: async () => accessToken,
    subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
    connection: process.env.GOOGLE_CONNECTION_NAME || "google-oauth2",
    scopes: [
      "https://www.googleapis.com/auth/calendar.calendarlist.readonly", // Read-only access to calendar list
      "https://www.googleapis.com/auth/calendar.events.readonly", // Read-only access to events
    ],
  });
};
```

### Create Hono API Chat API server with interrupt handling

Create an AI-powered chat server using Hono, the Auth0 AI SDK, and the Vercel AI SDK that allows a user to chat with an AI assistant that can access their Google Calendar.

The Auth0 AI SDK's `withInterruptions()` function wraps the Vercel AI SDK's `streamText()` function, enabling the Hono server to handle interrupts, which are special responses from Token Vault. An interrupt is sent if a tool call requires a new or updated access token, for example, if a user needs to re-authenticate or a new permission is needed.

Create `server/src/index.ts`:

```ts server/src/index.ts wrap lines
import {
  convertToModelMessages,
  createUIMessageStream,
  createUIMessageStreamResponse,
  generateId,
  streamText,
} from "ai";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { decodeJwt } from "jose";

import { openai } from "@ai-sdk/openai";
import { setAIContext } from "@auth0/ai-vercel";
import { errorSerializer, withInterruptions } from "@auth0/ai-vercel/interrupts";
import { serve } from "@hono/node-server";

import { createGoogleCalendarTool } from "./lib/auth";
import { createListUserCalendarsTool } from "./lib/tools/listUserCalendars";
import { jwtAuthMiddleware } from "./middleware/auth";

import type { ApiResponse } from "shared/dist";

export const app = new Hono().post("/chat", jwtAuthMiddleware(), async (c) => {
    // auth middleware adds the auth context to the request
    const auth = c.get("auth");

    const { messages: requestMessages } = await c.req.json();

    // Generate a thread ID for this conversation
    const threadID = generateId();

    // Set AI context for the tools to access
    setAIContext({ threadID });

    // Create the Google Calendar wrapper with auth context
    const googleCalendarWrapper = createGoogleCalendarTool(c);

    // Create tools with the auth context
    const listUserCalendars = createListUserCalendarsTool(googleCalendarWrapper);

    // Use the messages from the request directly
    const tools = { listUserCalendars };

    // note: you can see more examples of Hono API consumption with AI SDK here:
    // https://ai-sdk.dev/cookbook/api-servers/hono?utm_source=chatgpt.com#hono

     const modelMessages = convertToModelMessages(requestMessages);

    const stream = createUIMessageStream({
      originalMessages: requestMessages,
      execute: withInterruptions(
        async ({ writer }) => {
          const result = streamText({
            model: openai("gpt-4o-mini"),
            system:
              "You are a helpful calendar assistant! You can help users with their calendar events and schedules. Keep your responses concise and helpful. Always format your responses as plain text. Do not use markdown formatting like **bold**, ##headers, or -bullet points. Use simple text formatting with line breaks and indentation only.",
            messages: modelMessages,
            tools,

            onFinish: (output) => {
              if (output.finishReason === "tool-calls") {
                const lastMessage = output.content[output.content.length - 1];
                if (lastMessage?.type === "tool-error") {
                  const { toolName, toolCallId, error, input } = lastMessage;
                  const serializableError = {
                    cause: error,
                    toolCallId: toolCallId,
                    toolName: toolName,
                    toolArgs: input,
                  };

                  throw serializableError;
                }
              }
            },
          });
          writer.merge(
            result.toUIMessageStream({
              sendReasoning: true,
            })
          );
        },
        {
          messages: requestMessages,
          tools,
        }
      ),
      onError: errorSerializer((err) => {
        console.error("react-hono-ai-sdk route: stream error", err);
        return "Oops, an error occurred!";
      }),
    });

    return createUIMessageStreamResponse({ stream });
  });

// Start the server for Node.js
const port = Number(process.env.PORT) || 3000;

console.log(`🚀 Server starting on port ${port}`);
serve({ fetch: app.fetch, port });

console.log(`✅ Server running on http://localhost:${port}`);
```

### Implement interrupt handling in React

Update your chat component to handle step-up auth interrupts:

```tsx client/src/components/Chat.tsx wrap lines highlight={3,5,12,18-33,49-65, 124-126}
import {
  DefaultChatTransport,
  lastAssistantMessageIsCompleteWithToolCalls,
} from "ai";
import { Loader2, Send, Trash2 } from "lucide-react";
import { useState } from "react";

import { useChat } from "@ai-sdk/react";
import { useInterruptions } from "@auth0/ai-vercel/react";
import { TokenVaultInterrupt } from "@auth0/ai/interrupts";

import { useAuth0 } from "../hooks/useAuth0";
import { TokenVaultConsentPopup } from "./TokenVaultConsentPopup";
import { Button } from "./ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";
import { Input } from "./ui/input";

import type { TextUIPart, UIMessage } from "ai";
const SERVER_URL = import.meta.env.VITE_SERVER_URL || "http://localhost:3000";

export function Chat() {
  const { getToken } = useAuth0();
  const [input, setInput] = useState<string>("");
  const chatHelpers = useInterruptions((errorHandler) =>
    useChat({
      transport: new DefaultChatTransport({
        api: `${SERVER_URL}/chat`,
        fetch: (async (url: string | URL | Request, init?: RequestInit) => {
          const token = await getToken();
          return fetch(url, {
            ...init,
            headers: {
              "Content-Type": "application/json",
              ...init?.headers,
              Authorization: `Bearer ${token}`,
            },
          });
        }) as typeof fetch,
      }),
      onError: errorHandler((error) => {
        console.error("Chat error:", error);
      }),
      sendAutomaticallyWhen: lastAssistantMessageIsCompleteWithToolCalls,
    })
  );

  const { messages, sendMessage, status, error, setMessages, toolInterrupt } =
    chatHelpers;

  const clearMessages = () => {
    setMessages([]);
  };

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-lg font-semibold">
          Calendar Assistant
        </CardTitle>
        {messages.length > 0 && (
          <Button
            variant="outline"
            size="sm"
            onClick={clearMessages}
            className="h-8 w-8 p-0"
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        )}
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Messages */}
        <div className="space-y-4 max-h-96 overflow-y-auto">
          {messages.length === 0 ? (
            <div className="text-center text-muted-foreground py-8">
              <p className="text-sm">Ask me about your calendar events!</p>
              <p className="text-xs mt-1">
                Try: "What meetings do I have today?" or "Show me my upcoming
                events"
              </p>
            </div>
          ) : (
            messages.map((message) => (
              <MessageBubble key={message.id} message={message} />
            ))
          )}
          {status === "streaming" && (
            <div className="flex justify-start">
              <div className="bg-muted rounded-lg px-3 py-2 max-w-[80%] flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span className="text-sm text-muted-foreground">
                  Thinking...
                </span>
              </div>
            </div>
          )}
        </div>

        {/* Error message - hide if it's an Auth0 interrupt (we show the popup instead) */}
        {error && !TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
          <div className="bg-destructive/10 text-destructive text-sm p-3 rounded-lg">
            Error: {error.message}
          </div>
        )}

        {/* Step-Up Auth Interrupt Handling */}
        {TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
          <TokenVaultConsentPopup interrupt={toolInterrupt} />
        )}

        {/* Input form */}
        <form
          onSubmit={(e) => {
            e.preventDefault();
            sendMessage({ text: input });
            setInput("");
          }}
          className="flex gap-2"
        >
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask about your calendar..."
            disabled={status === "streaming"}
            className="flex-1"
          />
          <Button
            className="h-10"
            type="submit"
            disabled={status === "streaming" || !input.trim()}
          >
            <Send className="h-4 w-4" />
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

function MessageBubble({ message }: { message: UIMessage }) {
  const isUser = message.role === "user";

  // Get all text content from the message parts
  const textContent = message.parts
    .filter((part) => part.type === "text")
    .map((part) => (part as TextUIPart).text)
    .join("");

  return (
    <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
      <div
        className={`rounded-lg px-3 py-2 max-w-[80%] ${
          isUser ? "bg-primary text-primary-foreground" : "bg-muted"
        }`}
      >
        <p className="text-sm whitespace-pre-wrap">{textContent}</p>
      </div>
    </div>
  );
}
```

### Test your application

1. Start the client and server using Turbo: `npm run dev`.
2. Navigate to `http://localhost:5173`.
3. Log in with Google and ask your AI agent about your calendar.

The application will automatically prompt for additional calendar permissions when needed using Auth0's step-up authorization flow.

That's it! You've successfully integrated Token Vault with access tokens into your React SPA + Vercel AI application.

Explore [the example app on GitHub](https://github.com/auth0/auth0-ai-js/tree/main/examples/calling-apis/spa-with-backend-api/react-hono-ai-sdk).
