import { Prerequisites } from "/snippets/get-started/prerequisites/call-others-api.jsx";
import { AccountAndAppSteps } from "/snippets/get-started/prerequisites/account-app-steps.jsx";

<Prerequisites
  createAuth0ApplicationStep={{
    applicationType: "Single Page Web Applications",
    callbackUrl: "http://localhost:5173",
    logoutUrl: "http://localhost:5173",
    allowedWebOrigins: "http://localhost:5173",
  }}
  refreshTokenGrantStep={{
    applicationName: "Single Page Web Application",
  }}
  createAuth0ApiStep={{}}
  createResourceServerClientStep={{}}
  tokenExchangeGrantStep={{
    applicationName: "Single Page Web Application",
  }}
/>

### Key features of this React SPA + LangGraph.js example

This integration provides a robust, secure foundation for authenticating users and enabling AI agents to act on their behalf using third-party APIs. Here are some key features of this example:

1. **Modern Toolset**: Uses a modern stack with React, Vite, LangGraph.js, and the Auth0 AI SDK to create an interactive chat interface that integrates with Google Calendar and the [LangGraph.js ReAct Memory Agent](https://github.com/langchain-ai/memory-agent-js).
2. **Client-Side Authorization**: Client login and step-up authorization are handled client-side using `@auth0/auth0-spa-js`. No backend proxy required, and client streaming calls are made directly to the LangGraph API.
3. **Token Vault**: Token Vault performs token exchanges and securely manages tokens, allowing seamless, user-approved third-party API access to AI agents and finely scoped authorization for each API.
4. **Interrupt Handling**: The React client manages tool access errors and step-up authorization using interrupts that trigger a pop-up for re-authorization.
5. **LangGraph Custom Auth**: The auth integration with LangGraph.js leverages LangGraph's [custom auth support](https://docs.langchain.com/langgraph-platform/custom-auth), ensuring secure and authenticated API calls both with the LangGraph Platform and self-hosted deployments.

<Tabs>
  <Tab title="Use sample app(recommended)">

### Clone sample app
Clone this sample app from the [Auth0 AI samples](https://github.com/auth0-samples/auth0-ai-samples.git) repository:

```bash wrap lines
git clone https://github.com/auth0-samples/auth0-ai-samples.git
cd auth0-ai-samples/calling-apis-on-users-behalf/others-api/langchain-react-spa-js
```

The project is divided into two parts:
- `apps/agents`: contains the backend LangGraph API server using LangGraph CLI, LangGraph SDKs, and Auth0 AI SDKs.
- `apps/web`: contains the frontend code for the web app, written in React as a Vite SPA.

### Install dependencies

To install all the frontend and backend dependencies, navigate to the root directory of the project and run the following command:
```bash wrap lines
# Install all frontend & backend dependencies from the root directory of the project.
npm install
```

### Create the environment files

Add separate `.env` files with environment variables for the backend LangGraph API server and the frontend.

#### Backend LangGraph API Server (apps/agents/.env)

Copy `apps/agents/.env.example` to `apps/agents/.env` and update the values:
```bash .env wrap lines
# LLM Provider (choose one)
ANTHROPIC_API_KEY=your-anthropic-key
OPENAI_API_KEY=your-openai-key

# Auth0 Configuration
AUTH0_DOMAIN=your-auth0-domain.auth0.com
AUTH0_AUDIENCE=your-api-identifier
AUTH0_CUSTOM_API_CLIENT_ID=your-custom-api-client-id
AUTH0_CUSTOM_API_CLIENT_SECRET=your-custom-api-client-secret
```

#### Frontend (apps/web/.env)

Copy `apps/web/.env.example` to `apps/web/.env` and update the values:
```bash .env wrap lines
VITE_AUTH0_DOMAIN=your-auth0-domain.auth0.com
VITE_AUTH0_CLIENT_ID=your-spa-client-id
VITE_AUTH0_AUDIENCE=your-api-identifier
VITE_LANGGRAPH_API_URL=http://localhost:2024
```

### Run your application

1. Start the Vite frontend and LangGraph API server using Turbo: `npm run dev`.
2. Navigate to `http://localhost:5173`.
3. Hit the **Sign In with Auth0** button and log in to your application with Google credentials on the Universal Login screen.
4. Enter the Agent Chat form options for the `Deployment URL` (e.g., `http://localhost:2024` or your LangGraph Platform Deployment's Resource URL), and the `Graph ID` of the agent to use (e.g., `memory_agent`), and hit the **Continue** button.
5. Ask your AI agent about your calendar with a prompt, such as "Can you check my calendar for availability tomorrow at 3pm?".

The application will automatically prompt for additional calendar permissions when needed using Auth0's step-up authorization flow.

That's it! You've successfully set up and run the React SPA + LangGraph API sample app.

  </Tab>
  <Tab title="Integrate into your app">

### Install packages

Ensure you have installed the following client and server dependencies in your project:

**Frontend client dependencies:**

- `@auth0/auth0-spa-js`: Auth0 SPA SDK for client-side authentication
- `@auth0/ai`: [Auth0 AI SDK](https://github.com/auth0-lab/auth0-ai-js/tree/main/packages/ai) built for GenAI applications
- `@langchain/core`: contains the core LangChain abstractions and schemas for LangChain.js
- `@langchain/langgraph`, `@langchain/langgraph-api`, `@langchain/langgraph-sdk`: Core [LangGraph.js SDK](https://github.com/langchain-ai/langgraphjs/tree/main) for interacting with LangGraph APIs

**Backend LangGraph API Server dependencies:**

- `@langchain/core`: contains the core LangChain abstractions and schemas for LangChain.js
- `@langchain/langgraph`, `@langchain/langgraph-sdk`: Core [LangGraph.js SDK](https://github.com/langchain-ai/langgraphjs/tree/main) libraries for constructing a State Graph and defining LangGraph tools.
- `@langchain/openai`: used when interfacing with the OpenAI series of models from LangGraph agents (alternatively, you can use `@langchain/anthropic` for accessing Anthropic models).
- `@langchain/langgraph-cli`: the [LangGraph CLI](https://docs.langchain.com/langgraph-platform/cli) is used for self-hosted LangGraph API server deployments or commonly as a local LangGraph API server during development
- `@auth0/ai`, `@auth0/ai-langchain`: [Auth0 AI SDK](https://github.com/auth0-lab/auth0-ai-js/tree/main/packages/ai)'s built for interfacing with Token Vault and your LangGraph API tools.
- `googleapis`: Node.js client for Google APIs
- `jose`: JavaScript Object Signing and Encryption library for JWT verification


### Update the environment files

Add separate `.env` files with environment variables for the client and the LangGraph API server.

#### Backend LangGraph API Server (server/.env)

In the backend directory of your project, add the following variables to your environment file:
```bash .env wrap lines
# LLM Provider (choose one)
ANTHROPIC_API_KEY=your-anthropic-key
OPENAI_API_KEY=your-openai-key

# Auth0 Configuration
AUTH0_DOMAIN=your-auth0-domain.auth0.com
AUTH0_AUDIENCE=your-api-identifier
AUTH0_CUSTOM_API_CLIENT_ID=your-custom-api-client-id
AUTH0_CUSTOM_API_CLIENT_SECRET=your-custom-api-client-secret
```

In the frontend directory of your project, add the following variables to your environment file:

Copy `apps/web/.env.example` to `apps/web/.env` and update the values:
```bash .env wrap lines
VITE_AUTH0_DOMAIN=your-auth0-domain.auth0.com
VITE_AUTH0_CLIENT_ID=your-spa-client-id
VITE_AUTH0_AUDIENCE=your-api-identifier
VITE_LANGGRAPH_API_URL=http://localhost:2024
```

### Frontend React SPA with Vite Auth0 Implementation

#### Auth0 Client Configuration

Create the `src/lib/auth0.ts` file to set up the Auth0 SPA JS client:

```tsx src/lib/auth0.ts wrap lines
import { Auth0Client, createAuth0Client, User } from "@auth0/auth0-spa-js";

// Auth0 configuration
const AUTH0_DOMAIN = import.meta.env.VITE_AUTH0_DOMAIN;
const AUTH0_CLIENT_ID = import.meta.env.VITE_AUTH0_CLIENT_ID;
const AUTH0_AUDIENCE = import.meta.env.VITE_AUTH0_AUDIENCE;

if (!AUTH0_DOMAIN || !AUTH0_CLIENT_ID) {
  throw new Error(
    "Missing Auth0 configuration. Please check your environment variables.",
  );
}

let auth0Client: Auth0Client | null = null;

export const initAuth0 = async (): Promise<Auth0Client> => {
  if (auth0Client) {
    return auth0Client;
  }

  auth0Client = await createAuth0Client({
    domain: AUTH0_DOMAIN,
    clientId: AUTH0_CLIENT_ID,
    authorizationParams: {
      redirect_uri: window.location.origin,
      audience: AUTH0_AUDIENCE,
      scope: "openid profile email", // Basic scopes
    },
  });

  return auth0Client;
};

export const getAuth0Client = (): Auth0Client => {
  if (!auth0Client) {
    throw new Error("Auth0 client not initialized. Call initAuth0() first.");
  }
  return auth0Client;
};

export const login = async (targetUrl?: string) => {
  const client = getAuth0Client();
  await client.loginWithRedirect({
    authorizationParams: {
      redirect_uri: window.location.origin,
    },
    appState: targetUrl ? { targetUrl } : undefined,
  });
};

export const logout = async () => {
  const client = getAuth0Client();
  await client.logout({
    logoutParams: {
      returnTo: window.location.origin,
    },
  });
};

export const getToken = async (): Promise<string> => {
  const client = getAuth0Client();
  return await client.getTokenSilently();
};

export const isAuthenticated = async (): Promise<boolean> => {
  const client = getAuth0Client();
  return await client.isAuthenticated();
};

export const getUser = async (): Promise<User | undefined> => {
  const client = getAuth0Client();
  return await client.getUser();
};
```

#### React Context Provider Setup

Create the `src/providers/Auth0.tsx` file to configure the React context provider for Auth0:
```tsx src/providers/Auth0.tsx wrap lines
import React, { ReactNode, useEffect, useRef, useState } from "react";
import { Auth0Context, Auth0ContextType } from "@/contexts/auth0-context";
import {
  getToken,
  getUser,
  initAuth0,
  isAuthenticated,
  login,
  logout,
} from "@/lib/auth0";
import { User } from "@auth0/auth0-spa-js";

interface Auth0ProviderProps {
  children: ReactNode;
}

export const Auth0Provider: React.FC<Auth0ProviderProps> = ({ children }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticatedState, setIsAuthenticatedState] = useState(false);
  const [user, setUser] = useState<User | null>(null);
  const [error, setError] = useState<string | null>(null);
  const initRef = useRef(false);

  useEffect(() => {
    // Prevent double execution in React Strict Mode
    if (initRef.current) return;
    initRef.current = true;

    const initializeAuth0 = async () => {
      try {
        setIsLoading(true);
        await initAuth0();

        // Handle redirect callback
        if (
          window.location.search.includes("code=") &&
          window.location.search.includes("state=")
        ) {
          const client = await initAuth0();
          await client.handleRedirectCallback();
          window.history.replaceState(
            {},
            document.title,
            window.location.pathname,
          );
        }

        const authenticated = await isAuthenticated();
        setIsAuthenticatedState(authenticated);

        if (authenticated) {
          const userData = await getUser();
          setUser(userData as User);
        }
      } catch (err) {
        console.error("Auth0 initialization error:", err);
        setError(err instanceof Error ? err.message : "Authentication error");
      } finally {
        setIsLoading(false);
      }
    };

    initializeAuth0();
  }, []);

  const contextValue: Auth0ContextType = {
    isLoading,
    isAuthenticated: isAuthenticatedState,
    user,
    error,
    login: async (targetUrl?: string) => {
      try {
        setError(null);
        await login(targetUrl);
      } catch (err) {
        console.error("Login error:", err);
        setError(err instanceof Error ? err.message : "Login failed");
      }
    },
    logout: async () => {
      try {
        setError(null);
        await logout();
        setIsAuthenticatedState(false);
        setUser(null);
      } catch (err) {
        console.error("Logout error:", err);
        setError(err instanceof Error ? err.message : "Logout failed");
      }
    },
    getToken,
  };

  return (
    <Auth0Context.Provider value={contextValue}>
      {children}
    </Auth0Context.Provider>
  );
};
```

#### Wrap the React Application with the Auth0 Provider

In `src/main.tsx`, wrap your application with the `Auth0Provider`:

```tsx src/main.tsx wrap lines
import "./index.css";
import { NuqsAdapter } from "nuqs/adapters/react-router/v6";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { Toaster } from "@/components/ui/sonner";
import App from "./App.tsx";
import { Auth0Provider } from "./providers/Auth0.tsx";
import { StreamProvider } from "./providers/Stream.tsx";
import { ThreadProvider } from "./providers/Thread.tsx";

createRoot(document.getElementById("root")!).render(
  <BrowserRouter>
    <NuqsAdapter>
      <Auth0Provider>
        <ThreadProvider>
          <StreamProvider>
            <App />
          </StreamProvider>
        </ThreadProvider>
      </Auth0Provider>
      <Toaster />
    </NuqsAdapter>
  </BrowserRouter>,
);
```

#### Client-Side Chat Component Integration

Use the Auth0 context with the LangGraph's streaming capabilities in your Chat components:

```tsx src/components/Chat.tsx wrap lines
import { useAuth0 } from "@/hooks/useAuth0";
import { useStream } from "@langchain/langgraph-sdk/react";

export default function ChatInterface() {
  const { user, isLoading, isAuthenticated, login, logout, getToken } = useAuth0();
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const apiUrl = import.meta.env.VITE_LANGGRAPH_API_URL || "http://localhost:2024";

  // Get access token when authenticated
  useEffect(() => {
    if (isAuthenticated) {
      getToken().then(setAccessToken).catch(console.error);
    }
  }, [isAuthenticated, getToken]);

  // Initialize LangGraph stream with Auth0 token
  const stream = useStream({
    apiUrl,
    assistantId: "memory_agent",
    defaultHeaders: accessToken
      ? { Authorization: `Bearer ${accessToken}` }
      : undefined,
  });

  const sendMessage = (content: string) => {
    if (!isAuthenticated || !content.trim()) return;

    stream.submit({
      messages: [{
        type: "human",
        content,
        // User context available in agent workflows
        metadata: { userId: user?.sub }
      }]
    });
  };

  if (isLoading) return <div>Loading...</div>;

  if (!isAuthenticated) {
    return (
      <div>
        <h1>Welcome to LangGraph Chat</h1>
        <button onClick={() => login()}>Login with Auth0</button>
      </div>
    );
  }

  return (
    <div>
      <header>
        <span>Welcome, {user?.name}</span>
        <button onClick={() => logout()}>Logout</button>
      </header>

      <div className="messages">
        {stream.messages?.map((msg, i) => (
          <div key={i}>{msg.content}</div>
        ))}
      </div>

      <form onSubmit={(e) => {
        e.preventDefault();
        const input = new FormData(e.target).get('message');
        sendMessage(input as string);
        e.target.reset();
      }}>
        <input name="message" placeholder="Type a message..." />
        <button type="submit" disabled={stream.isLoading}>
          Send
        </button>
      </form>
    </div>
  );
}
```

#### Step-up Authorization with Auth0 Interrupts

The Auth0 AI and Auth0 SPA JS SDKs include sophisticated interrupt handling for step-up authorization scenarios, particularly when accessing third-party APIs through Auth0's Token Vault. This enables agents to request additional permissions dynamically during conversations.

##### Implementing Interrupts

When an agent tool requires access to a third-party service (like Google Calendar) that the user hasn't previously authorized, LangGraph can raise a `FederatedConnectionInterrupt`. The frontend handles these interrupts by displaying an authorization pop-up.

1. Interrupt Detection in Chat Interface

In your chat message rendering logic, check for Auth0 interrupts:
```tsx src/components/Chat.tsx wrap lines
// In your chat message component
{threadInterrupt &&
  Auth0Interrupt.isInterrupt(threadInterrupt.value) &&
  isLastMessage ? (
    <Auth0InterruptHandler
      interrupt={threadInterrupt.value}
      onResume={() => thread.submit(null)}
    />
  ) : null}
```

2. Auth0 Interrupt Handler Component

Create `src/components/Auth0InterruptHandler.tsx` to manage the interrupt UI:

```tsx src/components/Auth0InterruptHandler.tsx wrap lines
import { Auth0Interrupt } from "@auth0/ai/interrupts";
import { FederatedConnectionInterrupt } from "@auth0/ai/interrupts";
import { FederatedConnectionPopup } from "./FederatedConnectionPopup";

interface Auth0InterruptHandlerProps {
  interrupt: Auth0Interrupt;
  onResume: () => void;
}

export function Auth0InterruptHandler({
  interrupt,
  onResume,
}: Auth0InterruptHandlerProps) {
  // Handle FederatedConnectionInterrupt
  if (FederatedConnectionInterrupt.isInterrupt(interrupt)) {
    return (
      <FederatedConnectionPopup
        interrupt={interrupt as FederatedConnectionInterrupt}
        onResume={onResume}
      />
    );
  }

  return null;
}
```

3. Federated Connection Popup

The `FederatedConnectionPopup` component handles the OAuth flow for third-party connections.

Create `src/components/FederatedConnectionPopup.tsx` to display the authorization prompt:

```tsx src/components/FederatedConnectionPopup.tsx wrap lines
// apps/web/src/components/auth0/FederatedConnectionPopup.tsx
import { useState } from "react";
import { FederatedConnectionInterrupt } from "@auth0/ai/interrupts";
import { useAuth0 } from "@/hooks/useAuth0";

interface FederatedConnectionPopupProps {
  interrupt: FederatedConnectionInterrupt;
  onResume: () => void;
}

export function FederatedConnectionPopup({
  interrupt,
  onResume,
}: FederatedConnectionPopupProps) {
  const [isConnecting, setIsConnecting] = useState(false);
  const { getToken } = useAuth0();

  const handleConnect = async () => {
    try {
      setIsConnecting(true);

      // Get the current access token
      const accessToken = await getToken();

      // Construct Auth0 authorization URL with additional scopes
      const authUrl = new URL(`https://${process.env.VITE_AUTH0_DOMAIN}/authorize`);
      authUrl.searchParams.set('client_id', process.env.VITE_AUTH0_CLIENT_ID!);
      authUrl.searchParams.set('response_type', 'code');
      authUrl.searchParams.set('redirect_uri', window.location.origin);
      authUrl.searchParams.set('scope', interrupt.scopes.join(' '));
      authUrl.searchParams.set('connection', interrupt.connection);
      authUrl.searchParams.set('state', 'step-up-auth');

      // Open popup window for authorization
      const popup = window.open(
        authUrl.toString(),
        'auth-popup',
        'width=500,height=600,scrollbars=yes'
      );

      // Listen for popup completion
      const checkClosed = setInterval(() => {
        if (popup?.closed) {
          clearInterval(checkClosed);
          setIsConnecting(false);
          // Resume the conversation after authorization
          onResume();
        }
      }, 1000);

    } catch (error) {
      console.error('Connection error:', error);
      setIsConnecting(false);
    }
  };

  return (
    <div className="border rounded-lg p-4 bg-blue-50">
      <h3 className="font-semibold mb-2">Additional Permission Required</h3>
      <p className="text-sm text-gray-600 mb-4">
        To continue, this agent needs access to your {interrupt.connection} account.
      </p>
      <div className="flex gap-2">
        <button
          onClick={handleConnect}
          disabled={isConnecting}
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {isConnecting ? 'Connecting...' : `Connect ${interrupt.connection}`}
        </button>
        <button
          onClick={onResume}
          className="border border-gray-300 px-4 py-2 rounded hover:bg-gray-50"
        >
          Skip
        </button>
      </div>
    </div>
  );
}
```

You've now implemented step-up authorization handling in your React SPA using Auth0 interrupts!

Now when step-up authorization is required, the user will see a prompt in the chat window asking them to authorize.

### Backend LangGraph API Implementation with Auth0 AI SDK Integration

Next, set up the backend LangGraph API server to define the agent and tools, integrating Auth0 AI SDKs for secure third-party API access.

#### LangGraph Custom Authentication

LangGraph supports custom authentication to validate incoming tokens and extract user context. This enables user-specific authorization and auditing within your LangGraph applications.

Configure your LangGraph deployment to accept Auth0 tokens by setting up custom authentication. See the [LangGraph Custom Auth documentation](https://docs.langchain.com/langgraph-platform/custom-auth) for detailed setup.

Example Custom Auth Handler:
```ts src/auth.ts wrap lines
import { createRemoteJWKSet, jwtVerify } from "jose";
const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

// JWKS endpoint for Auth0
const JWKS = createRemoteJWKSet(
  new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
);

const auth = new Auth();

auth.authenticate(async (request: Request) => {
  const authHeader = request.headers.get("Authorization");
  const xApiKeyHeader = request.headers.get("x-api-key");

  // LangGraph Platform converts Authorization to x-api-key automatically
  let token = xApiKeyHeader ?? authHeader;

  if (token && token.startsWith("Bearer ")) {
    token = token.substring(7);
  }

  const { payload } = await jwtVerify(token, JWKS, {
    issuer: `https://${AUTH0_DOMAIN}/`,
    audience: AUTH0_AUDIENCE,
  });

  return {
    identity: payload.sub!,
    email: payload.email as string,
    permissions: typeof payload.scope === "string" ? payload.scope.split(" ") : [],
    auth_type: "auth0",
    getRawAccessToken: () => token,
    ...payload,
  };
});

export { auth as authHandler };
```

Then you can reference the custom auth handler in your `langgraph.json` file:

```json langgraph.json wrap lines
{
  "node_version": "20",
  "dependencies": ["."],
  "graphs": {
    "memory_agent": "./src/memory-agent/graph.ts:graph"
  },
  "auth": {
    "path": "./src/auth.ts:authHandler"
  },
  "env": ".env"
}
```

#### Token Vault Integration with Agent Tools

Create the Auth0 AI `withTokenForConnection` wrapper to securely fetch access tokens from Token Vault for your tools:

```ts src/auth0-ai.ts wrap lines
import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
import { Auth0AI } from "@auth0/ai-langchain";

const auth0AI = new Auth0AI({
  auth0: {
    domain: process.env.AUTH0_DOMAIN!,
    clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!,
    clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!,
  },
});

export const withGoogleCalendar = auth0AI.withTokenForConnection({
  connection: "google-oauth2",
  scopes: ["https://www.googleapis.com/auth/calendar.freebusy"],
  accessToken: async (_, config) => {
    return config.configurable?.langgraph_auth_user?.getRawAccessToken();
  },
  subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
});
```

Then reference the Auth0 Token Vault wrapper above in the tool's definition:

```ts src/tools/google-calendar.ts wrap lines
import { addHours, formatISO } from "date-fns";
import { GaxiosError } from "gaxios";
import { google } from "googleapis";

import { getAccessTokenForConnection } from "@auth0/ai-langchain";
import { FederatedConnectionError } from "@auth0/ai/interrupts";
import { tool } from "@langchain/core/tools";

import { withGoogleCalendar } from "../../auth0-ai";

export const checkUsersCalendar = withGoogleCalendar(
  tool(
    async ({ date }) => {
      try {
        const accessToken = getAccessTokenForConnection();

        const calendar = google.calendar("v3");
        const auth = new google.auth.OAuth2();

        auth.setCredentials({
          access_token: accessToken,
        });

        const response = await calendar.freebusy.query({
          auth,
          requestBody: {
            timeMin: formatISO(date),
            timeMax: addHours(date, 1).toISOString(),
            timeZone: "UTC",
            items: [{ id: "primary" }],
          },
        });

        return {
          available: response.data?.calendars?.primary?.busy?.length === 0,
        };
      } catch (err) {
        if (err instanceof GaxiosError && err.status === 401) {
          throw new FederatedConnectionError(
            `Authorization required to access the Federated Connection`
          );
        }
        throw err;
      }
    },
  )
);
```

Great job! You've now set up the backend LangGraph API server with Auth0 AI SDK integration for secure third-party API access with your LangGraph tools.

### Test your application
Start your application. If you are already logged in, make sure to log out and log back in using Google. Then, ask your AI agent to list the upcoming events in your Google Calendar!

That's it! You successfully integrated third-party API access using Token Vault into your React SPA + LangGraph.js project.

### View a complete example
Want to see how it all comes together? Explore or clone the fully implemented sample application on [GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/calling-apis-on-users-behalf/others-api/langchain-react-spa-js).
  </Tab>
</Tabs>
