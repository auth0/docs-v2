---
title: "Core Concepts"
sidebarTitle: "Fundamentals"
---

## What is the Model Context Protocol (MCP)?

[MCP is an open standard](https://modelcontextprotocol.io), developed by Anthropic, that specifies a common interface for AI agents and Large Language Models (LLMs) to communicate with tools. It's designed to solve the problem of tool discovery and interaction in a standardized way.

MCP supports networked environments using HTTP and Server-Sent Events (SSE), allowing an AI agent to interact with tools hosted on remote servers across the internet.

## Why use Auth0 for MCP?

MCP offers practical advantages: Standardized interfaces for LLMs to interact with and LLM-facing tools with rich context and metadata.

Auth0 allows your users to securely interact with trusted agents without worrying about LLMs gaining access to sensitive information like access tokens: Auth0 enforces scoped, identity-bound, least-privilege access for AI Agents, both first-party and third-party APIs.

Auth0 manages consent flows and per-client permissions and secures credentials via Token Vault and Token Exchange while making it possible to audit logs and keep track of lifecycle events.

The MCP specification highlights several key OAuth 2.1 features that Auth0 provides:

* **Proof Key for Code Exchange (PKCE):** [PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) mandatory security feature that mitigates authorization code interception and is handled automatically in Auth0's SDKs.  
* **Metadata Discovery:** Is mandatory per the MCP spec. Servers must advertise their OAuth endpoints. An Auth0 tenant provides [an authorization server discovery document](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery#configure-applications-with-oauth-2-0-authorization-server-metadata) (`/.well-known/oauth-authorization-server`) so MCP clients can dynamically find the required endpoints for authorization, token exchange, etc., reducing manual client-side configuration.  
* **Dynamic Client Registration (DCR):** DCR is crucial for scalability. It allows MCP clients (like a generic AI workbench) to programmatically register with your Auth0-secured MCP server via an API call. This avoids forcing users to manually create a client application in the Auth0 Dashboard for every new tool they want to connect.  
* **Delegating Authentication to a Third-Party Identity Provider (IdP):** The specification supports delegating the user login process. You can configure your MCP server to use Auth0 as the trusted identity provider, centralizing user management and sign-on logic.

## MCP Authorization flow with Auth0 

Here is the standard OAuth authorization code flow when an MCP server uses Auth0 as its authorization server:

<Steps>
  <Step>
    The MCP client sends a request to the protected MCP server and receives HTTP `401 Unauthorized` with a `WWW-Authenticate` header that indicates the protected resource metadata URL.
  </Step>
  <Step>
    The MCP client requests the [resource metadata](https://datatracker.ietf.org/doc/html/rfc9728/) from the MCP server at the `/.well-known/oauth-protected-resource` endpoint.
  </Step>
  <Step>
    The MCP client parses the metadata, selects an authorization server (Auth0) from the list, and then fetches its OAuth 2.0 Authorization Server Metadata from the `/.well-known/oauth-authorization-server` endpoint. [Dynamic Client Registration (DCR)](https://auth0.com/docs/get-started/applications/dynamic-client-registration#enable-dynamic-client-registration) can happen after receiving the metadata response.
  </Step>
  <Step>
    The client generates [PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) parameters and builds the authorization request, then opens the browser to the authorization endpoint.
  </Step>
  <Step>
    The user then authenticates with Auth0 (using username/password, social login, or MFA). Auth0 redirects the browser to the MCP clientâ€™s registered redirect URI with an authorization code.
  </Step>
  <Step>
    The MCP client exchanges the code at the token endpoint and Auth0 returns the access token completing the original OAuth flow.
  </Step>
  <Step>
    After receiving an access token (and refresh token), the MCP client will use the access token to make authenticated calls to the MCP server's tools.
  </Step>
</Steps>

<Frame caption="MCP Authorization flow with Auth0">
  <img
    className="hidden dark:block"
    src="/img/mcp/mcp_auth_flow_dark.png"
    alt="Auth0 Authentication Flow"
  />
  <img
    className="block dark:hidden"
    src="/img/mcp/mcp_auth_flow_light.png"
    alt="Auth0 Authentication Flow"
  />
</Frame>

### Access Token Validation in MCP

Receiving a token is not enough. Your MCP server must validate every token to ensure it is authentic and intended for your server. This involves several checks:

* **Verify the Token Signature:** Check that the token was signed by Auth0.  
* **Check the Expiration Time (`exp` claim):** Ensure the token has not expired.  
* **Validate the Audience (`aud` claim):** This is the most important check. Verify that the aud claim exactly matches your server's unique identifier.  
* **Verify the Issuer (`iss` claim):** Check that the token was issued by your Auth0 tenant.

Auth0's SDKs can perform these checks automatically. You apply this validation as a middleware to your protected routes.

## Security Best Practices: Sessions and Requests

**1. Do Not Use Sessions for Authentication**  
The MCP specification **prohibits** using sessions for authentication. The bearer access token is the only valid credential. You must verify the access token on **every single inbound request** to a protected endpoint. This stateless authentication model is more secure and prevents session hijacking attacks.

**2. Verify All Inbound Requests**  
Security is a continuous process. Explicitly state in your documentation that **all** inbound requests to tool endpoints must be verified to contain a valid, validated access token. Use middleware (like the one that performs the token validation) to protect every relevant route.

For more best practices, check out the [MCP official Security Best Practices](https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices) page.