---
title: "Go API: Authorization with JWT Middleware"
description: Secure your Go API with Auth0 using go-jwt-middleware v3
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

##### By Kunal Dawar

This tutorial demonstrates how to add authorization to a Go API using **go-jwt-middleware v3**. Learn how to validate JWTs, protect endpoints, and enforce permission-based access control.

<Card title="View Sample on GitHub" href="https://github.com/auth0-samples/auth0-golang-api-samples/tree/master/01-Quickstart-Go-API" icon="github">
  Complete working example with tests • Go 1.24+ required
</Card>

<Info>
**New to Auth0?** Learn [how Auth0 works](/docs/get-started/auth0-overview) and read about [implementing API authentication and authorization](/docs/get-started/authentication-and-authorization-flow) using the OAuth 2.0 framework.
</Info>

## What You'll Build

<CardGroup cols={2}>
  <Card title="Public Endpoints" icon="globe">
    Routes accessible without authentication
  </Card>
  <Card title="Protected Endpoints" icon="lock">
    JWT validation for authenticated users
  </Card>
  <Card title="Permission-Based Access" icon="shield-check">
    Scope validation for fine-grained control
  </Card>
  <Card title="Production-Ready" icon="rocket">
    Graceful shutdown, timeouts, and error handling
  </Card>
</CardGroup>

## Prerequisites

Before starting, ensure you have:

<AccordionGroup>
  <Accordion title="Go 1.24 or later" icon="golang" defaultOpen>
    go-jwt-middleware v3 requires Go 1.24+ and uses generics for type-safe claims. Check your version:
    ```bash
    go version
    ```
    Install or update at [go.dev/doc/install](https://go.dev/doc/install)
  </Accordion>

  <Accordion title="Auth0 Account" icon="shield-check">
    [Sign up for free](https://auth0.com/signup) if you don't have an account.
  </Accordion>

  <Accordion title="Basic Go Knowledge" icon="code">
    Familiarity with Go syntax, HTTP servers, and package management.
  </Accordion>
</AccordionGroup>

## Step 1: Configure Auth0 API

<Steps>
  <Step title="Create an API">
    In the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**.

    <Frame>![Create API](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/create-api.png)</Frame>
  </Step>

  <Step title="Configure API settings">
    - **Name**: `Quickstarts` (or any descriptive name)
    - **Identifier**: `https://quickstarts/api` (this becomes your `audience`)
    - **Signing Algorithm**: Leave as **RS256** (recommended)

    <Tip>
    The API Identifier is a logical identifier - it doesn't need to be a real URL. Use a format like `https://quickstarts/api` for clarity.
    </Tip>
  </Step>

  <Step title="Understand RS256">
    By default, your API uses **RS256** (asymmetric algorithm) for signing tokens:
    - Auth0 signs tokens with a **private key**
    - Your API verifies tokens with a **public key** (from JWKS)
    - Public keys are automatically fetched from: `https://{yourDomain}/.well-known/jwks.json`

    Learn more about [JSON Web Key Sets (JWKS)](/docs/secure/tokens/json-web-tokens/json-web-key-sets)
  </Step>
</Steps>

## Step 2: Define API Permissions

Permissions (scopes) let you define how resources can be accessed. For example, grant `read` access to managers and `write` access to administrators.

<Steps>
  <Step title="Navigate to Permissions">
    In your API settings, click the **Permissions** tab.
  </Step>

  <Step title="Add permissions">
    Create the following permission for this tutorial:

    | Permission | Description |
    |------------|--------------|
    | `read:messages` | Read messages from the API |

    <Frame>![Configure Permissions](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/configure-permissions.png)</Frame>

    <Info>
    This tutorial uses the `read:messages` scope to protect the scoped endpoint.
    </Info>
  </Step>
</Steps>

<Accordion title="What this tutorial covers" icon="list-check">
  This example demonstrates:

  - ✅ Extracting JWTs from the `Authorization: Bearer <token>` header
  - ✅ Validating tokens using Auth0's [JWKS](/docs/secure/tokens/json-web-tokens/json-web-key-sets)
  - ✅ Checking token expiration and claims
  - ✅ Enforcing permission-based access with scopes
  - ✅ Type-safe claims extraction using Go generics

  Learn more: [Validate Access Tokens](/docs/secure/tokens/access-tokens/validate-access-tokens)
</Accordion>

## Step 3: Install Dependencies

<Steps>
  <Step title="Initialize Go module">
    Create your project directory and initialize a Go module:

    ```bash
    mkdir myapi && cd myapi
    go mod init github.com/yourorg/myapi
    ```
  </Step>

  <Step title="Install Auth0 middleware">
    Install the v3 go-jwt-middleware package:

    ```bash
    go get github.com/auth0/go-jwt-middleware/v3
    go get github.com/joho/godotenv
    ```

    <Warning>
    **Version Important**: Ensure you install **v3** (not v2). V3 uses generics for type-safe claims handling and requires Go 1.24+.
    </Warning>
  </Step>

  <Step title="Download dependencies">
    ```bash
    go mod download
    ```

    Your `go.mod` should look like this:

    ```go
    module github.com/yourorg/myapi

    go 1.24

    require (
        github.com/auth0/go-jwt-middleware/v3 v3.0.0
        github.com/joho/godotenv v1.5.1
    )
    ```
  </Step>
</Steps>

## Step 4: Configure Environment Variables

Create a `.env` file in your project root to store Auth0 configuration:

export const codeExample = `# The URL of your Auth0 Tenant Domain.
# If you're using a Custom Domain, set this to that value instead.
AUTH0_DOMAIN='{yourDomain}'

# Your Auth0 API's Identifier (from Step 1)
# Example: https://quickstarts/api
AUTH0_AUDIENCE='{yourApiIdentifier}'`;

<AuthCodeBlock children={codeExample} language="bash" />

<Warning>
**Security**: Never commit `.env` files to version control. Add `.env` to your `.gitignore` file.
</Warning>

## Step 5: Create Configuration Package

Create `internal/config/auth.go` to load and validate environment variables:

```go
package config

import (
    "fmt"
    "os"
)

type AuthConfig struct {
    Domain   string
    Audience string
}

func LoadAuthConfig() (*AuthConfig, error) {
    domain := os.Getenv("AUTH0_DOMAIN")
    if domain == "" {
        return nil, fmt.Errorf("AUTH0_DOMAIN environment variable required")
    }

    audience := os.Getenv("AUTH0_AUDIENCE")
    if audience == "" {
        return nil, fmt.Errorf("AUTH0_AUDIENCE environment variable required")
    }

    return &AuthConfig{
        Domain:   domain,
        Audience: audience,
    }, nil
}
```

<AccordionGroup>
  <Accordion title="Why use a config package?" icon="gear">
    **Benefits of centralized configuration**:
    - Single source of truth for environment variables
    - Clear error messages for missing configuration
    - Type-safe configuration access
    - Easy to test and mock in unit tests
    - Fail fast on startup if config is invalid
  </Accordion>

  <Accordion title="Production best practices" icon="shield-check">
    **Configuration management**:
    - Validate all required config on startup (fail fast)
    - Use different `.env` files for different environments
    - Consider using config validation libraries for complex setups
    - Document all environment variables in a `.env.example` file
  </Accordion>
</AccordionGroup>

## Step 6: Create Custom Claims

Custom claims allow you to extract and validate application-specific data from JWTs. Create `internal/auth/claims.go`:

```go
package auth

import (
    "context"
    "fmt"
    "strings"
)

// CustomClaims contains custom data we want to parse from the JWT.
type CustomClaims struct {
    Scope string `json:"scope"`
}

// Validate ensures the custom claims are properly formatted.
func (c *CustomClaims) Validate(ctx context.Context) error {
    // Scope is optional, but if present, must be properly formatted
    if c.Scope == "" {
        return nil // No scope is valid - not all endpoints require permissions
    }

    // Validate scope format (no leading/trailing spaces, no double spaces)
    if strings.TrimSpace(c.Scope) != c.Scope {
        return fmt.Errorf("scope claim has invalid whitespace")
    }

    if strings.Contains(c.Scope, "  ") {
        return fmt.Errorf("scope claim contains double spaces")
    }

    return nil
}

// HasScope checks whether our claims have a specific scope.
func (c *CustomClaims) HasScope(expectedScope string) bool {
    if c.Scope == "" {
        return false
    }

    scopes := strings.Split(c.Scope, " ")
    for _, scope := range scopes {
        if scope == expectedScope {
            return true
        }
    }
    return false
}
```

<Accordion title="Understanding Custom Claims Validation" icon="shield-check">
  **Automatic Validation**: The `Validate` method is called automatically by the middleware after parsing the JWT. You don't need to call it manually - it's part of the validation chain.

  **Scope is Optional**: The validation allows empty scopes because not all endpoints require permissions. This works for:
  - `/api/private` - Requires only authentication (no scope needed)
  - `/api/private-scoped` - Requires authentication + `read:messages` scope

  **Format Validation**: When scope is present, validation ensures:
  - No leading/trailing whitespace
  - No double spaces (ensures clean parsing)
  - Properly formatted space-separated values

  **HasScope Method**: Returns `false` if scope is empty, preventing false positives.

  **Validation Flow**:
  1. JWT is extracted from the `Authorization` header
  2. Claims are unmarshaled into `CustomClaims` struct
  3. `Validate(ctx)` is automatically called
  4. If validation fails, JWT is rejected before reaching your handlers

</Accordion>

## Step 7: Create JWT Validator

The validator is the core component that verifies tokens. Create `internal/auth/validator.go`:

```go
package auth

import (
    "fmt"
    "net/url"
    "time"

    "github.com/auth0/go-jwt-middleware/v3/jwks"
    "github.com/auth0/go-jwt-middleware/v3/validator"
)

func NewValidator(domain, audience string) (*validator.Validator, error) {
    // Construct issuer URL (must include trailing slash)
    issuerURL, err := url.Parse("https://" + domain + "/")
    if err != nil {
        return nil, fmt.Errorf("failed to parse issuer URL: %w", err)
    }

    // Initialize JWKS provider using v3 options pattern
    provider, err := jwks.NewCachingProvider(
        jwks.WithIssuerURL(issuerURL),
        jwks.WithCacheTTL(5*time.Minute),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create JWKS provider: %w", err)
    }

    // Create validator using v3 options pattern
    jwtValidator, err := validator.New(
        validator.WithKeyFunc(provider.KeyFunc),         // Provides public keys for RS256
        validator.WithAlgorithm(validator.RS256),        // Algorithm (prevents confusion attacks)
        validator.WithIssuer(issuerURL.String()),        // Validates 'iss' claim
        validator.WithAudience(audience),                // Validates 'aud' claim
        validator.WithCustomClaims(func() validator.CustomClaims {
            return &CustomClaims{}                       // Returns our custom claims from claims.go
        }),
        validator.WithAllowedClockSkew(30*time.Second),  // Allows 30s clock drift
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create validator: %w", err)
    }

    return jwtValidator, nil
}
```

<AccordionGroup>
  <Accordion title="What does the validator check?" icon="shield-check" defaultOpen>
    The validator performs these security checks on every JWT:

    1. **Signature verification** - Using Auth0's public keys from JWKS
    2. **Issuer validation** - `iss` claim matches your Auth0 domain
    3. **Audience validation** - `aud` claim matches your API identifier
    4. **Expiration check** - Token hasn't expired (`exp` claim)
    5. **Time validity** - Token is currently valid (`nbf` and `iat` claims)
  </Accordion>

  <Accordion title="Key features explained" icon="lightbulb">
    **JWKS Caching**: Automatically fetches and caches Auth0's public keys every 5 minutes, reducing network calls.

    **Algorithm Specification**: Explicitly sets RS256 to prevent [algorithm confusion attacks](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/).

    **Clock Skew Tolerance**: Allows 30 seconds for distributed system clock differences.

    **Options Pattern**: V3 uses functional options (`WithIssuerURL()`, `WithKeyFunc()`, `WithAlgorithm()`, etc.) for flexible, type-safe configuration.

    **Custom Claims**: The `CustomClaims` struct lets you extract custom data from JWTs, like permission scopes.
  </Accordion>
</AccordionGroup>

## Step 8: Create HTTP Middleware

Create `internal/auth/middleware.go` to wrap your validator:

```go
package auth

import (
    "log/slog"
    "net/http"

    jwtmiddleware "github.com/auth0/go-jwt-middleware/v3"
    "github.com/auth0/go-jwt-middleware/v3/validator"
)

func NewMiddleware(jwtValidator *validator.Validator) (*jwtmiddleware.JWTMiddleware, error) {
    return jwtmiddleware.New(
        jwtmiddleware.WithValidator(jwtValidator),
        jwtmiddleware.WithValidateOnOptions(false),
        jwtmiddleware.WithErrorHandler(func(w http.ResponseWriter, r *http.Request, err error) {
            slog.Error("JWT validation failed", "error", err, "path", r.URL.Path)
            w.Header().Set("Content-Type", "application/json")
            w.WriteHeader(http.StatusUnauthorized)
            w.Write([]byte(`{"message":"Failed to validate JWT."}`))
        }),
    )
}
```

The middleware:
- Extracts JWT from `Authorization: Bearer <token>` header
- Validates token using the core validator
- Skips validation for OPTIONS requests (CORS preflight)
- Injects validated claims into request context
- Returns custom error responses on validation failure with structured logging

## Step 9: Create API Handlers

Create `internal/handlers/api.go` with three handlers demonstrating different protection levels:

```go
package handlers

import (
    "encoding/json"
    "net/http"

    "github.com/yourorg/myapi/internal/auth"
    jwtmiddleware "github.com/auth0/go-jwt-middleware/v3"
    "github.com/auth0/go-jwt-middleware/v3/validator"
)

// PublicHandler - no authentication required
func PublicHandler(w http.ResponseWriter, r *http.Request) {
    response := map[string]string{
        "message": "Hello from a public endpoint! You don't need to be authenticated to see this.",
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// PrivateHandler - requires valid JWT
func PrivateHandler(w http.ResponseWriter, r *http.Request) {
    response := map[string]string{
        "message": "Hello from a private endpoint! You need to be authenticated to see this.",
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// ScopedHandler - requires 'read:messages' permission
func ScopedHandler(w http.ResponseWriter, r *http.Request) {
    // Extract validated claims using generics (v3 feature)
    claims, err := jwtmiddleware.GetClaims[*validator.ValidatedClaims](r.Context())
    if err != nil {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusUnauthorized)
        w.Write([]byte(`{"message":"Unauthorized."}`))
        return
    }

    // Check for required scope in custom claims
    customClaims, ok := claims.CustomClaims.(*auth.CustomClaims)
    if !ok || !customClaims.HasScope("read:messages") {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusForbidden)
        w.Write([]byte(`{"message":"Insufficient scope."}`))
        return
    }

    response := map[string]string{
        "message": "Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.",
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}
```

## Step 10: Create Main Server

Create `cmd/server/main.go` to wire everything together:

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "time"

    "github.com/yourorg/myapi/internal/auth"
    "github.com/yourorg/myapi/internal/config"
    "github.com/yourorg/myapi/internal/handlers"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables from .env file
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using environment variables")
    }

    // Load Auth0 configuration
    cfg, err := config.LoadAuthConfig()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // Create JWT validator
    jwtValidator, err := auth.NewValidator(cfg.Domain, cfg.Audience)
    if err != nil {
        log.Fatalf("Failed to create validator: %v", err)
    }

    // Create HTTP middleware
    middleware, err := auth.NewMiddleware(jwtValidator)
    if err != nil {
        log.Fatalf("Failed to create middleware: %v", err)
    }

    // Setup routes
    mux := http.NewServeMux()
    mux.HandleFunc("/api/public", handlers.PublicHandler)
    mux.Handle("/api/private", middleware.CheckJWT(http.HandlerFunc(handlers.PrivateHandler)))
    mux.Handle("/api/private-scoped", middleware.CheckJWT(http.HandlerFunc(handlers.ScopedHandler)))

    // Configure server with production timeouts
    srv := &http.Server{
        Addr:         ":8080",
        Handler:      mux,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // Start server in goroutine
    go func() {
        log.Println("Server starting on :8080")
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server failed: %v", err)
        }
    }()

    // Graceful shutdown
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, os.Interrupt)
    <-quit

    log.Println("Shutting down server...")
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := srv.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }

    log.Println("Server exited")
}
```

<Accordion title="Project Structure" icon="folder-tree">
  ```
  myapi/
  ├── cmd/
  │   └── server/
  │       └── main.go              # Application entry point
  ├── internal/
  │   ├── auth/
  │   │   ├── claims.go            # Custom JWT claims
  │   │   ├── middleware.go        # JWT middleware
  │   │   └── validator.go         # JWT validator
  │   ├── config/
  │   │   └── auth.go              # Configuration loader
  │   └── handlers/
  │       └── api.go               # HTTP handlers (public, private, scoped)
  ├── .env                         # Environment variables (not committed)
  ├── .env.example                 # Template for environment variables
  ├── .gitignore
  ├── go.mod
  ├── go.sum
  └── README.md
  ```
</Accordion>

## Step 11: Test Your API

<Steps>
  <Step title="Start the server">
    ```bash
    go run cmd/server/main.go
    ```

    You should see: `Server starting on :8080`
  </Step>

  <Step title="Get a test token">
    Navigate to your API in the [Auth0 Dashboard](https://manage.auth0.com/#/apis), click the **Test** tab, and copy the access token.
  </Step>

  <Step title="Test public endpoint">
    ```bash
    curl http://localhost:8080/api/public
    ```

    <Check>**Expected**: 200 OK with public message</Check>
  </Step>

  <Step title="Test private endpoint (no token)">
    ```bash
    curl http://localhost:8080/api/private
    ```

    <Check>**Expected**: 401 Unauthorized</Check>
  </Step>

  <Step title="Test private endpoint (with token)">
    ```bash
    curl -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
         http://localhost:8080/api/private
    ```

    <Check>**Expected**: 200 OK with user information</Check>
  </Step>

  <Step title="Test scoped endpoint">
    ```bash
    curl -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
         http://localhost:8080/api/private-scoped
    ```

    <Check>**Expected**: 200 OK if token has `read:messages` scope, 403 Forbidden otherwise</Check>
  </Step>
</Steps>

## Continue Learning

<CardGroup cols={2}>
  <Card title="Using Your API" icon="code" href="/docs/quickstart/backend/golang/02-using">
    Learn how to call your protected API from different client applications
  </Card>
  <Card title="Troubleshooting Guide" icon="screwdriver-wrench" href="/docs/quickstart/backend/golang/03-troubleshooting">
    Comprehensive debugging tips and solutions to common issues
  </Card>
</CardGroup>

## Quick Troubleshooting

<AccordionGroup>
  <Accordion title="Invalid Audience Error" icon="triangle-exclamation">
    **Error**: `{"error": "invalid_token", "description": "aud claim mismatch"}`

    **Solution**: Verify `AUTH0_AUDIENCE` matches your API Identifier exactly from the Auth0 Dashboard.
  </Accordion>

  <Accordion title="JWKS Endpoint Unreachable" icon="triangle-exclamation">
    **Error**: `error fetching keys: connection refused`

    **Solution**:
    - Check network connectivity to Auth0
    - Test JWKS endpoint: `curl https://your-tenant.us.auth0.com/.well-known/jwks.json`
    - Verify firewall/proxy settings
  </Accordion>

  <Accordion title="Token Expired" icon="triangle-exclamation">
    **Error**: `{"error": "invalid_token", "description": "token is expired"}`

    **Solution**: Get a new token from the Auth0 Dashboard Test tab.
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Custom Claims" icon="code" href="https://github.com/auth0/go-jwt-middleware#custom-claims">
    Add domain-specific authorization with type-safe claims
  </Card>
  <Card title="Token Refresh" icon="arrows-rotate" href="/docs/secure/tokens/refresh-tokens">
    Implement refresh tokens for long-lived sessions
  </Card>
  <Card title="DPoP Security" icon="lock" href="https://github.com/auth0/go-jwt-middleware#dpop-support">
    Enable proof-of-possession for enhanced security
  </Card>
  <Card title="Production Checklist" icon="circle-check" href="/docs/deploy-monitor/production-checks">
    Pre-launch security review and best practices
  </Card>
</CardGroup>

---

[Edit on GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/backend/golang/01-authorization.md)

---