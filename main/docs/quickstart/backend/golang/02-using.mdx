---
title: "Auth0 Go API SDK Quickstarts: Using your API"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

##### By Kunal Dawar

This tutorial demonstrates how to call your protected Go API from client applications. We recommend that you log in to follow this quickstart with examples configured for your account.

## Calling the API From Your Application

You can call your protected API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url http://localhost:8080/api/private \
  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'
```

```csharp C# lines
var client = new RestClient("http://localhost:8080/api/private");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {
	url := "http://localhost:8080/api/private"

	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)
	defer res.Body.Close()

	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))
}
```

```java Java lines
HttpResponse<String> response = Unirest.get("http://localhost:8080/api/private")
  .header("authorization", "Bearer YOUR_ACCESS_TOKEN")
  .asString();
```

```javascript Node.JS lines
const axios = require("axios").default;

const options = {
  method: 'GET',
  url: 'http://localhost:8080/api/private',
  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```

```python Python lines
import http.client

conn = http.client.HTTPConnection("localhost", 8080)
headers = { 'authorization': "Bearer YOUR_ACCESS_TOKEN" }

conn.request("GET", "/api/private", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'

url = URI("http://localhost:8080/api/private")

http = Net::HTTP.new(url.host, url.port)

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```

```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer YOUR_ACCESS_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "http://localhost:8080/api/private")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse as Any)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<Note>
The examples use port **8080**. Update the port in your requests to match your server configuration.
</Note>

## Obtaining an Access Token

<Tabs>
  <Tab title="Single-Page or Mobile Apps">
    If you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using.

    <CardGroup cols={2}>
      <Card title="Single-Page Applications" icon="browser" href="/docs/quickstart/spa">
        React, Vue, Angular quickstarts with examples
      </Card>
      <Card title="Mobile / Native Applications" icon="mobile" href="/docs/quickstart/native">
        iOS, Android, React Native quickstarts
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Machine-to-Machine (M2M)">
    If you are calling the API from a command-line tool or another service where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials).

    <Steps>
      <Step title="Register M2M Application">
        Register a [Machine to Machine Application](https://manage.auth0.com/#/applications) in your Auth0 Dashboard.
      </Step>

      <Step title="Get credentials">
        Copy your **Client ID** and **Client Secret** from [Application Settings](https://auth0.com/docs/get-started/dashboard/application-settings).
      </Step>

      <Step title="Request access token">
        Use the Client Credentials flow to obtain an access token (see code examples below).
      </Step>
    </Steps>

    <Warning>
      **Token Reuse**: Auth0 customers are billed based on the number of Machine to Machine Access Tokens issued. Once your application gets an Access Token, it should keep using it until it expires to minimize the number of tokens requested.
    </Warning>
  </Tab>
</Tabs>

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=client_credentials \
  --data 'client_id={yourClientId}' \
  --data client_secret={yourClientSecret} \
  --data audience=YOUR_API_IDENTIFIER
```
```cs C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {
	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER")

	req, _ := http.NewRequest("POST", url, payload)
	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)
	defer res.Body.Close()

	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))
}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER")
  .asString();
```
```javascript Node.JS
const axios = require("axios").default;

const options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'client_credentials',
    client_id: '{yourClientId}',
    client_secret: '{yourClientSecret}',
    audience: 'YOUR_API_IDENTIFIER'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```python Python
import http.client

conn = http.client.HTTPSConnection("{yourDomain}")

payload = "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=client_credentials".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)
postData.append("&audience=YOUR_API_IDENTIFIER".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse as Any)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<Tip>
For testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).
</Tip>

## Test Your Protected API

<Steps>
  <Step title="Test Public Endpoint (No Authentication)">

You can make a request to the `/api/public` endpoint without passing any Access Token:

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url http://localhost:8080/api/public
```
```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {
	url := "http://localhost:8080/api/public"
	req, _ := http.NewRequest("GET", url, nil)

	res, _ := http.DefaultClient.Do(req)
	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))
}
```
</AuthCodeGroup>

<Check>**Expected**: 200 OK with message "Hello from a public endpoint! No authentication required."</Check>
  </Step>

  <Step title="Test Private Endpoint Without Token">
This should fail with a 401 error:

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url http://localhost:8080/api/private
```
</AuthCodeGroup>

<Check>**Expected**: 401 Unauthorized `{"error": "invalid_token"}`</Check>
  </Step>

  <Step title="Test Private Endpoint With Token">
This should succeed with a valid token:

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url http://localhost:8080/api/private \
  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {
	url := "http://localhost:8080/api/private"
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)
	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))
}
```
</AuthCodeGroup>

<Check>**Expected**: 200 OK with user information</Check>
  </Step>

  <Step title="Test Scoped Endpoint (Permission Required)">
To test the endpoint that requires a scope, pass the Access Token containing the correct scope (`read:messages`) as a Bearer token:

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url http://localhost:8080/api/private-scoped \
  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'
```

```csharp C# lines
var client = new RestClient("http://localhost:8080/api/private-scoped");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {
	url := "http://localhost:8080/api/private-scoped"
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)
	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))
}
```

```java Java lines
HttpResponse<String> response = Unirest.get("http://localhost:8080/api/private-scoped")
  .header("authorization", "Bearer YOUR_ACCESS_TOKEN")
  .asString();
```

```javascript Node.JS lines
const axios = require("axios").default;

const options = {
  method: 'GET',
  url: 'http://localhost:8080/api/private-scoped',
  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```

```python Python lines
import http.client

conn = http.client.HTTPConnection("localhost", 8080)
headers = { 'authorization': "Bearer YOUR_ACCESS_TOKEN" }

conn.request("GET", "/api/private-scoped", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'

url = URI("http://localhost:8080/api/private-scoped")

http = Net::HTTP.new(url.host, url.port)

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```

```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer YOUR_ACCESS_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "http://localhost:8080/api/private-scoped")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse as Any)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<Check>**Expected with scope**: 200 OK with `read:messages` permission</Check>

<Warning>
If the required scope is not present, the API returns a 403 HTTP Status (Forbidden): `Insufficient permissions`
</Warning>
  </Step>
</Steps>

## API Response Behavior

<Accordion title="Understanding Error Responses" icon="circle-info">
The middleware returns RFC 6750 compliant error responses with structured JSON:

**401 Unauthorized** (token missing or invalid):
```json
{"error": "invalid_token", "description": "authorization header missing"}
```

**403 Forbidden** (insufficient permissions):
```
Insufficient permissions
```

The response includes a `WWW-Authenticate` header for proper OAuth 2.0 compliance:
```
WWW-Authenticate: Bearer error="invalid_token", error_description="token expired"
```
</Accordion>

## Next Steps

<CardGroup cols={2}>
  <Card title="Custom Claims Validation" icon="code" href="https://github.com/auth0/go-jwt-middleware#custom-claims">
    Add domain-specific authorization logic with type-safe claims
  </Card>
  <Card title="Token Refresh" icon="arrows-rotate" href="/docs/secure/tokens/refresh-tokens">
    Implement refresh token flow for long-lived sessions
  </Card>
  <Card title="DPoP Support" icon="lock" href="https://github.com/auth0/go-jwt-middleware#dpop-support">
    Enable Demonstrating Proof-of-Possession for enhanced security
  </Card>
  <Card title="Production Best Practices" icon="circle-check" href="/docs/deploy-monitor/production-checks">
    Pre-launch security review and best practices
  </Card>
</CardGroup>

[Edit on GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/backend/golang/02-using.md)
