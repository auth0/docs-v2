---
description: ''
og:description: How to install, initialize and use auth0.js v9
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Référence Auth0.js v9
og:url: https://auth0.com/docs/
permalink: auth0js
title: Référence Auth0.js v9
twitter:description: How to install, initialize and use auth0.js v9
twitter:title: Référence Auth0.js v9
---

Auth0.js is a client-side JavaScript library for Auth0. It supports both [hosted login and embedded login](/docs/authenticate/login/universal-vs-embedded-login) use cases.

The full API documentation for the library is [here](https://auth0.github.io/auth0.js/index.html).

<Warning>

Embedded login for web applications uses [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) unless you [configure a custom domain](/docs/customize/custom-domains) for your tenant. Cross-origin authentication uses third-party cookies to allow for secure authentication transactions across different origins.

</Warning>

## Exemple prêt à être utilisé

The [example directory](https://github.com/auth0/auth0.js/tree/master/example) of the auth0.js library is a ready-to-go app that can help you to quickly and easily try out auth0.js. In order to run it, follow these quick steps:

1. If you don't have [node](http://nodejs.org/) installed, do that now
2. Download dependencies by running `npm install` from the root of this project
3. Finally, execute `npm start` from the root of this project, and then browse to your app running on the node server, presumably at `http://localhost:3000/example`.

## Configuration et initialisation

Maintenant, débutons en intégrant auth0.js dans votre projet. Nous couvrirons les [méthodes d’installation](#installation-options),[ l’initialisation de auth0.js](#initialization), [l’inscription](#signup), [la connexion](#login), [la déconnexion](#logout), et plus encore!

### Configure your Auth0 application for embedded login

When implementing embedded login, the library will use cross-origin calls inside hidden iframes to perform authentication. To make sure this can be done securely, Auth0 needs to know the domains where you will be hosting your applications.

Add the domain to the **Allowed Web Origins** field. You can find this field in the [Application Settings](https://manage.auth0.com/#/applications) area of your Dashboard.

### Options d’installation

Vous avez quelques options pour utiliser auth0.js dans vos projets. Choisissez l’une des options suivantes, selon vos besoins :

Install via [npm](https://npmjs.org) or [yarn](https://yarnpkg.com):

```bash lines
npm install auth0-js

yarn add auth0-js
```

Après avoir installé le module `auth0-js`, vous devrez le regrouper avec toutes ses dépendances, ou l’importer à l’aide de :

```js lines
import auth0 from 'auth0-js';
```

Alternativemet, incluez le script via notre CDN :

```html wrap lines
<script src="https://cdn.auth0.com/js/auth0/9.18/auth0.min.js"></script>
```

### Initialisation

initialisez une nouvelle requête de l’application Auth0, tel que suit :

```html lines
<script type="text/javascript">
  var webAuth = new auth0.WebAuth({
    domain:       '{yourDomain}',
    clientID:     '{yourClientId}'
  });
</script>
```

#### Paramètres disponibles

Deux paramètres obligatoires doivent être transmis dans l’objet `options` lors de l’instanciation de `webAuth`, tandis que d’autres sont facultatifs.

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `domain` | required | (String) Your Auth0 account domain (ex. myaccount.auth0.com) |
| `clientID` | required | (String) Your Auth0 client ID |
| `redirectUri` | optional\* | (String) The default `redirectUri` used. Defaults to an empty string (none). **If you do not provide a global `redirectUri` value here, you will need to provide a redirectUri value for *each* method you use.** |
| `scope` | optional | (String) The default <Tooltip tip="Scope: Mechanism that determines actions applications can perform on a user's behalf with information previously created in an online resource." cta="View Glossary" href="/docs/glossary?term=scope%28s%29">scope(s)</Tooltip> used by the application. Using scopes can allow you to return specific claims for specific fields in your request. You should read our [documentation on scopes](/docs/get-started/apis/scopes) for further details. |
| `audience` | optional | (String) The default audience to be used for requesting API access. |
| `responseType` | optional\* | (String) The default `responseType` used. It can be any space separated list of the values `code`, `token`, `id_token`. It defaults to `'token'`, unless a `redirectUri` is provided, then it defaults to `'code'`. **If you do not provide a global `responseType` value, you will need to provide a `responseType` value for *each* method you use.** |
| `responseMode` | optional | (String) This option is omitted by default. Can be set to `'form_post'` in order to send the token or code to the `'redirectUri'` via POST. Supported values are `query`, `fragment` and `form_post`. |
| `leeway` | optional | (Integer) A value in seconds; leeway to allow for clock skew with regard to ID Token expiration times. |
| `_disableDeprecationWarnings` | optional | (Boolean) Disables the deprecation warnings, defaults to `false`. |

En raison de problèmes de décalage d’horloge, le message d’erreur suivant peut parfois être affiché `The token was issued in the future`. Le paramètre `leeway` peut être utilisé pour accorder quelques secondes de marge aux délais d’expiration des jetons d’ID, afin d’éviter que cela ne se produise.

##### Permission

Dans auth0.js v9, la valeur par défaut de `scope` est `openid profile email`.

<Card title="Running Auth0.js locally">

If you don't specify at least the above scope when initializing auth0.js, and you are running your website from `http://localhost` or `http://127.0.0.1`, calling the `getSSOData()` method will result in the following error in the browser console:

`Consent required. When using getSSOData, the user has to be authenticated with the following scope: openid profile email`

That will not happen when you run your application in production or if you specify the `openid profile email` scope. You can read more about this in the [User consent and third-party applications](/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) document.

</Card>

## Connexion

Vous pouvez choisir une méthode de connexion fondée sur le type d’auth dont vous avez besoin dans votre application.

### webAuth.authorize()

The `authorize()` method can be used for logging in users through <Tooltip tip="Universal Login: Your application redirects to Universal Login, hosted on Auth0's Authorization Server, to verify a user's identity." cta="View Glossary" href="/docs/glossary?term=Universal+Login">Universal Login</Tooltip> or social connections as shown in the examples below. This method invokes the `/authorize` endpoint of the Authentication API, and can take a variety of parameters through the `options` object.

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `audience` | optional | (String) The default audience to be used for requesting API access. |
| `connection` | optional | (String) Specifies the connection to use rather than presenting all connections available to the application. |
| `scope` | optional | (String) The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OIDC scopes about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](/docs/secure/tokens/json-web-tokens/create-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Token">Refresh Token</Tooltip>. |
| `responseType` | optional | (String) It can be any space separated list of the values `code`, `token`, `id_token`. It defaults to `'token'`, unless a `redirectUri` is provided, then it defaults to `'code'`. |
| `clientID` | optional | (String) Your Auth0 client ID. |
| `redirectUri` | optional | (String) The URL to which Auth0 will redirect the browser after authorization has been granted for the user. |
| `state` | optional | (String) An arbitrary value that should be maintained across redirects. It is useful to mitigate CSRF attacks and for any contextual information (for example, a return URL) that you might need after the authentication process is finished. For more information, see [State Parameter](/docs/secure/attack-protection/state-parameters). auth0.js, when used in single-page applications, handles the state generation and validation automatically if not specified. |
| `prompt` | optional | (String) A value of `login` will force the login page to show regardless of current session. A value of `none` will attempt to bypass the login prompts if a session already exists (see the [silent authentication](/docs/authenticate/single-sign-on#silent-authentication) documentation for more details). |

Pour une connexion hébergée, vous devez appeler la méthode `/authorize()`.

`webAuth.authorize({//Any additional options can go here});`

//Any additional options can go here

`webAuth.authorize({connection: 'twitter'});`

### Pour les connexions par réseau social, le paramètre `connection` devra être indiqué :

Pour les connexions par réseau social, le paramètre `connection` devra être indiqué :

Pour l’authentification par fenêtre contextuelle, la méthode `popup.authorize` peut être utilisée. L’authentification par fenêtre contextuelle ne peut être utilisée dans les pages de connexion avec hôte. Typiquement, l’authentification par fenêtre contextuelle est utilisée par les applications avec une simple page, de manière à ce que l’état actuel ne soit pas perdu en effectuant une redirection de la page entière.

```js lines
webAuth.popup.authorize({
  responseType: 'token'
  redirectUri: 'https://{yourApp}/popup_response_handler.html'
  //Any additional options can go here
}, function(err, authResult) {
  //do something
});
```

Autorisation par défaut avec fenêtre contextuelle (les utilisateurs voient la Connexion universelle Auth0) :

```js lines
webAuth.popup.authorize({
  responseType: 'token'
  redirectUri: 'https://{yourApp}/popup_response_handler.html',
  connection: 'twitter'
}, function(err, authResult) {
  //do something
});
```

#### Et pour les connexions par réseau social avec fenêtre contextuelle utilisant `authorize` :

Gestion des résultats d’authentifications par fenêtre contextuelle popup

```html lines
<!-- popup_response_handler.html -->
<html>
  <body>
    <script src="https://cdn.auth0.com/js/auth0/9.18/auth0.min.js"></script>
    <script type="text/javascript">
      var webAuth = new auth0.WebAuth({
        domain:       'YOUR_AUTH0_DOMAIN',
        clientID:     'YOUR_CLIENT_ID'
      });
      webAuth.popup.callback();
    </script>
  </body>
</html>
```

Lorsque vous utilisez l’authentification par fenêtre contextuelle, vous devez fournir un `redirectUri` où la page de destination communique les résultats de l’autorisation au rappel en utilisant la méthode `webAuth.popup.callback`. Une simple mise en oeuvre ressemblerait à ceci :

Un gestionnaire idéal ne comprendrait que cette fonctionalité minimale (c.-à-d. évitant de recharger l’application entière seulement pour gérer la réponse).

### Vous devrez ajouter le `redirectUri` à la liste des **URL de rappel autorisées** de l’application dans la page de configuration de l’application sur le tableau de bord.

<Warning>

Embedded login for web applications uses [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) unless you [configure a custom domain](/docs/customize/custom-domains) for your tenant. Cross-origin authentication uses third-party cookies to allow for secure authentication transactions across different origins.

</Warning>

The `login` method can be used for embedded login through [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) for database connections, using `/co/authenticate`.

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `username` | optional | (String) The username to present for authentication. **Either** `username` or `email` must be present. |
| `email` | optional | (String) The email to present for authentication. **Either** `username` or `email` must be present. |
| `password` | required | (String) The password to present for authentication. |
| `realm` | required | (String) The name of the database connection against which to authenticate. |

```js lines
webAuth.login({
  realm: 'tests',
  username: 'testuser',
  password: 'testpass',
});
```

### La méthode `login` permet une [authentification cross-origin](/login/cross-origin-authentication) pour les connexions par base de données, en utilisant `/co/authenticate`.

The `crossOriginVerification()` method can be used to help provide cross-origin authentication to customers who have third-party cookies disabled in their browsers. Further details about its usage can be read in the [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) document.

### La méthode `crossOriginVerification()` peut être utilisée pour aider à fournir une authentification cross-origin aux clients dont les témoins de tierce-partie ont été désactivés dans leur navigateur. Pour de plus amples détails concernant spn utilisation, consultez le document [authentification cross-origin](/login/cross-origin-authentication).

La méthode `crossOriginVerification()` peut être utilisée pour aider à fournir une authentification cross-origin aux clients dont les témoins de tierce-partie ont été désactivés dans leur navigateur. Pour de plus amples détails concernant spn utilisation, consultez le document [authentification cross-origin](/login/cross-origin-authentication).


```js lines
// Calculate URL to redirect to
var url = webAuth.client.buildAuthorizeUrl({
  clientID: '{yourClientId}', // string
  responseType: 'token id_token', // code
  redirectUri: 'https://{yourApp}/callback',
  state: '{yourState}',
  nonce: '{yourNonce}'
});

// Redirect to url
// ...
```

The `state` parameter is an opaque value that Auth0 will send back to you. This method helps prevent CSRF attacks, and it needs to be specified if you redirect to the URL yourself instead of calling `webAuth.authorize()`. For more information, see [State Parameter](/docs/secure/attack-protection/state-parameters).

### Single Sign-On with embedded authentication

Apps with embedded login must meet two criteria in order to have <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=Single+Sign-on">Single Sign-on</Tooltip> (SSO).

1. Both of the applications attempting SSO must be first-party applications. SSO with third-party applications will not work.
2. They need to make use of custom domains and have both the applications which intend to have SSO as well as the Auth0 tenant on the same domain. Traditionally, Auth0 domains are in the format `foo.auth0.com`, but custom domains allow you to use the same domain for each of the applications in question as well as your Auth0 tenant, preventing the risk of CSRF attacks.

Our recommendation is to use Universal Connexion instead of setting up SSO in embedded login scenarios. Universal Connexion is the most reliable and stable way to perform SSO, and is the only way to do so if you must use multiple domains for your applications, or use [third-party applications](/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).

## Le paramètre `state` est une valeur opaque qu’Auth0 vous renverra. Cette méthode aide à prévenir les attaques CSRF, et elle doit être indiquée si vous redirigez vous-mêmes vers l’URL plutôt que d’appeler `webAuth.authorize()`. Pour plus d’informations, consultez la section [Paramètre state](/attack-protection/state-parameters).

<Tooltip tip="Passwordless: Form of authentication that does not rely on a password as the first factor." cta="View Glossary" href="/docs/glossary?term=Passwordless">Passwordless</Tooltip> authentication allows users to log in by receiving a one-time password through email or text message. The process will require you to start the passwordless process, generating and dispatching a code to the user (or a code within a link), followed by accepting their credentials through the verification method. That could happen in the form of a login screen which asks for their (email or phone number) and the code you just sent them. It could also be implemented in the form of a passwordless link instead of a code sent to the user. They would simply click the link in their email or text and it would hit your endpoint and verify this data automatically using the same verification method (just without manual entry of a code by the user).

L’authentification sans mot de passe permet aux utilisateurs de se connecter en recevant un mot de passe à usage unique (OTP) par courriel ou SMS. Ce processus demande que vous lanciez le processus Passwordless, produisant et envoyant un code à l’utilisateur, (ou un code avec un lien), suivi en acceptant les authentifiants par la méthode de vérification. Ce pourrait survenir sous la forme d’une écran de connexion qui demande leur (courriel ou numéro de téléphone) et le code que vous venez de leur envoyer. Ce pourrait également être mis en place sous la forme d’un lien Sans mot de passe avec un code envoyé à l’utilisateur. Ils n’auraient qu’à cliquer sur le lien dans leur couriel et ils atteindraient votre point de terminaison, pour alors vérifier ces données automatiquement à l’aide la même méthode de vérification (sans entrée manuelle de code de la part de l’utilisateur).


```js lines
var webAuth = new auth0.WebAuth({
  clientID: '{yourClientId}',
  domain: '{yourDomain}',
  redirectUri: 'http://example.com',
  responseType: 'token id_token'
});
```

### De manière à pouvoir utiliser  l’authentification sans mot de passe, vous devrez initialiser auth0.js avec un `redirectUri` et définir le `responseType : ’token’`.

Débuter l’authentification sans mot de passe

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `connection` | required | (String) Specifies how to send the code/link to the user. Value must be either `email` or `sms`. |
| `send` | required | (String) Value must be either `code` or `link`. If `null`, a link will be sent. |
| `phoneNumber` | optional | (String) The user's phone number for delivery of a code or link via SMS. |
| `email` | optional | (String) The user's email for delivery of a code or link via email. |

La première étape de l’authentification sans mot de passe avec auth0.js est la méthode `passwordlessStart`, qui a plusieurs paramètres qui peuvent être transmis dans son objet `options` :

```js lines
webAuth.passwordlessStart({
    connection: 'email',
    send: 'code',
    email: 'foo@bar.com'
  }, function (err,res) {
    // handle errors or continue
  }
);
```

### Notez qu’un seul des paramètres facultatifs `phoneNumber` et `email` doit être envoyé pour lancer la transaction sans mot de passe.

Compléter l’authentification sans mot de passe

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `connection` | required | (String) Specifies how to send the code/link to the user. Value must be either `email` or `sms` and the same as the value passed to `passwordlessStart`. |
| `verificationCode` | required | (String) The code sent to the user, either as a code or embedded in a link. |
| `phoneNumber` | optional | (String) The user's phone number to which the code or link was delivered via SMS. |
| `email` | optional | (String) The user's email to which the code or link was delivered via email. |

Si vous envoyez un code, vous devrez alors envoyer une demande à l’utilisateur d’entrer ce code. Vous traiterez le code et authentifierez l’utilisateur à l’aide de la méthode `passwordlessLogin`, qui possède plusieurs paramètres pouvant être envoyés dans son objet `options` :

Comme pour `passwordlessStart`, un seul des paramètres facultatifs `phoneNumber` et `email` doit être envoyé afin de vérifier la transaction sans mot de passe.

```js lines
webAuth.passwordlessLogin({
    connection: 'email',
    email: 'foo@bar.com',
    verificationCode: '389945'
  }, function (err,res) {
    // handle errors or continue
  }
);
```

## Pour pouvoir utiliser la méthode `passwordlessLogin`, les options `redirectUri` et `responseType` doivent être précisées au moment d’initialiser WebAuth.

Effectuez une extraction de authResult et obtenez les informations utilisateur

Après l’authentification, vous pouvez utiliser la méthode `parseHash` pour analyser le fragment de hashage URL lorsque l’utilisateur est redirigé vers l’application pour extraire le résultat d’une réponse d’authentification Auth0. Vous pouvez choisir de gérer cette page de rappel, laquelle vous redirigera vers l’application principale ou au sein de la même page, selon les circonstances de la situation.

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `state` | optional | (String) An opaque value the application adds to the initial request that Auth0 includes when redirecting back to the application. This value is used by auth0.js to prevent CSRF attacks. |
| <Tooltip tip="Nonce: Arbitrary number issued once in an authentication protocol to detect and prevent replay attacks." cta="View Glossary" href="/docs/glossary?term=nonce">nonce</Tooltip> | optional | (String) Used to verify the ID Token |
| `hash` | optional | (String) The URL hash (if not provided, `window.location.hash` will be used by default) |

La méthode `parseHash` accepte un objet `options` qui contient les paramètres suivants :

| **Item** | **Description** |
| --- | --- |
| `accessToken` | An <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=Access+Token">Access Token</Tooltip> for the API, specified by the `audience` |
| `expiresIn` | A string containing the expiration time (in seconds) of the `accessToken` |
| `idToken` | An ID Token JWT containing user profile information |

```js lines
webAuth.parseHash({ hash: window.location.hash }, function(err, authResult) {
  if (err) {
    return console.log(err);
  }

  webAuth.client.userInfo(authResult.accessToken, function(err, user) {
    // Now you have the user's information
  });
});
```

Le contenu de l’objet authResult renvoyé par la méthode `parseHash` dépend des paramètres d’authentification utilisés. Ce peut comprendre :

```json lines
{
    "sub": "auth0|123456789012345678901234",
    "nickname": "johnfoo",
    "name": "johnfoo@gmail.com",
    "picture": "https://gravatar.com/avatar/example.png",
    "updated_at": "2018-05-07T14:16:52.013Z",
    "email": "johnfoo@gmail.com",
    "email_verified": "false"
}
```

You can now do something else with this information as your application needs, such as acquire the user's entire set of profile information with the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>, as described below.

## Vous pouvez maintenant faire quelque chose d’autre avec cette information, selon les besoins de votre application, tel que d’acquérir l’ensemble des informations de profil de l’utilisateur dans Management API, tel que décrit ci-dessous.

Utilisation des nombres aléatoires
Par défaut (et si `responseType` contient `id_token`), `auth0.js` génère un `nonce` aléatoire lorsque vous appelez `webAuth.authorize`, le stocke localement, et l’extrait dans `webAuth.parseHash`. Le comportement par défaut devrait fonctionner dans la majorité des cas, mains certains cas exigent au développeur de contrôler le `nonce`.
`webAuth.authorize({<Tooltip tip="Nonce: Arbitrary number issued once in an authentication protocol to detect and prevent replay attacks." cta="View Glossary" href="/docs/glossary?term=nonce">nonce</Tooltip>: '1234', responseType: 'token id_token'});
Si vous souhaitez utiliser un `nonce` généré par le développeur, vous devez le fournir en tant qu’option à `webAuth.authorize` et `webAuth.parseHash`.

`webAuth.parseHash({nonce: ’1234’}, callback);`

```js lines
webAuth.checkSession({
  nonce: '1234',
}, function (err, authResult) {
    ...
});
```

The `webAuth.checkSession` method will automatically verify that the returned <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip>'s `nonce` claim is the same as the option.

## La méthode `webAuth.checkSession` vérifiera automatiquement que la demande `nonce` du jeton d’ID renvoyé est la même que celle de l’option.

Codes d’erreur et descriptions

<Warning>

Error descriptions are intended to be human readable. The description **should not be parsed by any code** and is subject to change at any time.

</Warning>

| **Status** | **Code** | **Description** |
| --- | --- | --- |
| 400 | invalid_request | Invalid request body. All and only of client_id, credential_type, username, otp, realm are required. |
| 401 | unauthorized_client | Cross origin login not allowed. |
| 400 | unsupported_credential_type | Unknown credential type parameter. |
| 400 | invalid_request | Unknown realm non-existent-connection. |
| 403 | access_denied | Wrong email or password. |
| 403 | access_denied | Authentication error |
| 403 | blocked_user | Blocked user |
| 401 | password_leaked | This login attempt has been blocked because the password you're using was previously disclosed through a data breach (not in this application). |
| 429 | too_many_attempts | Your account has been blocked after multiple consecutive login attempts. We've sent you a notification via your preferred contact method with instructions on how to unblock it. |
| 429 | too_many_attempts | We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator. |

Lorsque Auth0.js est employé pour une connexion intégrée, le point de terminaison `/co/authenticate` est utilisé, ce qui peut produire les erreurs suivantes :
`Origin https://test.app is not allowed.`

## De plus, vous pouvez également obtenir un code d’erreur 403 générique sans propriété `error` ou `error_description`. Le corps de la réponse n’incluera que quelque chose comme ceci :

Déconnexion

If the `clientID` parameter is included, the `returnTo` URL that is provided must be listed in the Application's **Allowed De plus, vous pouvez également obtenir un code d’erreur 403 générique sans propriété `error` ou `error_description`. Le corps de la réponse n’incluera que quelque chose comme ceci : URLs** in the [Auth0 dashboard](https://manage.auth0.com/#). However, if the `clientID` parameter is not included, the `returnTo` URL must be listed in the **Allowed De plus, vous pouvez également obtenir un code d’erreur 403 générique sans propriété `error` ou `error_description`. Le corps de la réponse n’incluera que quelque chose comme ceci : URLs** at the account level in the [Auth0 dashboard](https://manage.auth0.com/#).

```js lines
webAuth.logout({
  returnTo: 'some url here',
  clientID: 'some client ID here'
});
```

## Si le paramètre `clientID` est inclus, l’URL `returnTo` qui est fournie doit être listée dans les **URL de déconnexion autorisées** de l’application dans [Auth0 Dashboard](%24%7Bmanage_url%7D). Toutefois, si le paramètre `clientID` n’est pas inclus, l’URL `returnTo` doit figurer dans les **URL de déconnexion autorisées**.

Inscription

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `email` | required | (String) User's email address |
| `password` | required | (String) User's desired password |
| `username` | required\* | (String) User's desired username.  \*Required if you use a database connection and you have enabled **Requires Username** |
| `connection` | required | (String) The database connection name on your application upon which to attempt user account creation |
| `user_metadata` | optional | (JSON object) Additional attributes used for user information. Will be stored in [user\_metadata](/docs/manage-users/user-accounts/metadata) |

Pour enregistrer un utilisateur, utilisez la méthode `signup`. Cette méthode accepte l’objet options, lequel peut inclure les paramètres suivants :

```html lines
<h2>Signup Database Connection</h2>
<input class="signup-email" />
<input type="password" class="signup-password" />
<input type="button" class="signup-db" value="Signup!" />
<script type="text/javascript">
    $('.signup-db').click(function (e) {
        e.preventDefault();
        webAuth.signup({
            connection: 'Username-Password-Authentication',
            email: $('.signup-email').val(),
            password: $('.signup-password').val(),
            user_metadata: { plan: 'silver', team_id: 'a111' }
        }, function (err) {
            if (err) return alert('Something went wrong: ' + err.message);
            return alert('success signup without login!')
        });
    });
</script>
```

## Les enregistrements devraient être pour les connexions de bases de données. Voici un exemple de la méthode `signup` et un exemple de code pour un formulaire.

En utilisant checkSession pour obtenir de nouveaux jetons

The call to `checkSession` can be used to get a new token for the API that was specified as the <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> when `webAuth` was initialized:

```js lines
webAuth.checkSession({}, function (err, authResult) {
  // err if automatic parseHash fails
  ...
});
```

L’appel à `checkSession` peut être utilisé pour obtenir un nouveau jeton pour l’API définie en tant qu'audience lors de l’initialisation de `webAuth` :

Consultez [Effectuer une extraction de AuthResult et obtenir des informations utilisateur](#extract-the-authresult-and-get-user-info) pour connaître le format de `authResult`.

```js lines
webAuth.checkSession(
  {
    audience: `https://mydomain/another-api/˜`,
    scope: 'read:messages'
  }, function (err, authResult) {
  // err if automatic parseHash fails
  ...
});
```

Note that `checkSession()` triggers any [rules](/docs/customize/rules) you may have set up, so you should check on your rules in the [Dashboard](https://manage.auth0.com/#/rules) prior to using it.

Notez que `checkSession()` déclenche toutes les [règles](/rules) que vous avez définies, vous devez donc vérifier vos règles dans le [Dashboard](%24%7Bmanage_url%7D/#/rules) avant de l’utiliser.

However, the browser **must** have third-party cookies enabled. Otherwise, **checkSession()** is unable to access the current user's session (making it impossible to obtain a new token without displaying anything to the user). The same will happen if users have [Safari's ITP enabled](/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).

Remember to add the URL where the authorization request originates from, to the **Allowed Web Origins** list of your Auth0 application in the [Dashboard](https://manage.auth0.com/#) under your application's **Settings**.

<Warning>

If the connection is a social connection and you are using Auth0 dev keys, the `checkSession` call will always return `login_required`.

</Warning>

### N’oubliez pas d’ajouter l’URL d’où provient la demande d’autorisation à la liste des **Origines Web autorisées** de votre application Auth0 dans le [Dashboard](%24%7Bmanage_url%7D) sous les **Settings (Paramètres)** de votre application.

In some multi-application scenarios, where Single De plus, vous pouvez également obtenir un code d’erreur 403 générique sans propriété `error` ou `error_description`. Le corps de la réponse n’incluera que quelque chose comme ceci : is desired (a user logging out of one application needs to be logged out of other applications), an application can be set up to periodically poll Auth0 using `checkSession()` to see if a session exists. If the session does not exist, you can then log the user out of the application. The same polling method can be used to implement silent authentication for a Single Sign-on (SSO) scenario.

The poll interval between checks to `checkSession()` should be at least 15 minutes between calls to avoid any issues in the future with rate limiting of this call.

## Effectuer un sondage avec checkSessions()

Requêtes de réinitialisation de mot de passe

```js lines
$('.change_password').click(function () {
    webAuth.changePassword({
      connection: 'db-conn',
      email:   'foo@bar.com'
    }, function (err, resp) {
      if(err){
        console.log(err.message);
      }else{
        console.log(resp);
      }
    });
  });
```

Si vous essayez de mettre en place une fonctionnalité de réinitialisation du mot de passe, vous utiliserez la méthode `changePassword` et transmettrez un objet « options », avec un paramètre « connexion » et un paramètre « courriel ».

## L’utilisateur recevra un courriel contenant un lien à cliquer pour réinitialiser leur mot de passe.

The Management API provides functionality that allows you to link and unlink separate user accounts from different providers and update user metadata. For more information, read [User Account Linking](/docs/manage-users/user-accounts/user-account-linking).

To get started, you first need to obtain a an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> that can be used to call the Management API. You can do it by specifying the `https://{yourDomain}/api/v2/` audience when initializing auth0.js, in which case you will get the access token as part of the authentication flow.

If you use [custom domains](/docs/customize/custom-domains), you will need to instantiate a new copy of `webAuth` using your Auth0 domain rather than your custom one, for use with the Management API calls, as it only works with Auth0 domains.

```js lines
var webAuth = new auth0.WebAuth({
  clientID: '{yourClientId}',
  domain: '{yourDomain}',
  redirectUri: 'http://example.com',
  audience: `https://{yourDomain}/api/v2/`,
  scope: 'read:current_user',
  responseType: 'token id_token'
});
```

Si vous utilisez des [domaines personnalisés](/custom-domains), vous devrez instancier une nouvelle copie de `webAuth` en utilisant votre domaine Auth0 plutôt que votre domaine personnalisé, pour l’utiliser avec les appels de Management API, car elle ne fonctionne qu’avec les domaines Auth0.

```js lines
webAuth.checkSession(
  {
    audience: `https://{yourDomain}/api/v2/`,
    scope: 'read:current_user'
  }, function(err, result) {
     // use result.accessToken
  }
);
```

Vous pouvez également le faire à l’aide de `checkSession()` :

* Vous devez spécifier les permissions qui vous sont nécessaires. Vous pouvez demander de suivre les permissions suivantes :
* Vous devez spécifier les permissions qui vous sont nécessaires. Vous pouvez demander de suivre les permissions suivantes :
* `update:current_user_identities`
* `create:current_user_metadata`
* `update:current_user_metadata`
* `update:current_user_metadata`
* `create:current_user_device_credentials`

`create:current_user_device_credentials`

```js lines
var auth0Manage = new auth0.Management({
  domain: '{yourDomain}',
  token: 'ACCESS_TOKEN'
});
```

### Une fois que vous avez le jeton d’accès, vous pouvez créer une nouvelle instance `auth0.Management` en le passant par le domaine Auth0 du compte et le jeton d’accès.

Obtention du profil utilisateur
`auth0Manage.getUser(userId, cb);`

### Pour obtenir les données du profil utilisateur, utilisez la méthode `getUser()`, avec le `userId` et un rappel comme paramètres. La méthode retourne vers le profil utilisateur. Notez que le `userID` requis ici sera le même que celui récupéré par la méthode `client.userInfo`.

When updating user metadata, you will need to first create a `userMetadata` object, and then call the `patchUserMetadata` method, passing it the user id and the `userMetadata` object you created. The values in this object will overwrite existing values with the same key, or add new ones for those that don't yet exist in the user metadata. For more information, read [Metadata](/docs/manage-users/user-accounts/metadata).
`auth0Manage.patchUserMetadata(userId, userMetadata, cb);`

### Pour mettre à jour les métadonnées d’un utilisateur, vous devez d’abord créer un objet `userMetadata`, puis appeler la méthode `patchUserMetadata` en lui transmettant l’identifiant de l’utilisateur et l’objet `userMetadata` que vous avez créé. Les valeurs de cet objet vont remplacer les valeurs de la même clé, et en ajouter de nouvelles pour la même clé, encore en ajouter qui n’existent pas encore pour les métadonnées utilisateur. Consultez la documentation sur les [métadonnées](/users/metadata) pour plus de détails sur les métadonnées utilisateur.

Association des utilisateurs

The `linkUser` method accepts two parameters, the primary `userId` and the secondary user's ID Token (the token obtained after login with this identity). The user ID in question is the unique identifier for the primary user account. The ID should be passed with the provider prefix, e.g., `auth0|1234567890` or `facebook|1234567890`, when using this method. See [User Account Linking](/docs/manage-users/user-accounts/user-account-linking) for details.
`auth0Manage.linkUser(userId, secondaryUserToken, cb);`

La méthode `linkUser` accepte deux paramètres,`userId` principal et le jeton d’ID de l’utilisateur secondaire (le jeton obtenu après la connexion avec cette identité). L’ID utilisateur en question est un identifiant unique pour le compte utilisateur primaire. Si vous utilisez cette méthode, l’identifiant doit être transmis avec le préfixe du fournisseur, par exemple `auth0|1234567890` ou `facebook|1234567890`. Consultez [Association de comptes d’utilisateur](/users/concepts/overview-user-account-linking) pour plus de renseignements.
Après avoir associé les comptes, un second compte n’existera plus en tant qu’entité séparée au niveau de la base de données utilisateur; il ne sera accessible qu’en tant que partie du compte primaire.