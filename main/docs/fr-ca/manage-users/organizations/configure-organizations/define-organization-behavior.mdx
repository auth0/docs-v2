---
title: "Définir le comportement de l’organisation"
permalink: "define-organization-behavior"
'description': "Découvrez comment définir le comportement de l’organisation au sein des applications pour la fonctionnalité Organizations d’Auth0."
'og:title': "Définir le comportement de l’organisation"
'og:description': "Découvrez comment définir le comportement de l’organisation au sein des applications pour la fonctionnalité Organizations d’Auth0."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Définir le comportement de l’organisation"
'twitter:description': "Découvrez comment définir le comportement de l’organisation au sein des applications pour la fonctionnalité Organizations d’Auth0."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Lorsque vous représentez votre application dans Auth0, vous pouvez spécifier les types d’utilisateurs que l’application doit prendre en charge. Certaines applications permettent aux individus de se connecter avec des comptes personnels, tandis que d’autres sont destinées à être utilisées par les membres des [organizations](/docs/fr-ca/manage-users/organizations/organizations-overview). Certains devraient prendre en charge les deux. Ceci est connu sous le nom de comportement d’organisation et peut être défini pour chaque application à laquelle vous vous connectez à Auth0.

Par exemple, votre application pourrait avoir :

* Une page de destination marketing générique qui a un bouton **Se connecter** qui amène vos utilisateurs au flux de connexion Auth0 sans organisation.
* Une URL séparée pour chacun de vos clients B2B (par exemple, les utilisateurs d’Acme accèdent à `acme.yourcompany.com`) qui redirige les utilisateurs vers Auth0 avec une organisation, afin que vos utilisateurs voient le bouton de connexion <Tooltip href="/docs/docs/fr-ca/glossary?term=single-sign-on" tip="Authentification unique (SSO)
Service qui, après qu’un utilisateur se soit connecté à une application, le connecte automatiquement à d’autres applications." cta="Voir le glossaire">SSO</Tooltip> d’Acme.

Vous pouvez définir le comportement de l’organisation pour autoriser l’un ou l’autre de ces scénarios. Vous pouvez également configurer le comportement de l’organisation pour que, si votre application nécessite la spécification d’une organisation, mais que l’utilisateur est accidentellement redirigé vers Auth0 sans qu’une organisation ne soit définie, une invite s’affiche, lui permettant de saisir le nom de son organisation.

Vous pouvez définir le comportement de l’organisation à l’aide du <Tooltip href="/docs/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> ou du <Tooltip href="/docs/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

## Auth0 Dashboard

Pour définir le comportement de l’organisation à partir d’Auth0 Dashboard :

1. Accédez à [Auth0 Dashboard > > Applications](https://manage.auth0.com/#/applications), et sélectionnez l’application pour laquelle vous souhaitez configurer les Organizations.
2. Sélectionnez **Organizations** afficher et configurer les paramètres appropriés :

<table class="table"><thead>
<tr>
<th><strong>Champ</strong></th>
<th><strong>Description</strong></th>
<th><strong>Mappage API</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Type d’utilisateurs</strong>                                                                                                                                                                                                                                </td>
<td>Détermine la catégorie d’utilisateurs qui peuvent se connecter à votre application.<br/><br/> Les options comprennent :<ul><li><strong>Personnes </strong> : Les utilisateurs peuvent s’inscrire avec un compte personnel et se connecter directement à votre application. Les utilisateurs individuels ne peuvent pas se connecter à l’aide d’une organisation.</li><li><strong>Utilisateurs professionnels</strong> : Les utilisateurs doivent être membres d’une organisation pour se connecter. Lorsque vous sélectionnez cette option, vous devez indiquer une organisation lorsque vous redirigez les utilisateurs vers le point de terminaison `/authorize` ou définir votre Flux de connexion à Invite pour organisation. </li><li><strong>Les deux</strong> : Les utilisateurs peuvent se connecter en tant que membre de l’organisation ou s’inscrire avec un compte personnel. </li></ul></td>
<td><strong>Type d’utilisateurs</strong> correspond à `organization_usage`<br/><br/>Options :<ul><li><strong>Personnes</strong> correspond à `deny`</li><li> <strong>Utilisateurs professionnels</strong> correspond à `require`</li><li><strong>Les deux</strong> correspondent à `allow`</li></ul></td>
</tr>
<tr>
<td><strong>Flux de connexion</strong></td>
<td>Détermine l’invite de connexion initiale présentée aux utilisateurs lorsqu’ils accèdent à votre application. Vous ne pouvez configurer ce champ que si le type d’utilisateurs est défini sur Utilisateurs professionnels ou les deux. <br/><br/>Les options comprennent :<ul><li><strong>Invite d’identifiants</strong> : Les utilisateurs sont d’abord invités à fournir leurs identifiants de connexion. Après la connexion, les utilisateurs peuvent sélectionner leur organisation. </li><li><strong>Invite pour organisation</strong> : Les utilisateurs sont d’abord invités à sélectionner leur organisation. Ensuite, ils peuvent fournir leurs identifiants pour se connecter. Vous ne pouvez utiliser cette option que si vous définissez Type d’utilisateurs sur Utilisateurs professionnels. </li><li><strong>Aucune invite</strong> : Auth0 ne dicte pas quelle invite de connexion est donnée aux utilisateurs. Au lieu de cela, votre application est responsable d’envoyer les paramètres requis à Auth0 pour afficher l’invite appropriée.</li></ul></td>
<td><strong>Flux de connexion</strong> correspond à `organization_require_behavior`<br/><br/>Options :<ul><li><strong>Invite d’identifiants</strong> correspond à `post_login_prompt`</li><li> <strong>Invite pour organisation</strong> correspond à `pre_login_prompt`</li><li><strong>Aucune invite</strong> correspond à `no_prompt`</li></ul></td>
</tr>
</tbody>
</table>
3. Sélectionnez **Enregistrer les modifications**.

## Management API

Effectuez une requête `PATCH` au point de terminaison [Mettre à jour un client](/docs/fr-ca/api/management/v2#!/Clients/patch_clients_by_id). Veillez à remplacer les valeurs fictives `client_id`, `mgmt_api_access_token`, `organization_usage`, et `organization_require_behavior` par votre ID client, votre jeton d’accès du Management API, l’option d’utilisation de l’organisation et l’option de comportement de l’organisation, respectivement.

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/clients/CLIENT_ID' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/clients/CLIENT_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/clients/CLIENT_ID"

	payload := strings.NewReader("{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/clients/CLIENT_ID")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/clients/CLIENT_ID',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {
    organization_usage: 'ORG_USAGE',
    organization_require_behavior: 'ORG_REQUIRE_BEHAVIOR'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"organization_usage": @"ORG_USAGE",
                              @"organization_require_behavior": @"ORG_REQUIRE_BEHAVIOR" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/clients/CLIENT_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/clients/CLIENT_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/clients/CLIENT_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/clients/CLIENT_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ "organization_usage": "ORG_USAGE", "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR" }"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "organization_usage": "ORG_USAGE",
  "organization_require_behavior": "ORG_REQUIRE_BEHAVIOR"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/clients/CLIENT_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th>Valeur</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`CLIENT_ID`</td>
<td>Identifiant de l’application pour laquelle vous voulez ajouter le comportement d’organisation.</td>
</tr>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="/docs/docs/fr-ca/tokens/management-api-access-tokens">Jetons d’accès pour Management API</a> avec la permission `update:clients`.</td>
</tr>
<tr>
<td>`ORGANIZATION_USAGE`</td>
<td>Indique si votre application peut prendre en charge les utilisateurs se connectant à une organisation. Options possibles :<ul><li>`deny`: (Par défaut) Les utilisateurs ne peuvent pas se connecter à l’aide d’une organisation.</li><li>`allow`: Les utilisateurs peuvent se connecter avec ou sans organisation. Si cette option est sélectionnée, vous devez indiquer une organisation lorsque vous redirigez les utilisateurs vers le point de terminaison `/authorize`.</li><li>`require`: Les utilisateurs doivent se connecter à l’aide d’une organisation. Si cette option est sélectionnée, vous devez soit indiquer une organisation lorsque vous redirigez les utilisateurs vers le point de terminaison `/authorize`, soit définir `organization_require_behavior` sur `pre_login_prompt` pour autoriser les utilisateurs à choisir une organisation avant de se connecter.</li></ul></td>
</tr>
<tr>
<td>`ORGANIZATION_REQUIRE_BEHAVIOR`</td>
<td>Détermine le flux de connexion présenté aux utilisateurs accédant à votre application. S’applique uniquement si `organization_usage` est définie sur `require` ou `allow`. <br/><br/> Options possibles:<ul><li>`no_prompt`: (Par défaut) Pas d’invite. Les demandes sans paramètre d’organisation valide sont rejetées.</li><li> `pre_login_prompt`: Demande aux utilisateurs de sélectionner une organisation avant de pouvoir se connecter. Vous ne pouvez utiliser cette option que si `organization_usage` est définie sur `require`. </li><li>`post_login_prompt`: Demande aux utilisateurs de se connecter avec leurs identifiants. Après connexion, demande aux utilisateurs de sélectionner leur organisation.</li> </ul></td>
</tr>
</tbody>
</table>

### Codes d’état des réponses

Les codes d’état de réponse possibles sont les suivants  :

<table class="table"><thead>
<tr>
<th>Code d’état</th>
<th>Code d’erreur</th>
<th>Message</th>
<th>Cause</th>
</tr>
</thead>
<tbody>
<tr>
<td>`200`</td>
<td></td>
<td>Client mis à jour avec succès.</td>
<td></td>
</tr>
<tr>
<td>`400`</td>
<td>`invalid_uri`</td>
<td>URI de demande non valide. Le message variera en fonction de la cause.</td>
<td>Le chemin n’est pas valide.</td>
</tr>
<tr>
<td>`400`</td>
<td>`invalid_body`</td>
<td>Corps de la demande non valide. Le message variera en fonction de la cause.</td>
<td>La charge utile de la demande n’est pas valide.</td>
</tr>
<tr>
<td>`401`</td>
<td></td>
<td>Jeton non valide.</td>
<td></td>
</tr>
<tr>
<td>`401`</td>
<td></td>
<td>Le client n’est pas global.</td>
<td></td>
</tr>
<tr>
<td>`401`</td>
<td></td>
<td>Signature non valide reçue pour la validation du jeton Web JSON.</td>
<td></td>
</tr>
<tr>
<td>`403`</td>
<td>`insufficient_scope`</td>
<td>Permission insuffisante; on s’attend à l’un des éléments suivants : `update:clients`.</td>
<td>Tentative de lecture/écriture d’un champ qui n’est pas autorisé avec les permissions de jeton du porteur fourni.</td>
</tr>
<tr>
<td>`403`</td>
<td>`insufficient_scope`</td>
<td>Certains champs ne peuvent pas être mis à jour avec les autorisations accordées par les permissions du jeton porteur. Le message variera en fonction des champs et des permissions.</td>
<td>Tentative de lecture/écriture d’un champ qui n’est pas autorisé avec les permissions de jeton du porteur fourni.</td>
</tr>
<tr>
<td>`403`</td>
<td>`operation_not_supported`</td>
<td>Le compte n’est pas autorisé à effectuer cette opération.</td>
<td>Le compte n’est pas autorisé à effectuer cette opération.</td>
</tr>
<tr>
<td>`404`</td>
<td>`inexistent_client`</td>
<td>Client non trouvé.</td>
<td>Ressource inexistante. L’application spécifiée n’existe pas.</td>
</tr>
<tr>
<td>`429`</td>
<td></td>
<td>Trop de demandes. Vérifiez les en-têtes X-RateLimit-Limit, X-RateLimit-Remaining et X-RateLimit-Reset.</td>
<td></td>
</tr>
</tbody>
</table>