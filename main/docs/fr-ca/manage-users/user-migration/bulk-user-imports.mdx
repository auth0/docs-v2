---
title: "Importation d’utilisateurs par lot"
permalink: "bulk-user-imports"
'description': "Apprenez comment performer importations d’utilisateurs en masse avec le Management API."
'og:title': "Importation d’utilisateurs par lot"
'og:description': "Apprenez comment performer importations d’utilisateurs en masse avec le Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Importation d’utilisateurs par lot"
'twitter:description': "Apprenez comment performer importations d’utilisateurs en masse avec le Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez importer les données des utilisateurs en lot dans Auth0 à l’aide du point de terminaison [Création d’une tâche d’importation d’utilisateurs](/docs/fr-ca/api/management/v2#!/Jobs/post_users_imports). Les importations en lots sont utiles pour migrer les utilisateurs d’une base de données ou d’un service existant vers Auth0.

<Warning>

Si vous essayez d’utiliser plusieurs méthodes de migration (par ex., la migration automatique puis l’importation en bloc d’utilisateurs), vous risquez de rencontrer une erreur `DUPLICATED_USER`. Cette erreur indique que l’utilisateur existe dans le magasin d’utilisateurs interne d’Auth0 mais pas dans votre locataire. Pour corriger cette erreur, supprimez l’utilisateur avec le point de terminaison [Supprimer un utilisateur de connexion](https://auth0.com/docs/api/management/v2#!/Connections/delete_users_by_email) de l’Auth0 Management API, puis réessayez l’importation.

</Warning>

## Prérequis

Avant de lancer la tâche d’importation des utilisateurs :

* Configurez une connexion de base de données dans laquelle importer les utilisateurs et activez-la pour au moins une application.
* Assurez- vous que, si vous importez des mots de passe, ceux-ci sont hachés à l’aide de l’un des algorithmes pris en charge. Les utilisateurs dont les mots de passe sont hachés au moyen d’algorithmes non pris en charge devront réinitialiser leur mot de passe lorsqu’ils se connecteront pour la première fois après l’importation en lot.
* Si vous importez des inscriptions à la <Tooltip href="/docs/docs/fr-ca/glossary?term=multifactor-authentication" tip="Authentification multifacteur (MFA)
Processus d’authentification de l’utilisateur qui utilise un facteur en plus du nom d’utilisateur et du mot de passe, tel qu’un code par SMS." cta="Voir le glossaire">MFA</Tooltip>, assurez-vous qu’il s’agit d’un type pris en charge : `email`, `phone`, ou`totp`.
* [Obtenir un jeton de Management API](/docs/fr-ca/secure/tokens/access-tokens/management-api-access-tokens) pour les requêtes de points de terminaison des tâches.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Si vous utilisez un fichier d’exportation provenant d’un locataire Auth0, vous devez convertir le fichier exporté de `ndjson` en [JSON](https://auth0.com/docs/manage-users/user-migration/bulk-user-exports#json-compatible-format). Pour conserver les mêmes identifiants d’utilisateur, vous devez supprimer le préfixe `auth0|` de tous les identifiants importés.

Le processus d’importation ajoute automatiquement le préfixe `auth0|` aux identifiants d’utilisateur importés. Si vous ne supprimez pas le préfixe `auth0|` avant l’importation, les identifiants sont renvoyés sous la forme `auth0|auth0|...`.

</Callout>

## Créer un fichier JSON pour les utilisateurs

Créez un fichier JSON avec les données de l’utilisateur que vous souhaitez importer dans Auth0. La manière dont vous exportez les données des utilisateurs vers un fichier JSON varie en fonction de votre base de données d’utilisateurs existante. Le point de terminaison de Management API prend charge des sections du fichier JSON. Ainsi, au lieu d’utiliser `fs.readFileSync`, il faut utiliser `fs.createReadStream`. Le point de terminaison attend un flux de lecture en canal au lieu du fichier JSON complet.

Pour en savoir plus sur le schéma du fichier JSON et voir des exemples, consultez [Schéma de la base de données d’importation en lots et exemples](/docs/fr-ca/manage-users/user-migration/bulk-user-import-database-schema-and-examples).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

La limite de la taille des fichiers pour une importation en bloc est de 500 Ko. Vous devrez effectuer l'importation en plusieurs fois (plusieurs fichiers) si vos données dépassent cette taille.

</Callout>

## Requête d’importation d’utilisateurs en lots

Pour lancer un travail d’importation d’utilisateurs en lots, faites une requête `POST` au point de terminaison [Créer une tâche d’importation d’utilisateurs](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports). Veillez à remplacer les valeurs fictives `MGMT_API_ACCESS_TOKEN`, `USERS_IMPORT_FILE.json`, `CONNECTION_ID` et `EXTERNAL_ID` par votre jeton d’accès de <Tooltip href="/docs/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>, le fichier JSON des utilisateurs, le [connection ID](/docs/fr-ca/authenticate/identity-providers/locate-the-connection-id) à la base de données et l’ID externe, respectivement.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-imports' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --form users=@USERS_IMPORT_FILE.json \
  --form connection_id=CONNECTION_ID \
  --form external_id=EXTERNAL_ID
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-imports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "multipart/form-data; boundary=---011000010111000001101001");
request.AddParameter("multipart/form-data; boundary=---011000010111000001101001", "-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-imports"

	payload := strings.NewReader("-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("content-type", "multipart/form-data; boundary=---011000010111000001101001")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-imports")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("content-type", "multipart/form-data; boundary=---011000010111000001101001")
  .body("-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-imports',
  headers: {
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'content-type': 'multipart/form-data; boundary=---011000010111000001101001'
  },
  data: '-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
'
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"content-type": @"multipart/form-data; boundary=---011000010111000001101001" };
NSArray *parameters = @[ @{ @"name": @"users", @"fileName": @"USERS_IMPORT_FILE.json", @"contentType": @"text/json" },
                         @{ @"name": @"connection_id", @"value": @"CONNECTION_ID" },
                         @{ @"name": @"external_id", @"value": @"EXTERNAL_ID" } ];
NSString *boundary = @"---011000010111000001101001";

NSError *error;
NSMutableString *body = [NSMutableString string];
for (NSDictionary *param in parameters) {
    [body appendFormat:@"--%@\r
", boundary];
    if (param[@"fileName"]) {
        [body appendFormat:@"Content-Disposition:form-data; name="%@"; filename="%@"\r
", param[@"name"], param[@"fileName"]];
        [body appendFormat:@"Content-Type: %@\r
\r
", param[@"contentType"]];
        [body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"] encoding:NSUTF8StringEncoding error:&error]];
        if (error) {
            NSLog(@"%@", error);
        }
    } else {
        [body appendFormat:@"Content-Disposition:form-data; name="%@"\r
\r
", param[@"name"]];
        [body appendFormat:@"%@", param[@"value"]];
    }
}
[body appendFormat:@"\r
--%@--\r
", boundary];
NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-imports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-imports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: multipart/form-data; boundary=---011000010111000001101001"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
"

headers = {
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'content-type': "multipart/form-data; boundary=---011000010111000001101001"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-imports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-imports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'multipart/form-data; boundary=---011000010111000001101001'
request.body = "-----011000010111000001101001\r
Content-Disposition: form-data; name="users"; filename="USERS_IMPORT_FILE.json"\r
Content-Type: text/json\r
\r
\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="connection_id"\r
\r
CONNECTION_ID\r
-----011000010111000001101001\r
Content-Disposition: form-data; name="external_id"\r
\r
EXTERNAL_ID\r
-----011000010111000001101001--\r
"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "content-type": "multipart/form-data; boundary=---011000010111000001101001"
]
let parameters = [
  [
    "name": "users",
    "fileName": "USERS_IMPORT_FILE.json",
    "contentType": "text/json"
  ],
  [
    "name": "connection_id",
    "value": "CONNECTION_ID"
  ],
  [
    "name": "external_id",
    "value": "EXTERNAL_ID"
  ]
]

let boundary = "---011000010111000001101001"

var body = ""
var error: NSError? = nil
for param in parameters {
  let paramName = param["name"]!
  body += "--\(boundary)\r
"
  body += "Content-Disposition:form-data; name="\(paramName)""
  if let filename = param["fileName"] {
    let contentType = param["content-type"]!
    let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)
    if (error != nil) {
      print(error)
    }
    body += "; filename="\(filename)"\r
"
    body += "Content-Type: \(contentType)\r
\r
"
    body += fileContent
  } else if let paramValue = param["value"] {
    body += "\r
\r
\(paramValue)"
  }
}

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-imports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th>Paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`users`</td>
<td>Fichier au format JSON contenant les utilisateurs à importer.</td>
</tr>
<tr>
<td>`connection_id`</td>
<td>ID de la connexion à laquelle les utilisateurs seront insérés. Vous pouvez récupérer l’ID en utilisant le point de terminaison <a href="https://auth0.com/docs/api/management/v2#!/Connections/get_connections">GET /api/v2/connections</a>.</td>
</tr>
<tr>
<td>`upsert`</td>
<td>Valeur booléenne; `false` par défaut. Si la valeur est `false`, les utilisateurs préexistants qui correspondent à l’adresse courriel, à l’ID utilisateur, au téléphone ou au nom d’utilisateur échoueront. Lorsque la valeur est définie sur `true`, les utilisateurs préexistants qui correspondent à l’adresse courriel seront mis à jour, mais uniquement avec des attributs pouvant être insérés ou mis à jour. Pour obtenir une liste des champs de profil utilisateur qui peuvent être modifiés lors de l’importation, veuillez consulter <a href="https://auth0.com/docs/users/user-profile-structure#user-profile-attributes">Structure du profil utilisateur : Attributs du profil utilisateur</a>. Remarque : Fournir une entrée utilisateur dupliquée dans le fichier d’importation entraînera une erreur. Dans ce cas, Auth0 n’effectuera pas d’insertion suivie d’une mise à jour.</td>
</tr>
<tr>
<td>`external_id`</td>
<td>Chaîne facultative définie par l’utilisateur et qui peut être utilisée pour corréler plusieurs tâches. Renvoyée dans le cadre de la réponse à l’état de la tâche.</td>
</tr>
<tr>
<td>`send_completion_email`</td>
<td>Valeur booléenne; `true` par défaut. Lorsque la valeur est définie sur `true`, un courriel de confirmation est envoyé à tous les propriétaires de locataires lorsque la tâche d’importation est terminée. Si vous ne souhaitez <em>pas</em> que des courriels soient envoyés, vous devez définir explicitement ce paramètre sur `false`.</td>
</tr>
</tbody>
</table>

Vous recevrez une réponse semblable à celle qui suit si la requête réussit :

```json lines
{
  "status": "pending",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "upsert": false,
  "external_id": "EXTERNAL_ID",
  "send_completion_email": true
}
```

L’entité renvoyée représente la tâche d’importation.

Lorsque la tâche d’importation d’utilisateurs est terminée et si la valeur `send_completion_email` est définie sur `true`, l’administrateur du locataire reçoit un courriel l’informant de l’échec ou de la réussite de la tâche. Un courriel pour un travail qui a échoué peut informer le ou les administrateurs que le fichier JSON des utilisateurs n’a pas été analysé lors de l’importation des utilisateurs.

### Tâches d’importation simultanées

Le point de terminaison [Créer une tâche d’importation d’utilisateurs](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) est limité à deux tâches d’importation simultanées. Si vous demandez des tâches supplémentaires alors que deux sont en attente, vous recevrez une réponse `429 Too Many Requests` :

```json lines
{
  "statusCode": 429,
  "error": "Too Many Requests",
  "message": "There are 2 active import users jobs, please wait until some of them are finished and try again
}
```

## Vérifier l’état de la tâche

Pour vérifier l’état d’une tâche, faites une requête `GET` au point de terminaison [Obtenir une tâche](https://auth0.com/docs/api/management/v2#!/Jobs/get_jobs_by_id). Assurez-vous de remplacer les valeurs fictives `MGMT_API_ACCESS_TOKEN` et `JOB_ID` avec votre jeton d’accès à Management API et l’ID de la tâche d’importation d’utilisateurs.

<AuthCodeGroup>
```bash cURL
curl --request GET \
  --url 'https://{yourDomain}/api/v2/jobs/JOB_ID' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/JOB_ID");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/JOB_ID"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/jobs/JOB_ID")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/jobs/JOB_ID',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/JOB_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/JOB_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN"
    }

conn.request("GET", "/{yourDomain}/api/v2/jobs/JOB_ID", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/JOB_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/JOB_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Vous recevrez une réponse semblable à l’une des suivantes, en fonction de l’état de la tâche d’importation d’utilisateurs :

**En attente**

```javascript lines
{
  "status": "pending",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "external_id": "EXTERNAL_ID"
}
```

**Terminé**

Si une tâche est terminée, la réponse relative à l’état de la tâche comprendra les totaux des enregistrements réussis, échoués, insérés et mis à jour.

```javascript lines
{
  "status": "completed",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "external_id": "EXTERNAL_ID",
  "summary": {
    "failed": 0,
    "updated": 0,
    "inserted": 1,
    "total": 1
  }
}
```

**Échec**

En cas d’erreur dans la tâche, celle-ci sera renvoyée comme ayant échoué. Notez toutefois que des informations utilisateur non valides, telles qu’un courriel non valide, n’entraîneront pas l’échec de l’ensemble de la tâche.

```javascript lines
{
  "status": "failed",
  "type": "users_import",
  "created_at": "",
  "id": "job_abc123",
  "connection_id": "CONNECTION_ID",
  "external_id": "EXTERNAL_ID",
}
```

Pour connaître les détails des entrées qui ont échoué, consultez **Récupérer les saisies qui ont échoué** ci-dessous.

## Délais d’expiration

Toutes les tâches d’importation d’utilisateurs expirent au bout de **deux (2) heures**. Si votre tâche n’est pas terminée pas dans ce délai, elle est marquée comme ayant échoué.

De plus, toutes les données relatives à la tâche sont automatiquement supprimées au bout de 24 heures et ne peuvent plus être consultées par la suite. Pour cette raison, **nous vous conseillons vivement de stocker les résultats des tâches en utilisant le mécanisme de stockage qui vous convient le mieux.**.

## Récupérer les saisies qui ont échoué

<Warning>

Toutes les données relatives au travail sont automatiquement supprimées au bout de 24 heures et ne peuvent plus être consultées par la suite. Pour cette raison, nous vous conseillons vivement de stocker les résultats des travaux en utilisant le mécanisme de stockage qui vous convient le mieux.

</Warning>

Si des erreurs se sont produites dans la tâche d’importation d’utilisateurs, vous pouvez obtenir les détails de l’erreur en effectuant une requête `GET` au point de terminaison [Obtenir le détail des erreurs de la tâche](/docs/fr-ca/api/management/v2#!/Jobs/get_errors). Assurez-vous de remplacer les valeurs fictives `MGMT_API_ACCESS_TOKEN` et `JOB_ID` avec votre jeton d’accès à Management API et l’ID de la tâche d’importation d’utilisateurs.

<AuthCodeGroup>
```bash cURL
curl --request GET \
  --url 'https://{yourDomain}/api/v2/jobs/JOB_ID/errors' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/JOB_ID/errors");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/JOB_ID/errors"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/jobs/JOB_ID/errors")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/jobs/JOB_ID/errors',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/JOB_ID/errors"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/JOB_ID/errors",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN"
    }

conn.request("GET", "/{yourDomain}/api/v2/jobs/JOB_ID/errors", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/JOB_ID/errors")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/JOB_ID/errors")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Vous recevrez une réponse semblable à celle qui suit si la requête réussit : Les champs à caractère confidentiel, tels que `hash.value` seront masqués dans la réponse.

```json lines
[
    {
        "user": {
            "email": "test@test.io",
            "user_id": "7af4c65cb0ac6e162f081822422a9dde",
            "custom_password_hash": {
                "algorithm": "ldap",
                "hash": {
                    "value": "*****"
                }
            }
        },
        "errors": [
            {
                "code": "...",
                "message": "...",
                "path": "..."
            }
        ]
    }
]
```

Chaque objet d’erreur comprendra un code d’erreur et un message expliquant l’erreur plus en détail. Les codes d’erreur possibles sont les suivants :

* ANY_OF_MISSING
* ARRAY_LENGTH_LONG
* ARRAY_LENGTH_SHORT
* CONFLICT
* CONFLICT_EMAIL
* CONFLICT_USERNAME
* CONNECTION_NOT_FOUND
* DUPLICATED_USER
* ENUM_MISMATCH
* FORMAT
* INVALID_TYPE
* MAX_LENGTH
* MAXIMUM
* MFA_FACTORS_FAILED
* MIN_LENGTH
* MINIMUM
* NOT_PASSED
* OBJECT_REQUIRED
* PATTERN

## En savoir plus

* [Configurer la migration automatique à partir de votre base de données](/docs/fr-ca/manage-users/user-migration/configure-automatic-migration-from-your-database)
* [L’extension User Import/Export (Importation/Exportation des utilisateurs).](/docs/fr-ca/manage-users/user-migration/user-import-export-extension)
* [Schéma de base données pour importation d’utilisateurs en lots et exemples](/docs/fr-ca/manage-users/user-migration/bulk-user-import-database-schema-and-examples)
* [Scénarios de migration des utilisateurs](/docs/fr-ca/manage-users/user-migration/user-migration-scenarios)