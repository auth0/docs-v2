---
title: "Exportations d’utilisateurs en masse"
permalink: "bulk-user-exports"
'description': "Apprenez à exporter des listes d’utilisateurs et leurs métadonnées."
'og:title': "Exportations d’utilisateurs en masse"
'og:description': "Apprenez à exporter des listes d’utilisateurs et leurs métadonnées."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Exportations d’utilisateurs en masse"
'twitter:description': "Apprenez à exporter des listes d’utilisateurs et leurs métadonnées."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez utiliser le point de terminaison `POST /api/v2/jobs/users-exports` pour créer une tâche qui exporte tous les utilisateurs associés à une [connexion](/docs/fr-ca/identityproviders), ou tous les utilisateurs du locataire.

Pour une liste des champs de profil utilisateur qui peuvent être importés et exportés, consultez [Structure du profil utilisateur](/docs/fr-ca/manage-users/user-accounts/user-profiles/user-profile-structure).

Lorsque vous créez votre tâche, vous devez fournir ce qui suit :

* [ID de la connexion](/docs/fr-ca/authenticate/identity-providers/locate-the-connection-id) à partir de laquelle vous souhaitez exporter les utilisateurs (facultatif).
* Format du fichier d’exportation (CSV ou compatible JSON).
* Nombre maximum d’enregistrements d’utilisateurs à exporter (facultatif, tous les enregistrements seront exportés si cette information n’est pas fournie).
* Champs associés aux utilisateurs (ID ou nom) que vous voulez inclure dans l’exportation.

Vous aurez également besoin d’un [jeton d’accès à Management API](/docs/fr-ca/api/management/v2/tokens) valide.

## Créer le corps d’une demande

(Facultatif) Recherchez le `connection_id` et le nom de domaine de votre locataire Auth0 dans <Tooltip href="/docs/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip>. Créez un nouveau fichier texte avec le corps de la demande suivant :

```json lines
{
   "connection_id":"connection_id",
   "format":"csv",
   "limit":20,
   "fields":[
      {
         "name":"user_id"
      },
      {
         "name":"email"
      },
      {
         "name":"user_metadata.country"
      }
   ]
}
```

Mettez à jour le `connection_id` avec votre ID de connexion à la base de données, ou supprimez-le pour exporter tous les utilisateurs du locataire.

## Exemple de demande

Permissions requises : `read:users`

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-exports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-exports"

	payload := strings.NewReader("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-exports")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .header("content-type", "application/json")
  .body("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-exports',
  headers: {
    authorization: 'Bearer {yourMgmtAPIAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    connection_id: '{yourConnectionId}',
    format: 'csv',
    limit: 5,
    fields: [{name: 'email'}, {name: 'identities[0].connection', export_as: 'provider'}]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"connection_id": @"{yourConnectionId}",
                              @"format": @"csv",
                              @"limit": @5,
                              @"fields": @[ @{ @"name": @"email" }, @{ @"name": @"identities[0].connection", @"export_as": @"provider" } ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-exports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-exports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}"

headers = {
    'authorization': "Bearer {yourMgmtAPIAccessToken}",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-exports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-exports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'
request["content-type"] = 'application/json'
request.body = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtAPIAccessToken}",
  "content-type": "application/json"
]
let parameters = [
  "connection_id": "{yourConnectionId}",
  "format": "csv",
  "limit": 5,
  "fields": [
    ["name": "email"],
    [
      "name": "identities[0].connection",
      "export_as": "provider"
    ]
  ]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-exports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

La réponse devrait ressembler à ceci :

```json lines
{
  "type": "users_export",
  "status": "pending",
  "connection_id": "con_0000000000000001",
  "format": "csv",
  "limit": 5,
  "fields": [
    {
      "name": "user_id"
    },
    {
      "name": "name"
    },
    {
      "name": "email"
    },
    {
      "name": "identities[0].connection",
      "export_as": "provider"
    }
  ],
  "connection": "Username-Password-Authentication",
  "created_at": "2017-11-02T23:34:03.803Z",
  "id": "job_coRQCC3MHztpuTlo"
}
```

## Inclure les métadonnées des utilisateurs dans le fichier CSV exporté

Si vous exportez des données utilisateur au format CSV et que vous souhaitez inclure des informations sur les métadonnées, indiquez chaque champ de métadonnées que vous souhaitez exporter. Vous pouvez exporter jusqu’à 30 champs.

<Warning>

Vous ne pouvez pas exporter l’intégralité de `app_metadata` ou de `user_metadata` au format CSV. Vous devez préciser explicitement les champs des objets de métadonnées.

Pour exporter `app_metadata` ou `user_metadata` en tant qu’objets uniques, utilisez le format compatible JSON et incluez le champ souhaité dans le paramètre `fields` du corps de la requête. Par exemple :

`{"name":"app_metadata"}`

Comme vous ne pouvez exporter que jusqu’à 30 champs, l’utilisation du format JSON est conseillée si les données utilisateur ont de nombreux champs.

</Warning>

Par exemple, pour des métadonnées structurées comme ceci.

```json lines
{
  "consent": {
      "given": true,
      "date": "01/23/2019",
      "text_details": "{yourURL}"
  }
}
```

La demande d’exportation (pour les trois champs) ressemblerait à ceci.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-exports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-exports"

	payload := strings.NewReader("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-exports")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .header("content-type", "application/json")
  .body("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-exports',
  headers: {
    authorization: 'Bearer {yourMgmtAPIAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    connection_id: '{yourConnectionId}',
    format: 'csv',
    limit: 5,
    fields: [
      {name: 'email'},
      {name: 'user_metadata.consent.given'},
      {name: 'user_metadata.consent.date'},
      {name: 'user_metadata.consent.text_details'}
    ]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"connection_id": @"{yourConnectionId}",
                              @"format": @"csv",
                              @"limit": @5,
                              @"fields": @[ @{ @"name": @"email" }, @{ @"name": @"user_metadata.consent.given" }, @{ @"name": @"user_metadata.consent.date" }, @{ @"name": @"user_metadata.consent.text_details" } ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-exports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-exports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}"

headers = {
    'authorization': "Bearer {yourMgmtAPIAccessToken}",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-exports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-exports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'
request["content-type"] = 'application/json'
request.body = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtAPIAccessToken}",
  "content-type": "application/json"
]
let parameters = [
  "connection_id": "{yourConnectionId}",
  "format": "csv",
  "limit": 5,
  "fields": [["name": "email"], ["name": "user_metadata.consent.given"], ["name": "user_metadata.consent.date"], ["name": "user_metadata.consent.text_details"]]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-exports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Dans les fichiers CSV exportés par l’utilisateur, nous mettons en échappement les données de type chaîne conformément aux normes OWASP pour l’atténuation des injections CSV :

* Les caractères à guillemets simples sont précédés d’un caractère à guillemets doubles.
* Chaque chaîne est précédée d’un caractère à guillemets simples.
* Chaque chaîne est entourée de guillemets doubles.

Cela ne s’applique pas aux dates générées par Auth0 au format ISO 8601.

</Callout>

### Format compatible JSON

Si vous exportez les données au format compatible JSON, vous ne devez fournir que la propriété racine; vous n’avez pas besoin de nommer chaque propriété interne puisqu’elles seront incluses automatiquement.

Les fichiers d’exportation d’Auth0 utilisent le format [NDJSON](https://github.com/ndjson/ndjson-spec) en raison de la taille importante des fichiers d’exportation, tandis que la fonctionnalité d’importation exige un fichier JSON.

Avant de pouvoir importer des utilisateurs en utilisant un export généré par Auth0, vous devrez convertir le fichier de NDJSON à JSON en utilisant la bibliothèque de votre choix (telle que [jq](https://stedolan.github.io/jq/)).

Dans ce cas, pour le même exemple que nous avons utilisé précédemment, la requête ressemblerait à ceci :

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-exports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-exports"

	payload := strings.NewReader("{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-exports")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .header("content-type", "application/json")
  .body("{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-exports',
  headers: {
    authorization: 'Bearer {yourMgmtAPIAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    connection_id: '{yourConnectionId}',
    format: 'json',
    limit: 5,
    fields: [{name: 'email'}, {name: 'user_metadata.consent'}]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"connection_id": @"{yourConnectionId}",
                              @"format": @"json",
                              @"limit": @5,
                              @"fields": @[ @{ @"name": @"email" }, @{ @"name": @"user_metadata.consent" } ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-exports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-exports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}"

headers = {
    'authorization': "Bearer {yourMgmtAPIAccessToken}",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-exports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-exports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'
request["content-type"] = 'application/json'
request.body = "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtAPIAccessToken}",
  "content-type": "application/json"
]
let parameters = [
  "connection_id": "{yourConnectionId}",
  "format": "json",
  "limit": 5,
  "fields": [["name": "email"], ["name": "user_metadata.consent"]]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-exports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

## Vérifier le statut de l’exportation

Une fois que vous avez créé votre job pour exporter vos utilisateurs, vous pouvez vérifier son statut en utilisant le [point de terminaison Get a Job](/docs/fr-ca/api/management/v2#!/Jobs/get_jobs_by_id).

Indiquez l’ID de la tâche (que vous avez reçu dans la réponse lors de la création de la tâche). Si vous utilisez l’exemple de demande ci-dessous, remplacez le paramètre fictif `{yourJobId}` par la valeur de l’ID.

Permissions requises : `create:users`, `read:users`, `create:passwords_checking_job`

<AuthCodeGroup>
```bash cURL
curl --request GET \
  --url 'https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D',
  headers: {authorization: 'Bearer {yourMgmtAPIAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtAPIAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/jobs/%7ByourJobId%7D", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer {yourMgmtAPIAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Vous devriez obtenir une réponse similaire à :

```json lines
{
  "type": "users_export",
  "status": "completed",
  "connection_id": "con_lCvO...a",
  "format": "csv",
  "limit": 5,
  "fields": [
    {
      "name": "user_id"
    },
    {
      "name": "name"
    },
    {
      "name": "email"
    },
    {
      "name": "identities[0].connection",
      "export_as": "provider"
    }
  ],
  "location": "pus3-auth0-export-users-us-east-2.s3.us-east-2.amazonaws.com/job_coRQCC3MHztpuTlo/auth0docs2.csv.gz?Expires=1509725589&Key-Pair-Id=APKAJPL62IJALBDMSSCA&Signature=l2JaFXP~BATnfagb64PK-qbX9QaZREDYNW0q5QeHuV-MaDpZjpABDXfHHLh2SsCMQz~UO-QsCSfI81l0lvCKzZPZL6cZHK7f~ixlZOK~MHKJuvMqsUZMbNluNAwhFmgb2fZ86yrB1c-l2--H3lMELAk7hKUwwSrNBlsfbMgQ-i41nMNnsYdy3AVlNVQkwZyx~w-IEHfJDHsqyjia-jfDbIOLQvr8~D9PwZ-xOzROxDwgxrt3undtz80bkgP5hRKOAbHC7Y-iKWa2bzNZYHqzowTrlh7Ta60cblJR46NfF9cNqn9jqRGVv-lsvUD9FxnImCCk~DL6npJnzNLjHvn4-CaWq6KdQnwWgCnZ3LZkxXDVWLLIQQaoc6i~xbuGnnbtKRePFSnpqbt2mAUYasdxTOWuUVK8wHhtfZmRYtCpwZcElXFO9Qs~PTroYZEiS~UHH5byMLt2x4ChkHnTG7pIhLAHN~bCOLk8BN2lOkDBUASEVtuJ-1i6cKCDqI2Ro9YaKZcCYzeQvKwziX6cgnMchmaZW77~RMOGloi2EffYE31OJHKiSVRK7RGTykaYN5S2Sg7W0ZOlLPKBtCGRvGb8rJ6n3oPUiOC3lSp7v0~dkx1rm-jO8mKWZwVtC0~4DVaXsn8KXNbj0LB4mjKaDHwXs16uH1-aCfFnMK7sZC2VyCU_",
  "connection": "Username-Password-Authentication",
  "created_at": "2017-11-02T23:34:03.803Z",
  "id": "job_coRQCC3MHztpuTlo"
}
```

## Recherche des données d’exportation

Vous pouvez accéder à vos fichiers d’exportation en utilisant l’URL fournie comme valeur du paramètre **location**. Le nom de votre locataire est également le nom de votre fichier. Par exemple, si votre nom de locataire est `auth0docs`, votre fichier sera `auth0docs.csv` ou `auth0docs.json`. Lorsque vous naviguez vers l’URL, le téléchargement du fichier débutera automatiquement.

Le lien de téléchargement est valable pendant 60 secondes. Si ce délai expire, vous disposez de 24 heures pour l’appeler à nouveau avant que la tâche n’expire.

## Nettoyage des travaux

Toutes les données relatives à votre tâche sont automatiquement supprimées au bout de 24 heures et ne sont plus accessibles par la suite. Pour cette raison, **nous vous recommandons vivement de stocker les résultats de vos tâches en utilisant le mécanisme de stockage de votre choix**.