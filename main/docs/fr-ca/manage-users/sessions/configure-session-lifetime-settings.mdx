---
title: "Configuration des paramètres de durée de vie des sessions"
permalink: "configure-session-lifetime-settings"
'description': "Décrit comment configurer les longueurs et limites de session pour un locataire à l’aide du Auth0 Dashboard ou de Management API."
'og:title': "Configuration des paramètres de durée de vie des sessions"
'og:description': "Décrit comment configurer les longueurs et limites de session pour un locataire à l’aide du Auth0 Dashboard ou de Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Configuration des paramètres de durée de vie des sessions"
'twitter:description': "Décrit comment configurer les longueurs et limites de session pour un locataire à l’aide du Auth0 Dashboard ou de Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

**Expiration absolue** L’expiration absolue d’une session est définie lors de la création de la session. Vous pouvez ajuster l’Expiration absolue en configurant les paramètres de session à l’aide du <Tooltip href="/docs/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> ou de <Tooltip href="/docs/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

## Dashboard

1. Allez dans [Tableau de Bord > Paramètres du locataire](https://manage.auth0.com/#/tenant) et cliquez sur l’onglet **Avancé.**
2. Faites défiler l’écran jusqu’à la section **Log In Session Management (Gestion des sessions de connexion)**, recherchez **Inactivity timeout** (Délai d’inac](/docs/images/ **Require log in after** (Connexion requise après), entrez les paramètres souhaités, puis cliquez sur **Save** (Enregistrer).

   <Frame>![Dashboard (Tableau de bord) Tenant Settings (Paramètres de locataire) Advanced (Avancés) Login Session Management (Gestion de session de connexion)](/images/fr-ca/cdy7uua7fh8z/q2fGPzoUqCcXj7OxcHhjy/635dfdd05771d1158e4005d387a30e5c/Session_Expiration_-_FR.png)</Frame>

<table class="table"><thead>
<tr>
<th><strong>Paramètre</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Idle Session Lifetime (Durée de vie de la session inactive)</td>
<td>Délai (en minutes) après lequel la session d’un utilisateur expirera s’il n’a pas interagi avec le serveur d’autorisations. Sera remplacé par les limites du système s’il dépasse 4 320 minutes (3 jours) pour les plans Essential or Professional ou 144 000 minutes (100 jours) pour les plans Entreprise.</td>
</tr>
<tr>
<td>Maximum Session Lifetime (Durée de vie maximale de la session)</td>
<td>Délai (en minutes) après lequel un utilisateur devra se reconnecter, quelle que soit son activité. Sera remplacé par les limites du système s’il dépasse 43 200 minutes (30 jours) pour les plans Essential or Professional ou 525 600 minutes (365 jours) pour les plans Entreprise.</td>
</tr>
</tbody>
</table>

## Management API

Effectuer un appel `PATCH` au [point de terminaison Paramètres du locataire](https://auth0.com/docs/api/management/v2#!/tenants/patch_settings). Assurez-vous de remplacer les valeurs d’espace réservé `MGMT_API_ACCESS_TOKEN`, `SESSION_LIFETIME` et `IDLE_SESSION_LIFETIME` par votre Jeton d’accès à Management API, valeur de durée de vie de la session et la valeur de durée de vie inutilisée de la session, respectivement.

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/tenants/settings' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/tenants/settings");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/tenants/settings"

	payload := strings.NewReader("{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/tenants/settings")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/tenants/settings',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: '{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }'
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };

NSData *postData = [[NSData alloc] initWithData:[@"{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/tenants/settings"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/tenants/settings",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/tenants/settings", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/tenants/settings")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]

let postData = NSData(data: "{ "session_lifetime": SESSION_LIFETIME_VALUE, "idle_session_lifetime": IDLE_SESSION_LIFETIME_VALUE }".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/tenants/settings")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Valeur</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="https://auth0.com/docs/api/management/v2/tokens">Jeton d’accès à Management API</a> avec la permission `update:tenant_settings`.</td>
</tr>
<tr>
<td>`IDLE_SESSION_LIFETIME_VALUE`</td>
<td>Délai (en heure) après lequel la session d’un utilisateur expirera s’il n’a pas interagi avec le serveur d’autorisation. Il sera remplacé par les limites du système, si plus de 72 heures (3 jours) pour les plans Essential ou Professional ou 2400 heures (100 jours) pour les plans Enterprise.</td>
</tr>
<tr>
<td>`SESSION_LIFETIME_VALUE`</td>
<td>Délai (en heures) après lequel un utilisateur devra se reconnecter, sans tenir compte de son activité. Il sera remplacé par les limites du système, si plus de 720 heures (30 jours) pour les plans Essential ou Professional ou 8760 heures (365 jours) pour les plans Enterprise.</td>
</tr>
</tbody>
</table>

Pour obtenir une aide au dépannage, consultez [Vérifier les appels d’API](/docs/fr-ca/troubleshoot/authentication-issues/check-api-calls).

## En savoir plus

* [Couches de sessions](/docs/fr-ca/manage-users/sessions/session-layers)
* [Sessions non persistantes](/docs/fr-ca/manage-users/sessions/non-persistent-sessions)