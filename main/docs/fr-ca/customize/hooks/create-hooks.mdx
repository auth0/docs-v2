---
title: "Création de hooks"
permalink: "create-hooks"
'description': "Comment créer des hooks à l’aide de Dashboard et Management API. Les hooks peuvent également être importés et exportés à l’aide de l’outil de déploiement d’interface de ligne de commande (Command-Line Interface, CLI) Auth0."
'og:title': "Création de hooks"
'og:description': "Comment créer des hooks à l’aide de Dashboard et Management API. Les hooks peuvent également être importés et exportés à l’aide de l’outil de déploiement d’interface de ligne de commande (Command-Line Interface, CLI) Auth0."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Création de hooks"
'twitter:description': "Comment créer des hooks à l’aide de Dashboard et Management API. Les hooks peuvent également être importés et exportés à l’aide de l’outil de déploiement d’interface de ligne de commande (Command-Line Interface, CLI) Auth0."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Warning>

La date de fin de vie (EOL) des Règles et des Appels sera le **18 novembre 2026**. Ils ne sont plus disponibles pour les nouveaux locataires créés à partir du **16 octobre 2023**. Les locataires actuels ayant des hooks actifs conserveront l’accès aux produit Hooks jusqu’à la fin de leur durée de vie.

Nous vous conseillons vivement d’utiliser les Actions pour étendre Auth0. Avec les Actions, vous avez accès à des informations de type enrichies, à une documentation intégrée et à des packages `npm` publics, et vous pouvez connecter des intégrations externes qui optimisent votre expérience d’extensibilité globale. Pour en savoir plus sur ce que les Actions proposent, consultez [Comprendre comment fonctionnent Auth0 Actions](/docs/fr-ca/customize/actions/actions-overview).

Pour vous aider dans votre migration, nous proposons des guides qui vous aideront à [migrer des Règles vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions) et à [migrer des Hooks vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions). Nous avons également une page dédiée à la [Migration vers les Actions](https://auth0.com/extensibility/movetoactions) qui met en évidence les comparaisons de fonctionnalités, [une démo des Actions](https://www.youtube.com/watch?v=UesFSY1klrI)  et d’autres ressources pour vous aider dans votre parcours de migration.

Pour en savoir plus sur l’obsolescence des Règles et des Appels, consultez notre article de blog : [Preparing for Rules and Hooks End of Life (Préparation à la fin de vie des règles et des crochets)](https://auth0.com/blog/preparing-for-rules-and-hooks-end-of-life/).

</Warning>

<Warning>

Comme nous prévoyons de supprimer les fonctions Règles et Hooks en 2026, vous devez créer de nouvelles Règles ou de nouveaux Hooks uniquement dans votre environnement de développement et uniquement pour tester la migration vers les Actions.

Pour apprendre à migrer vos Règles vers des Actions, consultez [Migrer des règles vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions). Pour apprendre à migrer vos Hooks vers des Actions, consultez la section [Migrer des Hooks vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions).

</Warning>

Vous pouvez créer plusieurs hooks à l’aide de Dashboard et <Tooltip href="/docs/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

Vous pouvez également importer et exporter des hooks à l’aide de l’outil Deploy CLI.

<Warning>

Bien que vous puissiez créer plusieurs hooks pour un point d’extensibilité donné, chaque point d’extensibilité ne peut avoir qu’un seul hook activé à la fois. Tous les appels ultérieurs que vous créez pour ce point d’extensibilité sont automatiquement désactivés. Vous devez donc les activer explicitement. Le hook activé sera exécuté pour toutes les applications et API.

</Warning>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

En option, vous pouvez ajouter des secrets (tels que des clés Twilio ou des chaînes de connexion à la base de données) aux hooks.

</Callout>

## Utiliser Dashboard

1. Allez à [Tableau de bord Auth0 > Pipeline Auth > Crochets](https://manage.auth0.com/#/hooks), et cliquez sur **+Créer**.
2. Saisissez un nom descriptif pour votre hook, sélectionnez le point d’extensibilité pour lequel le hook doit s’exécuter, et cliquez sur **Créer**.
3. Localisez la section correspondant au point d’extensibilité que vous avez sélectionné et cliquez sur l’icône en forme de crayon à côté du hook que vous avez créé.
4. Mettez à jour le hook à l’aide du Éditeur de hooks et cliquez sur l’icône de disquette pour l’enregistrer.

## Utiliser Management API

Effectuez un appel `POST` au point de terminaison [Créer un point de terminaison de hook](/docs/fr-ca/api/management/v2/#!/Hooks/post_hooks). Veillez à remplacer les paramètres fictifs `MGMT_API_ACCESS_TOKEN`, `HOOK_NAME`, `HOOK_SCRIPT` et `EXTENSIBILITY_POINT_NAME` par votre jeton d’accès à Management API, le nom de l’appel, le script du hook et le nom du point d’extensibilité, respectivement.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/hooks' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/hooks");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/hooks"

	payload := strings.NewReader("{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/hooks")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/hooks',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {
    name: 'HOOK_NAME',
    script: 'HOOK_SCRIPT',
    triggerId: 'EXTENSIBILITY_POINT_NAME'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"name": @"HOOK_NAME",
                              @"script": @"HOOK_SCRIPT",
                              @"triggerId": @"EXTENSIBILITY_POINT_NAME" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/hooks"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/hooks",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("POST", "/{yourDomain}/api/v2/hooks", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "triggerId": "EXTENSIBILITY_POINT_NAME" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("POST", "/{yourDomain}/api/v2/hooks", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "name": "HOOK_NAME",
  "script": "HOOK_SCRIPT",
  "triggerId": "EXTENSIBILITY_POINT_NAME"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/hooks")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Valeur</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td>Jeton d’accès à Management API avec la <dfn id="react-containers-DefinitionTooltip-1"><span class="tooltip-portal-underlined-word" data-react-universal-portal="">permission</span></dfn> `create:hooks`. Pour en savoir plus, lisez <a href="/docs/docs/fr-ca/api/management/v2/tokens">Jeton d’accès à Management API</a>.</td>
</tr>
<tr>
<td>`HOOK_NAME`</td>
<td>Nom de l’appel à créer.</td>
</tr>
<tr>
<td>`HOOK_SCRIPT`</td>
<td>Script contenant le code de l’appel. Doit correspondre à ce que vous entreriez si vous créiez un nouvel appel en utilisant le Dashboard.</td>
</tr>
<tr>
<td>`EXTENSIBILITY_POINT_NAME`</td>
<td>Nom du point d’extensibilité pour lequel l’appel doit s’exécuter. Options à inclure : `credentials-exchange`, `pre-user-registration`, `post-user-registration`, `post-change-password`. Pour en savoir plus sur les points d’extensibilité, lisez <a href="/docs/docs/fr-ca/hooks/extensibility-points">Points d’extensibilité</a>.</td>
</tr>
</tbody>
</table>

<Card title="Gérer les limitations de taux lors d’une requête API depuis un Hook">

Si vous faites une requête API Auth0 à partir d’un script de Hook, vous devrez gérer les limitations de taux. Pour ce faire, vérifiez l’en-tête `X-RateLimit-Remaining` et gérez la situation de manière adéquate lorsque le numéro retourné s’approche de 0.

De plus, ajoutez le code nécessaire pour gérer les cas dans lesquels vous dépassez les limites de taux et recevez un code de statut HTTP `429`(`Too Many Requests`). Dans ce cas, si une nouvelle requête est nécessaire, il est recommandé de prévoir un délai d’attente pour éviter de se retrouver dans une boucle infinie de tentatives.

</Card>

Pour en savoir plus sur la limite anti-attaques d’Auth0 pour les hooks, lisez Limites anti-attaques.

## En savoir plus

* [Migrer des Hooks vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions)