---
title: "Gérer les facteurs d’authentification avec l’Authentication API"
permalink: "manage-authenticator-factors-mfa-api"
'description': "Décrit la façon de gérer les inscriptions de facteurs d’authentification MFA pour les applications en utilisant l’API MFA Auth0."
'og:title': "Gérer les facteurs d’authentification avec l’Authentication API"
'og:description': "Décrit la façon de gérer les inscriptions de facteurs d’authentification MFA pour les applications en utilisant l’API MFA Auth0."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Gérer les facteurs d’authentification avec l’Authentication API"
'twitter:description': "Décrit la façon de gérer les inscriptions de facteurs d’authentification MFA pour les applications en utilisant l’API MFA Auth0."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Card title="Before you start">

* Activez le type d’autorisation **MFA** pour votre application. Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types).

</Card>

Auth0 fournit plusieurs [Points de terminaison API](/docs/fr-ca/api/authentication#multi-factor-authentication) pour vous aider à gérer les authentifiants que vous utilisez avec une application pour l’authentification multifacteur (<Tooltip href="/docs/docs/fr-ca/glossary?term=multifactor-authentication" tip="Authentification multifacteur (MFA)
Processus d’authentification de l’utilisateur qui utilise un facteur en plus du nom d’utilisateur et du mot de passe, tel qu’un code par SMS." cta="Voir le glossaire">MFA</Tooltip>). Vous pouvez utiliser ces points de terminaison pour créer une interface utilisateur complète permettant aux utilisateurs de gérer leurs facteurs d’authentification.

## Obtention des jetons d’accès API MFA

Pour appeler l’API MFA afin de gérer les enregistrements, vous devez d’abord obtenir un jeton d’accès pour l’API MFA.

Pour utiliser l’API MFA dans le cadre d’un flux d’authentification, vous pouvez suivre les étapes détaillées dans [Authentification avec l’octroi du mot de passe du propriétaire de la ressource et MFA](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa). Si vous construisez une interface utilisateur pour gérer les facteurs d’authentification, vous devrez obtenir un jeton que vous pourrez utiliser pour l’API MFA à tout moment, pas seulement pendant l’authentification.

Si vous utilisez [Universal Login (Connexion universelle)](/docs/fr-ca/authenticate/login/auth0-universal-login), redirigez l’utilisateur vers le point de terminaison Authorize, en spécifiant le public `https://{yourDomain}/mfa/`, avant d’appeler l’API MFA.

### Connexion universelle

Si vous utilisez [Connexion universelle](/docs/fr-ca/authenticate/login/auth0-universal-login), redirigez l'utilisateur vers le point de terminaison Authorize, en spécifiant l'<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" tip="">audience</Tooltip> `https://{yourDomain}/mfa/`, avant d'appeler l'API MFA.

<Warning>

Lorsque `https://{yourDomain}/mfa/` est spécifié en tant que l'audience, l’authentification multifactorielle (MFA) est appliquée. Lorsque les utilisateurs finaux activent **Remember this browser(Se souvenir de ce navigateur)** alors que `.../mfa` est spécifié comme audience, le paramètre n’aura aucun effet.

Auth0 recommande que les administrateurs de locataire  [créent une action](https://auth0.com/docs/customize/actions/write-your-first-action)qui définit `allowRememberBrowser` sur false (faux). Cela masquera l’option **Remember this browser (Se souvenir de ce navigateur)** dans l’expérience de l’utilisateur final.

</Warning>

### Octroi par mot de passe du propriétaire de la ressource

Si vous utilisez la méthode de la Subvention du Propriétaire de la Ressource (<Tooltip href="/docs/docs/fr-ca/glossary?term=resource-owner" tip="Propriétaire de ressources
Entité (telle qu’un utilisateur ou une application) capable d’accorder l’accès à une ressource protégée." cta="Voir le glossaire">Resource Owner</Tooltip> Password Grant/ROPG), vous disposez de 3 options :

* Lors de la connexion, faites appel à l'audience `https://{yourDomain}/mfa/` et utilisez un [jeton d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens) pour l’actualiser plus tard.
* Si vous devez répertorier et supprimer des authentifiants, demandez à l’utilisateur de [s’authentifier à nouveau](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa) avec `/oauth/token`, en spécifiant l'audience `https://{yourDomain}/mfa/`. Les utilisateurs devront effectuer une authentification multifacteur avant de pouvoir répertorier et/ou supprimer les facteurs d’authentification.
* Si vous avez uniquement besoin de répertorier les authentifiants, demandez à l’utilisateur de [s’authentifier à nouveau](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa) en utilisant `/oauth/token` avec nom d’utilisateur/mot de passe. Le point de terminaison renverra une erreur `mfa_required` et un `mfa_token` que vous pouvez utiliser pour répertorier les authentifiants. Les utilisateurs devront fournir leur mot de passe pour voir leurs authentifiants.

### Permissions

Lorsque vous demandez un jeton pour l'audience MFA, vous pouvez demander les permissions suivantes :

<table class="table"><thead>
<tr>
<th>Permission</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`enroll`</td>
<td>Pour inscrire un nouvel authentificateur.</td>
</tr>
<tr>
<td>`read:authenticators`</td>
<td>Pour répertorier les authentificateurs existants.</td>
</tr>
<tr>
<td>`remove:authenticators`</td>
<td>Pour supprimer un authentificateur.</td>
</tr>
</tbody>
</table>

## Répertorier les authentifiants

Pour obtenir une liste des authentifiants pour un utilisateur, vous pouvez appeler le point de terminaison des authentifiants MFA :

<AuthCodeGroup>
```bash cURL
curl --request GET \
  --url 'https://{yourDomain}/mfa/authenticators' \
  --header 'authorization: Bearer MFA_TOKEN'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/mfa/authenticators");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer MFA_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/mfa/authenticators"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer MFA_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.get("https://{yourDomain}/mfa/authenticators")
  .header("authorization", "Bearer MFA_TOKEN")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/mfa/authenticators',
  headers: {authorization: 'Bearer MFA_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer MFA_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/mfa/authenticators"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/mfa/authenticators",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MFA_TOKEN"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer MFA_TOKEN" }

conn.request("GET", "/{yourDomain}/mfa/authenticators", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/mfa/authenticators")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer MFA_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer MFA_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/mfa/authenticators")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Dans la réponse, vous devriez recevoir des informations concernant le(s) type(s) d’authentifiants :

```json lines
[
  {
    "authenticator_type": "recovery-code",
    "id": "recovery-code|dev_IsBj5j3H12VAdOIj",
    "active": true
  },
  {
    "authenticator_type": "otp",
    "id": "totp|dev_nELLU4PFUiTW6iWs",
    "active": true,
  },
  {
    "authenticator_type": "oob",
    "oob_channel": "sms",
    "id": "sms|dev_sEe99pcpN0xp0yOO",
    "name": "+1123XXXXX",
    "active": true
  }
]
```

Avec comme objectif de créer une interface utilisateur permettant aux utilisateurs finaux de gérer leurs facteurs, vous devriez ignorer les authentifiants dont le paramètre `active` est défini sur `false`. Ces authentifiants ne sont pas confirmés par les utilisateurs. Ils ne peuvent donc pas être utilisés pour exiger une authentification multifacteur.

L’API MFA répertoriera les inscriptions suivantes selon le type d’authentifiant :

<table class="table"><thead>
<tr>
<th>Authentifiant</th>
<th>Actions</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Push et OTP</strong></td>
<td>Si le les notifications poussées sont activées, Auth0 crée également un enregistrement OTP. Vous verrez les deux lors de la liste des inscriptions.</td>
</tr>
<tr>
<td><strong>SMS et voix</strong></td>
<td>Si le SMS et la voix sont tous deux activés, lorsqu’un utilisateur s’inscrit par SMS ou par la voix, Auth0 crée automatiquement deux authentifiants pour le numéro de téléphone, un pour le SMS et un autre pour la voix.</td>
</tr>
<tr>
<td><strong>Courriel</strong></td>
<td>Tous les courriels seront enregistrés en tant qu’authentifiants.</td>
</tr>
</tbody>
</table>

## Inscrire des authentifiants

Consultez les liens suivants pour obtenir des détails sur la façon d’inscrire des authentifiants pour différents facteurs :

* [SMS ou voix](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)
* [Mot de passe à usage unique (OTP)](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)
* [Push](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)
* [Courriel](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)

Vous pouvez également utiliser le [Flux de connexion universelle](/docs/fr-ca/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) pour abonner des utilisateurs à tout moment.

## Supprimer des authentifiants

Pour supprimer un authentifiant associé, envoyez une demande `DELETE` au point de terminaison des authentifiants MFA remplaçant `AUTHENTICATOR_ID` avec l’ID d’authentifiant qui convient. Vous pouvez obtenir l'ID lorsque vous répertoriez les facteurs d'authentification.

Si un `mfa_token` a été utilisé pour répertorier les authentifiants, les utilisateurs devront [compléter MFA pour obtenir un jeton d’accès](https://auth0.com/docs/fr-ca/api/authentication/muti-factor-authentication/verify-mfa-with-otp) avec une audience de `https://{yourDomain}/mfa/` afin de supprimer un authentifiant.

<AuthCodeGroup>
```bash cURL
curl --request DELETE \
  --url 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID' \
  --header 'authorization: Bearer ACCESS_TOKEN'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID");
var request = new RestRequest(Method.DELETE);
request.AddHeader("authorization", "Bearer ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("authorization", "Bearer ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.delete("https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID")
  .header("authorization", "Bearer ACCESS_TOKEN")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'DELETE',
  url: 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID',
  headers: {authorization: 'Bearer ACCESS_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"DELETE"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "DELETE",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer ACCESS_TOKEN"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer ACCESS_TOKEN" }

conn.request("DELETE", "/{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Delete.new(url)
request["authorization"] = 'Bearer ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer ACCESS_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Si l’authentifiant a été supprimé, une réponse 204 est renvoyée.

Lorsque vous supprimez un authentifiant, les actions suivantes ont lieu selon le type d’authentifiant :

Pour supprimer un code de récupération et en générer un nouveau, obtenez un [Jeton d’accès à Management API](https://auth0.com/docs/api/management/v2/tokens) Autho et utiliser <Tooltip href="/docs/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip> [Point de terminaison de régénération du code de récupération](https://auth0.com/docs/api/management/v2/#!/Users/post_recovery_code_regeneration).

## Régénérer des codes de récupération

Pour supprimer un code de récupération et en générer un nouveau, obtenez un [Jeton d’accès à Management API](https://auth0.com/docs/api/management/v2/tokens) et utiliser le [point de terminaison de régénération](https://auth0.com/docs/api/management/v2/#!/Users/post_recovery_code_regeneration) Management API.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration' \
  --header 'authorization: Bearer MANAGEMENT_API_TOKEN'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer MANAGEMENT_API_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration"

	req, _ := http.NewRequest("POST", url, nil)

	req.Header.Add("authorization", "Bearer MANAGEMENT_API_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration")
  .header("authorization", "Bearer MANAGEMENT_API_TOKEN")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration',
  headers: {authorization: 'Bearer MANAGEMENT_API_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer MANAGEMENT_API_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MANAGEMENT_API_TOKEN"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer MANAGEMENT_API_TOKEN" }

conn.request("POST", "/{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer MANAGEMENT_API_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer MANAGEMENT_API_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Vous obtiendrez un nouveau code de récupération que l’utilisateur final devra enregistrer, par exemple :

```json lines
{  
   "recovery_code": "FA45S1Z87MYARX9RG6EVMAPE"
}
```

## En savoir plus

* [Facteurs d’authentification SMS et vocaux pour l’inscription et les défis de connexion](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)
* [Inscription et défi des authentificateurs OTP](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)
* [Inscrire et lancer un défi-réponse pour les authentifiants Push](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)
* [Inscription et authentifiants par défi-réponse avec courriel](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)
* [Défi-réponse avec les codes de récupération](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)