---
title: "API Python : Autorisation"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";


##### Par Luciano Balmaceda

Ce tutoriel explique comment ajouter une autorisation à une API Python développée avec Flask. Nous vous recommandons de vous connecter pour suivre ce guide de démarrage rapide avec des exemples configurés pour votre compte.

{/* <Card title="View on Github" href="https://github.com/auth0-samples/auth0-python-api-samples/tree/master/00-Starter-Seed" icon="github">
Configuration système requise : Python 3.6 et versions ultérieures | Flask 2.0 | Authlib 1.0

</Card> */}

<Info>

**Vous découvrez Auth0 ?** Apprenez [comment fonctionne Auth0](/docs/get-started/auth0-overview) et consultez [la mise en œuvre de l'authentification et de l'autorisation API](/docs/get-started/authentication-and-authorization-flow) à l'aide du framework OAuth 2.0.

</Info>

## Configurer les API Auth0

### Créer une API

Dans la section [API](https://manage.auth0.com/#/apis) du tableau de bord Auth0, cliquez sur **Créer une API**. Indiquez un nom et un identifiant pour votre API, par exemple : `https://quickstarts/api`. Vous utiliserez cet identifiant comme « audience » ultérieurement, lors de la configuration de la vérification du jeton d’accès. Laissez l’**algorithme de signature** sur **RS256**.

<Frame> ![Créer une API](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/create-api.png) </Frame>

Par défaut, votre API utilise RS256 comme algorithme de signature des jetons. RS256 utilisant une paire de clés privée/publique, il vérifie les jetons à l'aide de la clé publique de votre compte Auth0. Cette clé publique est au format JWKS (JSON Web Key Set) et est accessible ici : [https://{yourDomain}/.well-known/jwks.json].

### Définir les autorisations

Les permissions vous permettent de définir comment les ressources sont accessibles à un utilisateur disposant d'un jeton d'accès donné. Par exemple, vous pouvez accorder un accès en lecture à la ressource `messages` aux utilisateurs ayant le niveau d'accès gestionnaire, et un accès en écriture à cette ressource aux utilisateurs ayant le niveau d'accès administrateur.

Vous pouvez définir les permissions autorisées dans la vue **Permissions** de la section [APIs](https://manage.auth0.com/#/apis) du tableau de bord Auth0.

<Frame> ![Configurer les permissions](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/configure-permissions.png) </Frame>

<Info>

Cet exemple utilise la portée `read:messages`.

</Info>

Cet exemple illustre :

* Comment vérifier la présence d'un jeton Web JSON (JWT) dans l'en-tête `Authorization` d'une requête HTTP entrante.
* Comment vérifier la validité d'un jeton à l'aide du [JSON Web Key Set (JWKS)](/docs/secure/tokens/json-web-tokens/json-web-key-sets) de votre compte Auth0 ? Pour en savoir plus sur la validation des jetons d'accès, consultez la section [Valider les jetons d'accès](/docs/secure/tokens/access-tokens/validate-access-tokens).

## Valider les jetons d'accès

### Installer les dépendances

Ajoutez les dépendances suivantes à votre fichier `requirements.txt` :

```lignes txt
# /requirements.txt

flask==2.3.3
python-dotenv
pyjwt
flask-cors
six
```

### Créer une application Flask

Créez un fichier `server.py` et initialisez l'application [Flask](http://flask.pocoo.org/). Définissez le domaine, l'audience et la gestion des erreurs.

export const codeExample = `# /server.py

import json
from six.moves.urllib.request import urlopen
from functools import wraps

from flask import Flask, request, jsonify, _request_ctx_stack
from flask_cors import cross_origin
import jwt

AUTH0_DOMAIN = '{yourDomain}'
API_AUDIENCE = YOUR_API_AUDIENCE
ALGORITHMS = ["RS256"]

APP = Flask(__name__)

# Gestionnaire d'erreurs
class AuthError(Exception):

def __init__(self, error, status_code):

self.error = error

self.status_code = status_code

@APP.errorhandler(AuthError)
def handle_auth_error(ex):

response = jsonify(ex.error)

response.status_code = ex.status_code

return response`;

<AuthCodeBlock children={codeExample} language="py" filename="Python" />

### Créer le décorateur de validation JWT

Ajouter un décorateur qui vérifie le jeton d'accès par rapport à votre JWKS.

```py Lignes Python
# /server.py

# Formater la réponse d'erreur et ajouter le code d'état
def get_token_auth_header():

""Obtient le jeton d'accès à partir de l'en-tête d'autorisation

"""
auth = request.headers.get("Authorization", None)

if not auth:

raise AuthError({"code": "authorization_header_missing",

"description":

"L'en-tête d'autorisation est attendu"}, 401)

parts = auth.split()

if parts[0].lower() != "bearer":

raise AuthError({"code": "invalid_header",

"description":

"L'en-tête d'autorisation doit commencer par"
" Bearer"}, 401)

elif len(parts) == 1:

raise AuthError({"code": "invalid_header",

"description": "Jeton introuvable"}, 401)

elif len(parts) > 2:

raise AuthError({"code": "invalid_header",

"description":

"L'en-tête d'autorisation doit être"
" Bearer token"}, 401)

token = parts[1]

return token

def requires_auth(f):

""Détermine si le jeton d'accès est valide

"""
@wraps(f)

def decorated(*args, **kwargs):

token = get_token_auth_header()

jsonurl = urlopen("https://"+AUTH0_DOMAIN+"/.well-known/jwks.json")

jwks = json.loads(jsonurl.read())

unverified_header = jwt.get_unverified_header(token)

public_key = None

for key in jwks["keys"]:

si key["kid"] == unverified_header["kid"]:

public_key = jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(jwk))

si public_key:

try:

payload = jwt.decode(

token,

public_key,

algorithms=ALGORITHMS,

audience=API_AUDIENCE,

issuer="https://"+AUTH0_DOMAIN+"/"

)

sauf jwt.ExpiredSignatureError:

raise AuthError({"code": "token_expired",

"description": "token is expired"}, 401)

sauf jwt.InvalidAudienceError:

raise AuthError({"code": "invalid_audience",

"description":

"incorrect audience,"
" Veuillez vérifier l'audience"}, 401)

except jwt.InvalidIssuerError

raise AuthError({"code": "invalid_issuer",

"description":

"émetteur incorrect",

" veuillez vérifier l'émetteur"}, 401)

except Exception:

raise AuthError({"code": "invalid_header",

"description":

"Impossible d'analyser le jeton d'authentification"
"".}, 401)

_request_ctx_stack.top.current_user = payload

return f(*args, **kwargs)

raise AuthError({"code": "invalid_header",

"description": "Impossible de trouver la clé appropriée"}, 401)

return decorated
```






### Valider les portées

Les routes individuelles peuvent être configurées pour rechercher une `scope` particulière dans le jeton d'accès en utilisant ce qui suit :

```py Lignes Python
# /serveur.py

def requires_scope(required_scope):

""Détermine si l'étendue requise est présente dans le jeton d'accès.

Arguments :

required_scope (str) : L'étendue requise pour accéder à la ressource.

""
token = get_token_auth_header()

unverified_claims = jwt.decode(token, options={"verify_signature": False})

if unverified_claims.get("scope"):

token_scopes = unverified_claims["scope"].split()

for token_scope in token_scopes:

if token_scope == required_scope:

return True

return False
```

## Protection des points de terminaison d'API

Les routes ci-dessous sont disponibles pour les requêtes suivantes :

* `GET /api/public` : disponible pour les requêtes non authentifiées

* `GET /api/private` : disponible pour les requêtes authentifiées contenant un jeton d'accès sans étendue supplémentaire

* `GET /api/private-scoped` : disponible pour les requêtes authentifiées contenant un jeton d'accès avec l'étendue `read:messages` accordée

Vous pouvez utiliser les décorateurs et les fonctions définis ci-dessus dans les points de terminaison correspondants.

``py Lignes Python

# API des contrôleurs

# Ceci ne nécessite pas d'authentification

@APP.route("/api/public")

@cross_origin(headers=["Content-Type", "Authorization"])
def public():

response = "Bonjour depuis un point de terminaison public ! Vous n'avez pas besoin d'être authentifié pour voir ceci."

return jsonify(message=response)

# Authentification requise
@APP.route("/api/private")
@cross_origin(headers=["Content-Type", "Authorization"])
@requires_auth
def private():

response = "Bonjour depuis un point de terminaison privé ! Vous devez être authentifié pour voir ce message."

return jsonify(message=response)

# Autorisation requise
@APP.route("/api/private-scoped")
@cross_origin(headers=["Content-Type", "Authorization"])
@requires_auth
def private_scoped():

if requires_scope("read:messages"):

response = "Bonjour depuis un point de terminaison privé ! Vous devez être authentifié et disposer de l'autorisation read:messages pour voir ce message."

return jsonify(message=response)

raise AuthError({

"code": "Non autorisé",

"description": "Vous n'avez pas accès à cette ressource"

}, 403)
```

<Info>
##### Que pouvez-vous faire ensuite ?
<table>
  <tr>
    <td><a href="/docs/authenticate/identity-providers">Configurer d'autres fournisseurs d'identité</a></td>
    <td><a href="/docs/secure/multi-factor-authentication">Activer l'authentification multifacteur</a></td>
  </tr>
  <tr>
    <td><a href="/docs/secure/attack-protection">En savoir plus sur la protection contre les attaques</a></td>
    <td><a href="/docs/customize/rules">En savoir plus sur les règles</a></td>
  </tr>
<durée </table>

[Modifier sur GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/backend/aspnet-core-webapi/01-authorization.md)
</Info>
---
