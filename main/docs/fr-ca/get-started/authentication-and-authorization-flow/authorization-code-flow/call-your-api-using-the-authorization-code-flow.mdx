---
title: "Appeler votre API à l’aide du flux de code d’autorisation"
permalink: "call-your-api-using-the-authorization-code-flow"
'description': "Apprenez à appeler votre propre API à partir d’applications Web standard à l’aide du flux de code d’autorisation."
'og:title': "Appeler votre API à l’aide du flux de code d’autorisation"
'og:description': "Apprenez à appeler votre propre API à partir d’applications Web standard à l’aide du flux de code d’autorisation."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Appeler votre API à l’aide du flux de code d’autorisation"
'twitter:description': "Apprenez à appeler votre propre API à partir d’applications Web standard à l’aide du flux de code d’autorisation."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Ce tutoriel vous aidera à appeler votre propre API en utilisant le flux de code d’autorisation. Pour en savoir plus sur le fonctionnement du flux et pourquoi l’utiliser, voir [Flux de code d’autorisation](/docs/fr-ca/get-started/authentication-and-authorization-flow/authorization-code-flow). Si vous souhaitez apprendre comment ajouter la connexion à votre application Web classique, consultez [Ajout d’une connexion avec le flux de code d’autorisation](/docs/fr-ca/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).

</Callout>

Auth0 permet à votre application d’implémenter facilement le <Tooltip href="/docs/docs/fr-ca/glossary?term=authorization-code" tip="Code d’autorisation
Chaîne aléatoire générée par le serveur d’autorisation et renvoyée à l’application dans le cadre de la réponse d’autorisation lors de l’utilisation du flux de code d’autorisation (avec ou sans PKCE)." cta="Voir le glossaire">Code d’autorisation</Tooltip> flux à l’aide de(s) :

* [Guides de démarrage rapide pour applications Web classiques](/docs/fr-ca/quickstart/webapp) : la manière la plus simple d’implémenter le flux.
* [Authentication API](/docs/fr-ca/api/authentication) : Si vous préférez créer votre propre solution, continuez à lire pour savoir comment appeler notre API directement.

## Prérequis

**Avant de commencer ce tutoriel :**

* [Enregistrez votre application avec Auth0](/docs/fr-ca/get-started/auth0-overview/create-applications/regular-web-apps).

  + Sélectionnez un **Type d’application** parmi les **Applications Web classiques**.
  + Ajoutez une **URL de rappel autorisée** de `{https://yourApp/callback}`.
  + Assurez-vous que les **Types de consentement** de votre application englobent le **code d’autorisation**. Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types).
  + Si vous souhaitez que votre application puisse utiliser des [jetons d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens), assurez-vous que les **types de consentement** de l’application incluent le **jeton d’actualisation**. Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types). Pour en savoir plus sur les jetons d’actualisation, lisez [Jetons d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens).
* [Enregistrez votre application avec Auth0](/docs/fr-ca/get-started/auth0-overview/set-up-apis)

  + Si vous souhaitez que votre API reçoive des jetons d’actualisation afin d’obtenir de nouveaux jetons lorsque les précédents expirent, activez **Autoriser l’accès hors ligne**.

## Étapes

accordion.expand_all/accordion.collapse_all

<Accordion title="1 Autoriser l’utilisateur">

Cette étape peut comprendre un ou plusieurs des procédés suivant :

* Authentifier l’utilisateur
* Redirection de l’utilisateur vers un fournisseur d’identité pour gérer l’authentification
* Vérification des sessions actives d’authentification unique (SSO)
* Obtenir le consentement de l’utilisateur pour le niveau de permission demandé, sauf si obtenu précédemment.

Pour autoriser l’utilisateur, votre application doit le rediriger vers [l’URL d’autorisation](/docs/fr-ca/api/authentication#authorization-code-grant).

#### Exemple d’URL d’autorisation

export const codeExample1 = `https://{yourDomain}/authorize?
    response_type=code&
    client_id={yourClientId}&
    redirect_uri={https://yourApp/callback}&
    scope={scope}&
    audience={apiAudience}&
    state={state}`;

<AuthCodeBlock children={codeExample1} language="text" lines />

##### Paramètres

Notez que pour autoriser un utilisateur lors de l’appel d’une API personnalisée, vous :

- devez inclure un paramètre d’audience
- pouvez inclure des permissions supplémentaires prises en charge par l’API cible

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`response_type`</td>
<td>Jeton le type d’identifiant qu’Auth0 va retourner (`code` ou `token`). Pour ce flux, la valeur doit être `code`.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">Paramètres d’application</a>.</td>
</tr>
<tr>
<td>`redirect_uri`</td>
<td>L’URL vers laquelle Auth0 redirigera le navigateur après que l’autorisation a été accordée par l’utilisateur. Le code d’autorisation sera indiqué dans le paramètre URL `code`. Vous devez définir cette URL comme une URL de rappel valide dans vos [Paramètres d’application](https://manage.auth0.com/#/Applications/{yourClientId}/settings). <br/> <br/> <strong>Avertissement :</strong> Selon la <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">Spécification OAuth 2.0</a>, Auth0 supprime tout ce qui se trouve après le hachage et n’honore <em>pas</em> les fragments.</td>
</tr>
<tr>
<td>`scope`</td>
<td>Précise les <a href="/docs/docs/fr-ca/scopes">permissions</a> pour lesquelles vous souhaitez demander une autorisation, ce qui dicte les permissions (ou attributs utilisateur) que vous souhaitez voir renvoyées. Elles doivent être séparées par un espace. Vous pouvez demander n’importe lequel des <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">scopes standard OpenID Connect (OIDC)</a> sur les utilisateurs, comme `profile` ou `email`, <a href="/docs/docs/fr-ca/tokens/concepts/jwt-claims#custom-claims">demandes personnalisées</a> conforme à un <a href="/docs/docs/fr-ca/tokens/guides/create-namespaced-custom-claims">format d'espace de noms</a>, ou n’importe quelle permission prise en charge par l’API cible (p. ex., `read:contacts`). Incluez `offline_access` pour obtenir un <dfn id="react-containers-DefinitionTooltip-1"><span class="tooltip-portal-underlined-word" data-react-universal-portal="">Jeton d’actualisation</span></dfn> (assurez-vous que le champ <strong>Allow Offline Access</strong> est activé dans les <a href="https://manage.auth0.com/#/applications">Paramètres de l’application</a>).</td>
</tr>
<tr>
<td>`audience`</td>
<td>L’identifiant unique de l’API à laquelle votre application Web veut accéder. Utilisez la valeur <strong>Identifiant</strong> dans l’onglet <a href="https://manage.auth0.com/#/apis">Settings (Paramètres)</a> pour l’API que vous avez déterminée dans le cadre des prérequis pour ce tutoriel.</td>
</tr>
<tr>
<td>`state`</td>
<td>(recommandé) Une chaîne alphanumérique arbitraire opaque que votre application ajoute à la requête initiale qu’Auth0 inclut lorsqu’elle redirige vers votre application. Pour voir comment utiliser cette valeur pour prévenir les attaques de falsification de requête intersites (CSRF), consultez <a href="/docs/docs/fr-ca/protocols/oauth2/mitigate-csrf-attacks">Atténuer les attaques CSRF avec les paramètres d’état</a>.</td>
</tr>
<tr>
<td>`organization`</td>
<td>(facultatif) Identifiant de l’organisation à utiliser lors de l’authentification d’un utilisateur. S’il n’est pas fourni, si votre application est configurée pour <strong>afficher l’invite de l’organisation</strong>, l’utilisateur pourra saisir le nom de l’organisation lors de l’authentification.</td>
</tr>
<tr>
<td>`invitation`</td>
<td>(facultatif) Identifiant de l’invitation à l’organisation. Lors de l’<a href="/docs/docs/fr-ca/organizations/invite-members">invitation d’un membre à une organisation</a>, votre application doit gérer l’acceptation de l’invitation en transmettant les paires clé-valeur `invitation` et `organization` lorsque l’utilisateur accepte l’invitation.</td>
</tr>
</tbody>
</table>

Par exemple, votre extrait HTML pour l’URL d’autorisation lors de l’ajout de l’enregistrement à votre application peut avoir l’air de ce qui suit :

export const codeExample2 = `<a href="https://{yourDomain}/authorize?
  response_type=code&
  client_id={yourClientId}&
  redirect_uri={https://yourApp/callback}&  
  scope=appointments%20contacts&
  audience=appointments:api&
  state=xyzABC123">
  Sign In
</a>`;

<AuthCodeBlock children={codeExample2} language="html" />

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 302`. Le code d’autorisation est compris à la fin de cette URL :

``` lines
HTTP/1.1 302 Found
Location: {https://yourApp/callback}?code={authorizationCode}&state=xyzABC123
```

</Accordion>

<Accordion title="2 Demander des jetons">

Maintenant que vous avez un code d’authentification, vous pouvez l’échanger pour des jetons. En utilisant le code d’autorisation (`code`) extrait de l’étape précédente, vous devrez `POST` sur [l’URL du jeton](/docs/fr-ca/api/authentication#authorization-code).

#### Exemple d’un POST à une URL de jeton

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=authorization_code \
  --data 'client_id={yourClientId}' \
  --data 'client_secret={yourClientSecret}' \
  --data 'code=yourAuthorizationCode}' \
  --data 'redirect_uri={https://yourApp/callback}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'authorization_code',
    client_id: '{yourClientId}',
    client_secret: '{yourClientSecret}',
    code: 'yourAuthorizationCode}',
    redirect_uri: '{https://yourApp/callback}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=authorization_code" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_secret={yourClientSecret}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&code=yourAuthorizationCode}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&redirect_uri={https://yourApp/callback}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client
conn = http.client.HTTPSConnection("")
payload = "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}"
headers = { 'content-type': "application/x-www-form-urlencoded" }
conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=authorization_code".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)
postData.append("&code=yourAuthorizationCode}".data(using: String.Encoding.utf8)!)
postData.append("&redirect_uri={https://yourApp/callback}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

##### Paramètres

<table class="table"><thead>
<tr>
<th>Nom de paramètres</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définir sur `authorization_code`.</td>
</tr>
<tr>
<td>`code`</td>
<td>`authorization_code` récupéré à l’étape précédente de ce tutoriel.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de votre application</a>.</td>
</tr>
<tr>
<td>`client_secret`</td>
<td>Le secret client de votre application. Vous pouvez trouver cette valeur dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de votre application</a>.  Pour en savoir plus sur les méthodes d’authentification d’application disponibles, lisez <a href="/docs/docs/fr-ca/secure/application-credentials">Identifiants d’applications</a>.</td>
</tr>
<tr>
<td>`redirect_uri`</td>
<td>L’URL de rappel valide définie dans les paramètres de votre Application. Cela doit correspondre exactement à `redirect_uri` passé à l’ URL d’autorisation à l’étape précédente de ce tutoriel. Notez que cela doit être codé URL.</td>
</tr>
</tbody>
</table>

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec une charge utile contenant les valeurs `access_token`, `refresh_token`, `id_token` et `token_type` :

```javascript lines
{
  "access_token": "eyJz93a...k4laUWw",
  "refresh_token": "GEbRxBN...edjnXbL",
  "id_token": "eyJ0XAi...4faeEoQ",
  "token_type": "Bearer"
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

Les [Jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens) contiennent des informations de l’utilisateur qui doivent être décodées et extraites.

Les [jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens) sont utilisés pour appeler le [point de terminaison /userinfo de l’Authentication API Auth0](/docs/fr-ca/api/authentication#get-user-info) ou une autre API. Si vous appelez votre propre API, la première chose que votre API devra faire est de [vérifier le jeton d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

Les [jetons d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens) sont utilisés pour obtenir un nouveau jeton d’accès ou un nouveau jeton d’ID après l’expiration du précédent. Le `refresh_token` ne sera présent dans la réponse que si vous avez inclus la permission `offline_access` et activé **Autoriser l’accès hors ligne** pour votre API dans le Dashboard.

<Warning>

Les jetons d’actualisation doivent être stockés en toute sécurité car ils permettent aux utilisateurs de rester authentifiés pratiquement indéfiniment.

</Warning>

</Accordion>

<Accordion title="3 Effectuer un appel à l’API">

Pour appeler votre API à partir d’une application web ordinaire, l’application doit transmettre le jeton d’accès récupéré en tant que jeton du porteur dans l’en-tête Authorization (Autorisation) de votre requête HTTP.

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url https://myapi.com/api \
  --header 'authorization: Bearer {accessToken}' \
  --header 'content-type: application/json'
```
```csharp C# lines
var client = new RestClient("https://myapi.com/api");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer {accessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://myapi.com/api"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer {accessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}

```
```java Java lines
HttpResponse response = Unirest.get("https://myapi.com/api")
  .header("content-type", "application/json")
  .header("authorization", "Bearer {accessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://myapi.com/api',
  headers: {'content-type': 'application/json', authorization: 'Bearer {accessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});

```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer {accessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://myapi.com/api"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];

```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://myapi.com/api",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {accessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("myapi.com")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer {accessToken}"
    }

conn.request("GET", "/api", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://myapi.com/api")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer {accessToken}'
response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer {accessToken}"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://myapi.com/api")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

</Accordion>

<Accordion title="4 Échange de jetons d’actualisation">

Vous avez déjà reçu un [jeton d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens) si vous avez suivi ce tutoriel et complété ce qui suit :

* configuré votre API pour autoriser l’accès hors ligne
* inclus la permission `offline_access` lorsque vous avez lancé la demande d’authentification via le [point de terminaison d’autorisation](/docs/fr-ca/api/authentication/reference#authorize-application).

Vous pouvez utiliser le jeton d’actualisation pour obtenir le nouveau jeton d’accès. Généralement, un utilisateur aura besoin d’un nouveau jeton d’accès uniquement après l’expiration du précédent ou lorsqu’il accède à une nouvelle ressource pour la première fois. Il est déconseillé d’appeler le point de terminaison pour obtenir un nouveau jeton d’accès à chaque fois que vous appelez une API, et Auth0 impose des limites anti-attaques qui réduiront la quantité de requêtes au point de terminaison pouvant être exécutées en utilisant le même jeton depuis la même adresse IP.

Pour actualiser votre jeton, effectuez une requête `POST` au point de terminaison `/oauth/token` dans l’Authentication API, à l’aide de `grant_type=refresh_token`.

##### Exemple de requête POST à une URL de jeton

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=refresh_token \
  --data 'client_id={yourClientId}' \
  --data 'refresh_token={yourRefreshToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'refresh_token',
    client_id: '{yourClientId}',
    refresh_token: '{yourRefreshToken}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=refresh_token" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&refresh_token={yourRefreshToken}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client
conn = http.client.HTTPSConnection("")
payload = "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D"
headers = { 'content-type': "application/x-www-form-urlencoded" }
conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/oauth/token")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D"
response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=refresh_token".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&refresh_token={yourRefreshToken}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

###### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définir ce paramètre à `refresh_token`.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">Paramètres d’application</a>.</td>
</tr>
<tr>
<td>`refresh_token`</td>
<td>Le jeton d’actualisation à utiliser.</td>
</tr>
<tr>
<td>`scope`</td>
<td>(facultatif) Une liste délimitée par des espaces des permissions demandées. Si elle n’est pas envoyée, les permissions originales seront utilisées; sinon vous pouvez demander un ensemble réduit de permissions. Veuillez noter que cela doit être codé URL.</td>
</tr>
</tbody>
</table>

###### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec une charge utile contenant un nouveau `access_token`, sa durée de vie en secondes (`expires_in`), les valeurs de `permissions` accordées et le `token_type` . Si la permission du jeton initial incluait `openid`, alors la réponse inclura également un nouveau `id_token` :

```json lines
{
  "access_token": "eyJ...MoQ",
  "expires_in": 86400,
  "scope": "openid offline_access",
  "id_token": "eyJ...0NE",
  "token_type": "Bearer"
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

</Accordion>

### Exemples de cas d’utilisation

#### Personnalisation des jetons

Vous pouvez utiliser Auth0 Actions pour modifier les permissions d'un jeton d'accès et/ou ajouter des demandes personnalisées aux jetons d'accès et d'ID. Pour en savoir plus sur les Actions, consultez la section [Comprendre le fonctionnement d’Auth0 Actions.](/docs/fr-ca/customize/actions/actions-overview)

Pour ce faire, ajoutez l’Action post-connexion suivante, qui s’exécutera après l’authentification de l’utilisateur :

```javascript lines
exports.onExecutePostLogin = async (event, api) => {
  // Add custom claims to Access Token and ID Token
  api.accessToken.setCustomClaim('https://foo/bar', 'value');
  api.idToken.setCustomClaim('https://fiz/baz', 'some other value');

  // Modify the scope of the Access Token
  api.accessToken.addScope('foo');
  api.accessToken.addScope('bar');
};
```

<Warning>

Auth0 renvoie les informations de profil contenues dans un format de demande structuré tel que défini par la [spécification OpenID Connect (OIDC)](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). Cela signifie que les demandes personnalisées ajoutées aux jetons d’ID ou aux jetons d’accès doivent [respecter des directives et des restrictions](/docs/fr-ca/secure/tokens/json-web-tokens/create-custom-claims) pour éviter d’éventuels conflits.

</Warning>

## En savoir plus

* [Cadre d’applications Authorization OAuth 2.0](/docs/fr-ca/authenticate/protocols/oauth)
* [Protocole OpenID Connect](/docs/fr-ca/authenticate/protocols/openid-connect-protocol)
* [Jetons](/docs/fr-ca/secure/tokens)