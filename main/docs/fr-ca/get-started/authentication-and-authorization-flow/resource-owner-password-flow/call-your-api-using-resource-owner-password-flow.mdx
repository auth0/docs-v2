---
title: "Appeler votre API à l’aide du Flux de mot de passe du propriétaire de ressource"
permalink: "call-your-api-using-resource-owner-password-flow"
'description': "Apprenez à appeler votre propre API à partir d’applications hautement fiables à l’aide du Flux de mot de passe du propriétaire de ressource."
'og:title': "Appeler votre API à l’aide du Flux de mot de passe du propriétaire de ressource"
'og:description': "Apprenez à appeler votre propre API à partir d’applications hautement fiables à l’aide du Flux de mot de passe du propriétaire de ressource."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Appeler votre API à l’aide du Flux de mot de passe du propriétaire de ressource"
'twitter:description': "Apprenez à appeler votre propre API à partir d’applications hautement fiables à l’aide du Flux de mot de passe du propriétaire de ressource."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Ce tutoriel vous aidera à appeler votre propre API au moyen du flux de mot de passe du propriétaire de ressource. Si vous souhaitez apprendre comment le flux fonctionne et pourquoi vous devriez l’utiliser, consultez [Flux de mot de passe du propriétaire de ressource](/docs/fr-ca/get-started/authentication-and-authorization-flow/resource-owner-password-flow).

</Callout>

<Warning>

Étant donné que le flux ROP (Resource Owner Password) implique que l’application gère le mot de passe de l’utilisateur, il ne doit pas être utilisé par des clients tiers.

</Warning>

Auth0 permet à votre application de mettre en œuvre facilement le Flux de mot de passe du propriétaire de ressource (parfois appelé « Autorisation de mot de passe du propriétaire de ressource ») en utilisant l'[Authentication API](/docs/fr-ca/api/authentication) (API d’authentification). Continuez à lire pour savoir comment appeler votre API directement.

## Prérequis

**Avant de commencer ce tutoriel :**

* [Enregistrez votre application avec Auth0](/docs/fr-ca/get-started/auth0-overview/create-applications/regular-web-apps).

  + Sélectionnez le **type d’application** parmi les **Applications web classiques**.
  + Ajoutez une **URL de rappel autorisée** de `{https://yourApp/callback}`. Ce champ ne peut pas être vide, sinon un message d’erreur s’affichera.
  + Assurez-vous que les **Grant Types** (Types d’autorisation) de votre application comprennent le **Password** (Mot de passe). Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types)
  + Si vous souhaitez que votre application puisse utiliser des jetons d’actualisation, assurez-vous que les **Grant Types** (Types d’autorisation) de l’application comprennent le **Refresh Token** (Jetons d’actualisation). Pour en savoir plus, lisez l’article [Mettre à jour les types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types). Pour en savoir plus sur les jetons d’actualisation, lisez l’article [Jetons d'actualisation](/docs/fr-ca/secure/tokens/refresh-tokens).
* [Enregistrez votre application avec Auth0](/docs/fr-ca/get-started/auth0-overview/set-up-apis)

  + Si vous souhaitez que votre API reçoive des jetons d’actualisation afin d’obtenir de nouveaux jetons lorsque les précédents expirent, activez **Autoriser l’accès hors ligne**.
* Configurer une connexion

  + Assurez-vous que votre connexion est capable d’authentifier des utilisateurs grâce à leur nom d’utilisateur et leur mot de passe (par exemple, [connexions aux bases de données](/docs/fr-ca/get-started/applications/set-up-database-connections), ou les [connexions d’entreprise](/docs/fr-ca/connections/identity-providers-enterprise) AD/LDAP, ADFS, ou Azure Active Directory).
* Mettez à jour ou désactivez toutes les [rules](/docs/fr-ca/rules)(règles), pour qu’elles n’impactent que des connexions spécifiques. Si le message `access_denied` s’affiche lorsque vous testez l’autorisation de mot de passe du propriétaire de ressource, cela peut être dû à une règle de contrôle d’accès.

## Étapes

1. [Configurez le locataire](#configure-tenant) :Définissez la connexion par défaut du locataire.
2. [Request tokens](#request-tokens) (Demande de jetons) :
   échangez votre code d’autorisation contre des jetons.
3. [Appelez l’API](#call-api) :
   Utilisez le jeton d’accès récupéré pour appeler votre API.
4. [Jetons d’actualisation](#refresh-tokens) :
   utilisez un jeton d’actualisation pour demander de nouveaux jetons lorsque les anciens expirent.

Facultatif : [Découvrez des cas d’utilisation](#sample-use-cases)

Facultatif : [Configurer la prise en charge des partitions](#configure-realm-support)

Facultatif : [Configurer MFA](#configure-mfa)

Facultatif : [Configurer les paramètres de protection contre les attaques](#configure-anomaly-detection)

### Configurez le locataire

Le Flux de mot de passe du propriétaire de ressource repose sur une connexion capable d’authentifier les utilisateurs par leur nom d’utilisateur et leur mot de passe; vous devez donc définir la connexion par défaut du locataire.

1. Accédez au [Auth0 Dashboard > Paramètres du locataire](https://manage.auth0.com/#/tenant), et faites défiler vers le bas pour trouver le paramètre **Répertoire par défaut**.
2. Sélectionnez le nom de la connexion que vous souhaitez utiliser. Assurez-vous qu’elle est capable d’authentifier les utilisateurs par leur nom d’utilisateur et leur mot de passe.

### Demander des jetons

Pour appeler votre API, vous devez d’abord obtenir les identifiants de l’utilisateur, généralement via un formulaire interactif. Une fois que votre application dispose des identifiants, vous devez les échanger contre des jetons. Pour ce faire, vous devez `POST (PUBLIER)` vers [l’URL du jeton](/docs/fr-ca/api/authentication#resource-owner-password).

#### Exemple d’un POST à une URL de jeton

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=password \
  --data 'username={username}' \
  --data 'password={password}' \
  --data 'audience={yourApiIdentifier}' \
  --data scope=read:sample \
  --data 'client_id={yourClientId}' \
  --data 'client_secret={yourClientSecret}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'password',
    username: '{username}',
    password: '{password}',
    audience: '{yourApiIdentifier}',
    scope: 'read:sample',
    client_id: '{yourClientId}',
    client_secret: '{yourClientSecret}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=password" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&username={username}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&password={password}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&audience={yourApiIdentifier}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&scope=read:sample" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_secret={yourClientSecret}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=password".data(using: String.Encoding.utf8)!)
postData.append("&username={username}".data(using: String.Encoding.utf8)!)
postData.append("&password={password}".data(using: String.Encoding.utf8)!)
postData.append("&audience={yourApiIdentifier}".data(using: String.Encoding.utf8)!)
postData.append("&scope=read:sample".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

##### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définir sur `password`.</td>
</tr>
<tr>
<td>`username`</td>
<td>Le nom d’utilisateur saisi par l’utilisateur.</td>
</tr>
<tr>
<td>`password`</td>
<td>Le mot de passe saisi par l’utilisateur.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous trouverez cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de l’application</a>.</td>
</tr>
<tr>
<td>`client_assertion`</td>
<td>Un JWT contenant une assertion signée avec les identifiants de votre application. Requis lorsque la méthode d’authentification de l’application est une clé privée JWT.</td>
</tr>
<tr>
<td>`client_assertion_type`</td>
<td>La valeur est `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Requis lorsque la méthode d’authentification de l’application est une clé privée JWT.</td>
</tr>
<tr>
<td>`client_secret`</td>
<td>Secret du client de votre application. Requis lorsque le secret du client est la méthode d’authentification de l’application. <a href="https://manage.auth0.com/#/applications/{yourClientId}/settings">Paramètres de l’application</a> est `Post` ou `Basic`. Si votre application n’est pas très fiable (p. ex., une SPA), ne définissez pas ce paramètre.</td>
</tr>
<tr>
<td>`audience`</td>
<td>L’audience du jeton, qui est votre API. Vous pouvez le trouver dans le champ <strong>Identifiant</strong> de votre <a href="https://manage.auth0.com/#/apis">onglet des paramètres de l’API</a>.</td>
</tr>
<tr>
<td>`scope`</td>
<td>Indique les <a href="/docs/docs/fr-ca/scopes">permissions</a> pour lesquelles vous souhaitez demander une autorisation, qui déterminent les demandes (ou les attributs de l’utilisateur) à renvoyer. Elles doivent être séparées par un espace. Vous pouvez demander n’importe laquelle des <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">permissions standard d’OpenID Connect (OIDC)</a> about users, such as `profile` or `email`, <a href="/docs/docs/fr-ca/tokens/concepts/jwt-claims#custom-claims">demandes personnalisées</a> conforme au <a href="/docs/docs/fr-ca/tokens/guides/create-namespaced-custom-claims">format espace de nom</a>, ou toutes les permissions prises en charge par l’API cible (p. ex., `read:contacts`). Incluez `offline_access` pour obtenir un <dfn id="react-containers-DefinitionTooltip-0"><span class="tooltip-portal-underlined-word" data-react-universal-portal="">Jeton d’actualisation</span></dfn> (assurez-vous que le champ <strong>Autoriser l’accès hors ligne</strong> est activé dans les <a href="https://manage.auth0.com/#/applications">paramètres de l’application</a>).</td>
</tr>
</tbody>
</table>

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec une charge utile contenant les valeurs `access_token`, `refresh_token`, `id_token`, `token_type`, et `expires_in` :

```javascript lines
{
  "access_token": "eyJz93a...k4laUWw",
  "refresh_token": "GEbRxBN...edjnXbL",
  "id_token": "eyJ0XAi...4faeEoQ",
  "token_type": "Bearer",
  "expires_in": 36000
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

<Warning>

Les jetons d’actualisation doivent être stockés en toute sécurité car ils permettent aux utilisateurs de rester authentifiés pratiquement indéfiniment.

</Warning>

<Card title="Permissions standard et Flux de mot de passe du propriétaire de ressource">

Étant donné que fournir un mot de passe vous donne un accès total, tout échange basé sur un mot de passe donne accès à toutes les permissions. Par exemple, si vous n’incluez aucune [Permissions des API](/docs/fr-ca/get-started/apis/scopes/api-scopes) dans la demande, toutes les permissions des API seront incluses dans le jeton d’accès. De même, si vous incluez uniquement la permission `openid` dans votre demande, toutes les [permissions OpenID Connect](/docs/fr-ca/get-started/apis/scopes/openid-connect-scopes)`openid` standards seront renvoyées. Dans ces cas, le paramètre `scope` sera inclus dans la réponse et donnera la liste des permissions émises.

</Card>

<Card title="Obtenir les informations de l’utilisateur sans jeton d’ID">

Si vous avez besoin des informations de l’utilisateur, incluez la permission `openid` dans votre demande. Si l’API utilise `RS256` comme [algorithme de signature](/docs/fr-ca/get-started/applications/signing-algorithms) , le jeton d’accès incluera `/userinfo` comme audience valide, signifiant que vous pouvez l’utiliser pour invoquer le [point de terminaison /userinfo](/docs/fr-ca/api/authentication#get-user-info) et récupérer les demandes de l’utilisateur.

</Card>

### Appeler l’API

Pour appeler votre API, l’application doit transmettre le jeton d’accès récupéré en tant que jeton du porteur dans l’en-tête d’autorisation de votre requête HTTP.

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url https://myapi.com/api \
  --header 'authorization: Bearer {accessToken}' \
  --header 'content-type: application/json'
```
```csharp C# lines
var client = new RestClient("https://myapi.com/api");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer {accessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://myapi.com/api"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer {accessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.get("https://myapi.com/api")
  .header("content-type", "application/json")
  .header("authorization", "Bearer {accessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://myapi.com/api',
  headers: {'content-type': 'application/json', authorization: 'Bearer {accessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer {accessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://myapi.com/api"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://myapi.com/api",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {accessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("myapi.com")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer {accessToken}"
    }

conn.request("GET", "/api", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://myapi.com/api")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer {accessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer {accessToken}"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://myapi.com/api")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

### Jetons d’actualisation

Vous avez déjà reçu un [jeton d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens) si vous avez suivi ce tutoriel et complété ce qui suit :

* configuré votre API pour autoriser l’accès hors ligne
* inclus la permission `offline_access` lorsque vous avez lancé la demande d’authentification via le [point de terminaison d’autorisation](/docs/fr-ca/api/authentication/reference#authorize-application).

Vous pouvez utiliser le jeton d’actualisation pour obtenir le nouveau jeton d’accès. Généralement, un utilisateur aura besoin d’un nouveau jeton d’accès uniquement après l’expiration du précédent ou lorsqu’il accède à une nouvelle ressource pour la première fois. Il est déconseillé d’appeler le point de terminaison pour obtenir un nouveau jeton d’accès à chaque fois que vous appelez une API, et Auth0 impose des limites anti-attaques qui réduiront la quantité de requêtes au point de terminaison pouvant être exécutées en utilisant le même jeton depuis la même adresse IP.

Pour actualiser votre jeton, effectuez une requête `POST` au point de terminaison `/oauth/token` dans l’Authentication API, à l’aide de `grant_type=refresh_token`.

#### Exemple d’un POST à une URL de jeton

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=refresh_token \
  --data 'client_id={yourClientId}' \
  --data 'refresh_token={yourRefreshToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'refresh_token',
    client_id: '{yourClientId}',
    refresh_token: '{yourRefreshToken}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=refresh_token" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&refresh_token={yourRefreshToken}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=refresh_token".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&refresh_token={yourRefreshToken}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

##### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définir ce paramètre à `refresh_token`.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">Paramètres d’application</a>.</td>
</tr>
<tr>
<td>`refresh_token`</td>
<td>Le jeton d’actualisation à utiliser.</td>
</tr>
<tr>
<td>`scope`</td>
<td>(facultatif) Une liste délimitée par des espaces des permissions demandées. Si elle n’est pas envoyée, les permissions originales seront utilisées; sinon vous pouvez demander un ensemble réduit de permissions. Veuillez noter que cela doit être codé URL.</td>
</tr>
</tbody>
</table>

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec une charge utile contenant un nouveau `access_token` , sa durée de vie en secondes (`expires_in`), les valeurs de `scope` accordées et le `token_type`.

```json lines
{
  "access_token": "eyJ...MoQ",
  "expires_in": 86400,
  "scope": "openid offline_access",
  "token_type": "Bearer"
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

### Exemples de cas d’utilisation

#### Personnalisation des jetons

Vous pouvez utiliser des règles pour modifier les permissions des jetons d’accès et/ou ajouter des demandes pour les jetons d’accès et d’ID. (Pour en savoir plus sur les règles, lisez l’article [Règles d'Auth0](/docs/fr-ca/customize/rules).) Pour ce faire, ajoutez la règle suivante, qui s’exécutera après l’authentification de l’utilisateur :

```javascript lines
exports.onExecutePostLogin = async (event, api) => {
  // Add custom claims to Access Token and ID Token
  api.accessToken.setCustomClaim('https://foo/bar', 'value');
  api.idToken.setCustomClaim('https://fiz/baz', 'some other value');

  // Modify the scope of the Access Token
  api.accessToken.addScope('foo');
  api.accessToken.addScope('bar');
};
```

Les permissions seront disponibles dans le jeton une fois toutes les règles exécutées.

<Warning>

Auth0 renvoie les informations de profil contenues dans un format de demande structuré tel que défini par la [spécification OpenID Connect (OIDC)](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). Cela signifie que les demandes personnalisées ajoutées aux jetons d’ID ou aux jetons d’accès doivent [respecter des directives et des restrictions](/docs/fr-ca/secure/tokens/json-web-tokens/create-custom-claims) pour éviter d’éventuels conflits.

</Warning>

### Configurer la prise en charge des partitions

Auth0 fournit une autorisation d’extension semblable à l’autorisation de mot de passe du propriétaire de ressource, qui vous permet de conserver des répertoires d’utilisateurs distincts (qui correspondent à des connexions distinctes) et de spécifier celui qui doit être utilisé pendant le flux.

Pour utiliser cette variation, vous devez :

* Définir le paramètre de requête `grant_type` sur `http://auth0.com/oauth/grant-type/password-realm`.
* Envoyer un paramètre de requête supplémentaire appelé `realm` (partition), et lui attribuer le nom de la partition auquel l’utilisateur appartient. Par exemple, si vous avez configuré une connexion à la base de données pour des employés internes appelée `employees` (employés), et que votre utilisateur en fait partie, définissez alors `realm` (partition) sur `employees` (employés).

<Card title="Connexions en tant que partitions">

Toute connexion qui prend en charge l’authentification active peut être configurée comme une partition, notamment les [connexions à des bases de données](/docs/fr-ca/connections/database), les [connexions sans mot de passe](/docs/fr-ca/connections/passwordless) et les connexions d’entreprise [AD/LDAP](/docs/fr-ca/connections/enterprise/active-directory-ldap), [ADFS](/docs/fr-ca/connections/enterprise/adfs) et [Azure Active Directory](/docs/fr-ca/connections/enterprise/azure-active-directory).

</Card>

### Configurer MFA

Si vous devez utiliser le Flux de mot de passe du propriétaire de ressource, mais que vous avez besoin d’une authentification plus forte, vous pouvez ajouter l’authentification multifacteur (<Tooltip href="/docs/docs/fr-ca/glossary?term=multifactor-authentication" tip="Authentification multifacteur (MFA)
Processus d’authentification de l’utilisateur qui utilise un facteur en plus du nom d’utilisateur et du mot de passe, tel qu’un code par SMS." cta="Voir le glossaire">MFA</Tooltip>). Pour savoir comment procéder, lisez l’article [Authentifier à l’aide d’un Flux de mot de passe du propriétaire de ressource avec MFA)](/docs/fr-ca/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).

### Configurer les paramètres de protection contre les attaques

Lorsque vous utilisez le Flux de mot de passe du propriétaire de ressource avec une protection contre les attaques de force brute, certaines fonctionnalités de protection contre les attaques peuvent échouer. Certains problèmes courants peuvent toutefois être évités. Pour en savoir plus, lisez l’article [Éviter les problèmes courants en utilisant Flux de mot de passe du propriétaire de ressource et Protection contre les attaques](/docs/fr-ca/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).

## En savoir plus

* [Cadre d’applications Authorization OAuth 2.0](/docs/fr-ca/authenticate/protocols/oauth)
* [Protocole OpenID Connect](/docs/fr-ca/authenticate/protocols/openid-connect-protocol)
* [Jetons](/docs/fr-ca/secure/tokens)