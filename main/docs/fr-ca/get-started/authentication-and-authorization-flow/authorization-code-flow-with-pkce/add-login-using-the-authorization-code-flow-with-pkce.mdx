---
title: "Ajouter une connexion avec le flux de code d’autorisation avec une clé de preuve pour l’échange de code (PKCE)"
permalink: "add-login-using-the-authorization-code-flow-with-pkce"
'description': "Comment ajouter une connexion à votre application native, mobile ou à page unique en utilisant le flux de code d’autorisation avec Proof Key for Code Exchange (PKCE)."
'og:title': "Ajouter une connexion avec le flux de code d’autorisation avec une clé de preuve pour l’échange de code (PKCE)"
'og:description': "Comment ajouter une connexion à votre application native, mobile ou à page unique en utilisant le flux de code d’autorisation avec Proof Key for Code Exchange (PKCE)."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Ajouter une connexion avec le flux de code d’autorisation avec une clé de preuve pour l’échange de code (PKCE)"
'twitter:description': "Comment ajouter une connexion à votre application native, mobile ou à page unique en utilisant le flux de code d’autorisation avec Proof Key for Code Exchange (PKCE)."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez ajouter une connexion à votre application native, mobile ou à page unique en utilisant le flux de code d’autorisation avec PKCE. Pour savoir comment fonctionne le flux et pourquoi vous devriez l’utiliser, consultez [Flux de code d’autorisation avec Proof Key for Code Exchange (PKCE)](/docs/fr-ca/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). Pour apprendre à appeler votre API à partir d’une application native, mobile ou à page unique, consultez [Appeler votre API en utilisant le flux de code d’autorisation avec PKCE](/docs/fr-ca/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce).

Pour implémenter le flux de code d’autorisation avec Proof Key for Code Exchange (PKCE), consultez les ressources suivantes :

* [Trousses SDK Auth0 Mobile](/docs/fr-ca/libraries) et [Trousse SDK Auth0 pour applications à page unique](/docs/fr-ca/libraries/auth0-single-page-app-sdk) : Manière la plus simple d’implémenter le flux, qui fera le gros du travail à votre place. Nos [Démarrages rapides Mobile](/docs/fr-ca/quickstart/native) et [Démarrages rapides pour applications à page unique](/docs/fr-ca/quickstart/spa) vous guideront tout au long du processus.
* [Authentication API](/docs/fr-ca/api/authentication) : Si vous préférez créer votre propre solution, poursuivez la lecture pour savoir comment appeler notre API directement.

Une fois la connexion réussie, votre application aura accès au jeton d’ID et au jeton d’accès de l’utilisateur. Le jeton d’ID contient des informations de base sur le profil utilisateur, et le jeton d’accès peut être utilisé pour appeler le point de terminaison Auth0 `/userinfo` ou vos propres API protégées. Pour en savoir plus sur les jetons d’ID, consultez [Jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens). Pour en savoir plus sur les jetons d’accès, consultez [Jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens).

## Prérequis

Enregistrez votre application auprès d’Auth0. Pour en apprendre davantage, consultez [Enregistrement d’applications natives](/docs/fr-ca/get-started/auth0-overview/create-applications/native-apps) ou [Enregistrement d’applications Web à page unique](/docs/fr-ca/get-started/auth0-overview/create-applications/single-page-web-apps).

* Sélectionnez un **type d’applicationnative** ou **à page unique**, selon le type de votre application.
* Ajoutez une **URL de rappel autorisée** de `VOTRE_URL_RAPPEL`. Le format de l’URL de rappel varie en fonction du type d’application et de la plateforme. Pour plus de détails sur le format correspondant à votre type d’application et à votre plateforme, consultez [Démarrages rapides Native/Mobile](/docs/fr-ca/quickstart/native) et [Démarrages rapides Application à page unique](/docs/fr-ca/quickstart/spa).
* Assurez-vous que les **Grant Types (Types d’autorisation)** de votre application comprennent le **code d’autorisation**. Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types).

## Créer un vérificateur de code

Créez un `code_verifier`, qui est une clé cryptographiquement aléatoire encodée en Base64 et qui sera finalement envoyée à Auth0 pour demander des jetons.

Pour en savoir plus sur l’algorithme de création du `code_verifier`, consultez la section [4.1 Client crée un vérificateur de code](https://datatracker.ietf.org/doc/html/rfc7636#section-4.1) des spécifications de <Tooltip href="/docs/docs/fr-ca/glossary?term=oath2" tip="OAuth 2.0
Cadre d’applications d’autorisation qui définit les protocoles d’autorisation et les flux de production." cta="Voir le glossaire">OAuth</Tooltip> Proof Key for Code Exchange (PKCE).

### Exemple JavaScript

```javascript lines
// Dependency: Node.js crypto module
// https://nodejs.org/api/crypto.html#crypto_crypto
function base64URLEncode(str) {
    return str.toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
var verifier = base64URLEncode(crypto.randomBytes(32));
```

### Exemple Java

```java lines
// Dependency: Apache Commons Codec
// https://commons.apache.org/proper/commons-codec/
// Import the Base64 class.
// import org.apache.commons.codec.binary.Base64;
SecureRandom sr = new SecureRandom();
byte[] code = new byte[32];
sr.nextBytes(code);
String verifier = Base64.getUrlEncoder().withoutPadding().encodeToString(code);
```

### Exemple Android

```java lines
// Dependency: Apache Commons Codec
// https://commons.apache.org/proper/commons-codec/
// Import the Base64 class.
// import org.apache.commons.codec.binary.Base64;
SecureRandom sr = new SecureRandom();
byte[] code = new byte[32];
sr.nextBytes(code);
String verifier = Base64.encodeToString(code, Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);
```

### Échantillon Swift 5

```swift lines
var buffer = [UInt8](repeating: 0, count: 32)
_ = SecRandomCopyBytes(kSecRandomDefault, buffer.count, &buffer)
let verifier = Data(buffer).base64EncodedString()
    .replacingOccurrences(of: "+", with: "-")
    .replacingOccurrences(of: "/", with: "_")
    .replacingOccurrences(of: "=", with: "")
```

### Exemple Objective-C

```objective-c lines
NSMutableData *data = [NSMutableData dataWithLength:32];
int result __attribute__((unused)) = SecRandomCopyBytes(kSecRandomDefault, 32, data.mutableBytes);
NSString *verifier = [[[[data base64EncodedStringWithOptions:0]
                        stringByReplacingOccurrencesOfString:@"+" withString:@"-"]
                        stringByReplacingOccurrencesOfString:@"/" withString:@"_"]
                        stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@"="]];
```

## Créer un défi de code

Générez un `code_challenge` à partir du `code_verifier` qui sera envoyé à Auth0 pour demander un `autorisation_code`.

Pour en savoir plus sur la façon dont le `code_challenge` est dérivé du `code_verifier`, consultez la section [4.2 Client crée le défi du code](https://datatracker.ietf.org/doc/html/rfc7636#section-4.) des spécifications de OAuth Proof Key for Code Exchange (PKCE).

### Exemple JavaScript

```javascript lines
// Dependency: Node.js crypto module
// https://nodejs.org/api/crypto.html#crypto_crypto
function sha256(buffer) {
    return crypto.createHash('sha256').update(buffer).digest();
}
var challenge = base64URLEncode(sha256(verifier));
```

### Exemple Java

```java lines
// Dependency: Apache Commons Codec
// https://commons.apache.org/proper/commons-codec/
// Import the Base64 class.
// import org.apache.commons.codec.binary.Base64;
byte[] bytes = verifier.getBytes("US-ASCII");
MessageDigest md = MessageDigest.getInstance("SHA-256");
md.update(bytes, 0, bytes.length);
byte[] digest = md.digest();
String challenge = Base64.encodeBase64URLSafeString(digest);
```

### Échantillon Swift 5

```swift lines
import CommonCrypto

// ...

guard let data = verifier.data(using: .utf8) else { return nil }
var buffer = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))
_ = data.withUnsafeBytes {
    CC_SHA256($0.baseAddress, CC_LONG(data.count), &buffer)
}
let hash = Data(buffer)
let challenge = hash.base64EncodedString()
    .replacingOccurrences(of: "+", with: "-")
    .replacingOccurrences(of: "/", with: "_")
    .replacingOccurrences(of: "=", with: "")
```

### Exemple Objective-C

```objective-c lines
// Dependency: Apple Common Crypto library
// http://opensource.apple.com//source/CommonCrypto
u_int8_t buffer[CC_SHA256_DIGEST_LENGTH * sizeof(u_int8_t)];
memset(buffer, 0x0, CC_SHA256_DIGEST_LENGTH);
NSData *data = [verifier dataUsingEncoding:NSUTF8StringEncoding];
CC_SHA256([data bytes], (CC_LONG)[data length], buffer);
NSData *hash = [NSData dataWithBytes:buffer length:CC_SHA256_DIGEST_LENGTH];
NSString *challenge = [[[[hash base64EncodedStringWithOptions:0]
                         stringByReplacingOccurrencesOfString:@"+" withString:@"-"]
                         stringByReplacingOccurrencesOfString:@"/" withString:@"_"]
                         stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@"="]];
```

## Autoriser l’utilisateur

Demandez l’autorisation de l’utilisateur et redirigez-le vers votre application à l’aide d’un `authorization_code`.

Une fois que vous avez créé le `code_verifier` et le `code_challenge`, vous devez obtenir l’autorisation de l’utilisateur. Il s’agit techniquement du début du flux d’autorisation, et cette étape peut inclure un ou plusieurs des processus suivants :

\* Authentification de l’utilisateur;
\* Rediriger l’utilisateur vers un fournisseur d’identité pour gérer l’authentification;
\* Vérification des sessions [d’authentification unique (SSO)](/docs/fr-ca/authenticate/single-sign-on) actives;
\* Obtention du consentement de l’utilisateur pour le niveau d’autorisation demandé, sauf si le consentement a été préalablement donné.

Pour autoriser l’utilisateur, votre application doit envoyer l’utilisateur vers [l’URL d’autorisation](/docs/fr-ca/api/authentication#authorization-code-grant-pkce-), y compris le `code_challenge` que vous avez généré à l’étape précédente et la méthode que vous avez utilisée pour générer le `code_challenge`.

### Exemple d’URL d’autorisation

export const codeExample1 = `https://{yourDomain}/authorize?
    response_type=code&
    code_challenge={codeChallenge}&
    code_challenge_method=S256&
    client_id={yourClientId}&
    redirect_uri={yourCallbackUrl}&
    scope={scope}&
    state={state}`;

<AuthCodeBlock children={codeExample1} language="text" lines />

### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`response_type`</td>
<td>Indique le type d’identifiant qu’Auth0 va retourner (`code` ou `jeton`). Pour ce flux, la valeur doit être `code`</td>
</tr>
<tr>
<td>`code_challenge`</td>
<td>Défi généré à partir du `code_verifier`.</td>
</tr>
<tr>
<td>`code_challenge_method`</td>
<td>Méthode utilisée pour générer le défi (par exemple, S256). La spécification PKCE définit deux méthodes, `S256` et `plain`, la première étant utilisée dans cet exemple et la <strong>seule</strong> prise en charge par Auth0 puisque la seconde est déconseillée.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de l’application</a>.</td>
</tr>
<tr>
<td>`redirect_uri`</td>
<td>URL vers laquelle Auth0 redirigera le navigateur une fois que l’autorisation aura été accordée par l’utilisateur. Vous devez spécifier cette URL en tant qu’URL de rappel valide dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètre de l’application</a>. &lt;br /&amp;gt ; &lt;br /&amp;gt ; <strong>Attention:</strong> Conformément à la <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">spécification OAuth 2.0</a>, Auth0 supprime tout ce qui se trouve après le hachage et n’accepte <em>pas</em> les fragments.</td>
</tr>
<tr>
<td>`scope`</td>
<td>Indique les <a href="/docs/docs/fr-ca/permissions">permissions</a> pour lesquels vous souhaitez demander une autorisation, ce qui dicte les demandes (ou les attributs d’utilisateur) que vous souhaitez voir renvoyées. Ils doivent être séparés par un espace. Pour obtenir un jeton d’ID dans la réponse, vous devez spécifier une permission d’au moins `openid`. Si vous voulez récupérer le profil complet de l’utilisateur, vous pouvez demander `openid profile`. Vous pouvez demander n’importe lequel des <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">permissions standards d’OpenID Connect (OIDC)</a> sur les utilisateurs, comme `email` (adresse courriel), ou des <a href="/docs/docs/fr-ca/tokens/concepts/jwt-claims#custom-claims">demandes personnalisées</a> conformes à un <a href="/docs/docs/fr-ca/tokens/guides/create-namespaced-custom-claims">format espace de nom</a>.</td>
</tr>
<tr>
<td>Incluez `offline_access` pour obtenir un <dfn id="react-containers-DefinitionTooltip-1"><span class="tooltip-portal-underlined-word" data-react-universal-portal="">Jeton d’actualisation</span></dfn> (assurez-vous que le champ <strong>Allow Offline Access</strong> est activé dans les <a href="https://manage.auth0.com/#/applications">paramètres de l’application</a>).</td>
<td></td>
</tr>
<tr>
<td>`state`</td>
<td>(recommandé) Une chaîne alphanumérique arbitraire opaque que votre application ajoute à la requête initiale qu’Auth0 inclut lorsqu’elle redirige vers votre application. Pour voir comment utiliser cette valeur pour prévenir les attaques par falsification de requête intersites , voir la section <a href="/docs/docs/fr-ca/protocols/oauth2/mitigate-csrf-attacks">Atténuer les attaques par falsification de requête intersites avec les paramètres d’état</a>.</td>
</tr>
<tr>
<td>`connection`</td>
<td>( facultatif) Force l’utilisateur à se connecter avec une connexion spécifique. Par exemple, vous pouvez transmettre une valeur de `github` pour envoyer l’utilisateur directement à GitHub pour qu’il se connecte avec son compte. Si la valeur n’est pas spécifiée, l’utilisateur voit l’écran de verrouillage Auth0 avec toutes les connexions configurées. Vous pouvez voir une liste de vos connexions configurées dans l’onglet <strong>Connections</strong> (connexions) de votre application.</td>
</tr>
<tr>
<td>`organization`</td>
<td>(facultatif) Identifiant de l’organisation à utiliser pour authentifier un utilisateur. S’il n’est pas fourni et que votre application est configurée pour <strong>afficher l’invite de l’organisation</strong>, l’utilisateur pourra entrer le nom de l’organisation lors de l’authentification.</td>
</tr>
<tr>
<td>`invitation`</td>
<td>(facultatif) Identifiant du ticket d’invitation de l’organization. Lorsque vous <a href="/docs/docs/fr-ca/organizations/invite-members">invitez un membre à rejoindre une organisation</a>, votre application doit gérer l’acceptation de l’invitation en transmettant les combinaisons de valeurs clés `invitation` et `organization` quand l’utilisateur accepte l’invitation.</td>
</tr>
</tbody>
</table>

Par exemple, votre snippet HTML pour l’URL d’autorisation lors de l’ajout d’une connexion à votre application pourrait ressembler à ceci :

export const codeExample2 = `<a href="https://{yourDomain}/authorize?
  response_type=code&
  code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&
  code_challenge_method=S256&
  client_id={yourClientId}&
  redirect_uri={yourCallbackUrl}&
  scope=openid%20profile&
  state=xyzABC123">
  Sign In
</a>`;

<AuthCodeBlock children={codeExample2} language="html" />

### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 302`. Le code d’autorisation est ajouté à la fin de l’URL :

``` lines
HTTP/1.1 302 Found
Location: {yourCallbackUrl}?code={authorizationCode}&state=xyzABC123
```

## Jetons de requête

Échangez votre `authorization_code` et `code_verifier` pour des jetons.

Maintenant que vous avez un code d’authentification, vous pouvez l’échanger pour des jetons. En utilisant le code d’autorisation (`code`) extrait de l’étape précédente, vous devrez `POST` sur [l’URL du jeton](/docs/fr-ca/api/authentication#authorization-code-pkce-) en l’envoyant avec le `code_verifier`.

### Exemple d’URL « POST to token »

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=authorization_code \
  --data 'client_id={yourClientId}' \
  --data 'code_verifier={yourGeneratedCodeVerifier}' \
  --data 'code={yourAuthorizationCode}' \
  --data 'redirect_uri={https://yourApp/callback}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'authorization_code',
    client_id: '{yourClientId}',
    code_verifier: '{yourGeneratedCodeVerifier}',
    code: '{yourAuthorizationCode}',
    redirect_uri: '{https://yourApp/callback}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=authorization_code" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&code_verifier={yourGeneratedCodeVerifier}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&code={yourAuthorizationCode}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&redirect_uri={https://yourApp/callback}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=authorization_code".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&code_verifier={yourGeneratedCodeVerifier}".data(using: String.Encoding.utf8)!)
postData.append("&code={yourAuthorizationCode}".data(using: String.Encoding.utf8)!)
postData.append("&redirect_uri={https://yourApp/callback}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définissez sur « authorization_code ».</td>
</tr>
<tr>
<td>`code_verifier`</td>
<td>La clé de chiffrement aléatoire qui a été générée à la première étape de ce tutoriel.</td>
</tr>
<tr>
<td>`code`</td>
<td>Le `authorization_code` récupéré à l’étape précédente de ce tutoriel.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans [Paramètres de l’application] (https://manage.auth0.com/#/Applications/{yourClientId}/settings).</td>
</tr>
<tr>
<td>`redirect_uri`</td>
<td>L’URL de rappel valide défini dans les paramètres de votre application. Cela doit correspondre exactement au `redirect_uri` transmis à l’URL d’autorisation à l’étape précédente de ce tutoriel. Notez que cela doit être codé URL.</td>
</tr>
</tbody>
</table>

### Réponse

Si tout se passe bien, vous recevrez une réponse HTTP 200 avec une charge utile contenant les valeurs `access_token`, `refresh_token`, `id_token`, et `token_type` :

```json lines
{
  "access_token":"eyJz93a...k4laUWw",
  "refresh_token":"GEbRxBN...edjnXbL",
  "id_token":"eyJ0XAi...4faeEoQ",
  "token_type":"Bearer",
  "expires_in":86400
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

Les [Jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens) contiennent des informations de l’utilisateur qui doivent être décodées et extraites.

Les [jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens) sont utilisés pour appeler le [point de terminaison /userinfo de l’Authentication API Auth0](/docs/fr-ca/api/authentication#get-user-info) ou une autre API. Si vous appelez votre propre API, la première chose que votre API devra faire est de [vérifier le jeton d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

Les [jetons d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens) sont utilisés pour obtenir un nouveau jeton d’accès ou un nouveau jeton d’ID après l’expiration du précédent. Le `refresh_token` ne sera présent dans la réponse que si vous avez inclus la permission `offline_access` et activé **Autoriser l’accès hors ligne** pour votre API dans le Dashboard.

<Warning>

Les jetons d’actualisation doivent être stockés en toute sécurité car ils permettent aux utilisateurs de rester authentifiés pratiquement indéfiniment.

</Warning>

## Cas d’utilisation

### Demande d’authentification de base

Cet exemple montre la requête la plus basique que vous pouvez faire lorsque vous autorisez l’utilisateur à l’étape 1. L’écran de connexion Auth0 permet à l’utilisateur de se connecter avec l’une des connexions configurées.

export const codeExample13 = `https://{yourDomain}/authorize?
    response_type=code&
    code_challenge={codeChallenge}&
    code_challenge_method=S256&
    client_id={yourClientId}&
    redirect_uri={yourCallbackUrl}&
    scope=openid`;

<AuthCodeBlock children={codeExample13} language="text" lines />

Désormais, lorsque vous demanderez des jetons, votre jeton d’ID contiendra les autorisations les plus élémentaires. Lorsque vous décodez le jeton d’ID, il ressemble à ce qui suit :

```json lines
{
  "iss": "https://auth0pnp.auth0.com/",
  "sub": "auth0|581...",
  "aud": "xvt9...",
  "exp": 1478112929,
  "iat": 1478076929
}
```

### Demander le nom et la photo de profil de l’utilisateur

Outre l’authentification habituelle de l’utilisateur, cet exemple montre comment demander des informations supplémentaires sur l’utilisateur, telles que son nom et sa photo.

Pour demander le nom et la photo de l’utilisateur, vous devez ajouter les permissions appropriées lors de l’autorisation de l’utilisateur :

export const codeExample14 = `https://{yourDomain}/authorize?
    response_type=code&
    code_challenge={codeChallenge}&
    code_challenge_method=S256&
    client_id={yourClientId}&
    redirect_uri={yourCallbackUrl}&
    scope=openid%20name%20picture&
    state={state}`;

<AuthCodeBlock children={codeExample14} language="text" lines />

Désormais, lorsque vous demanderez des jetons, votre jeton d’ID contiendra le nom et la photo demandés. Lorsque vous décodez le jeton d’ID, il ressemble à ce qui suit :

```json lines
{
  "name": "auth0user@...",
  "picture": "https://example.com/profile-pic.png",
  "iss": "https://auth0user.auth0.com/",
  "sub": "auth0|581...",
  "aud": "xvt...",
  "exp": 1478113129,
  "iat": 1478077129
}
```

### Demande de connexion d’un utilisateur avec GitHub

En plus de l’authentification habituelle des utilisateurs, cet exemple montre comment envoyer les utilisateurs directement à un fournisseur d’identité sociale, tel que GitHub. Pour que cet exemple fonctionne, vous devez aller dans [Auth0 Dashboard > Authentification > Social](https://manage.auth0.com/#/connections/social) et configurer la connexion appropriée. Obtenez le nom de la connexion dans l’onglet **Paramètres**.

Pour envoyer les utilisateurs directement à l’écran de connexion de GitHub, vous devez passer le paramètre `connection` et définir sa valeur au nom de la connexion (dans ce cas, `github`) lors de l’autorisation de l’utilisateur :

export const codeExample15 = `https://{yourDomain}/authorize?
    response_type=code&
    code_challenge={codeChallenge}&
    code_challenge_method=S256&
    client_id={yourClientId}&
    redirect_uri={yourCallbackUrl}&
    scope=openid%20name%20picture&
    state={state}&
    connection=github`;

<AuthCodeBlock children={codeExample15} language="text" lines />

Désormais, lorsque vous demandez des jetons, votre jeton d’ID contiendra une demande `sub` avec l’ID unique de l’utilisateur renvoyé par GitHub. Lorsque vous décodez le jeton d’ID, il ressemble à ce qui suit :

```json lines
{
  "name": "John Smith",
  "picture": "https://avatars.example.com",
  "email": "jsmith@...",
  "email_verified": true,
  "iss": "https://auth0user.auth0.com/",
  "sub": "github|100...",
  "aud": "xvt...",
  "exp": 1478114742,
  "iat": 1478078742
}
```

## En savoir plus

* [Cadre d’applications Authorization OAuth 2.0](/docs/fr-ca/authenticate/protocols/oauth)
* [Protocole OpenID Connect](/docs/fr-ca/authenticate/protocols/openid-connect-protocol)
* [Jetons](/docs/fr-ca/secure/tokens)