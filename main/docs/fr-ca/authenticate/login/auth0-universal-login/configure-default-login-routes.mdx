---
title: "Configuration des itinéraires de connexion par défaut"
permalink: "configure-default-login-routes"
'description': "Apprenez à configurer les itinéraires de connexion par défaut de votre locataire et de votre application."
'og:title': "Configuration des itinéraires de connexion par défaut"
'og:description': "Apprenez à configurer les itinéraires de connexion par défaut de votre locataire et de votre application."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Configuration des itinéraires de connexion par défaut"
'twitter:description': "Apprenez à configurer les itinéraires de connexion par défaut de votre locataire et de votre application."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Dans certains cas (décrits ci-dessous), Auth0 peut avoir besoin de rediriger vers le point de terminaison d’initiation de la connexion de l’application, en utilisant la connexion initiée par une tierce partie OIDC. Pour en savoir plus, consulter [Initier une connexion à partir d’une tierce partie](https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin) dans la [Fondation OpenID](https://openid.net).

Vous pouvez configurer ces URI à l’aide du tableau de bord dans les [Application Settings (Réglages de l’application)](https://manage.auth0.com/#/applications/settings) ou [Tenant Advanced Settings (Réglages avancés du locataire)](https://manage.auth0.com/#/tenant/advanced) ou avec Management API.

<Tabs><Tab title="Niveau de l’application">

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/clients/{yourClientId}' \
  --header 'authorization: Bearer API2_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{"initiate_login_uri": "<login_url>"}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/clients/{yourClientId}");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer API2_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{"initiate_login_uri": "<login_url>"}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/clients/{yourClientId}"

	payload := strings.NewReader("{"initiate_login_uri": "<login_url>"}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer API2_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/clients/{yourClientId}")
  .header("content-type", "application/json")
  .header("authorization", "Bearer API2_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{"initiate_login_uri": "<login_url>"}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/clients/{yourClientId}',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer API2_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {initiate_login_uri: '<login_url>'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer API2_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"initiate_login_uri": @"<login_url>" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/clients/{yourClientId}"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/clients/{yourClientId}",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{"initiate_login_uri": "<login_url>"}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer API2_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"initiate_login_uri": "<login_url>"}"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer API2_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/clients/{yourClientId}", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/clients/{yourClientId}")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer API2_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{"initiate_login_uri": "<login_url>"}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer API2_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = ["initiate_login_uri": "<login_url>"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/clients/{yourClientId}")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

</Tab><Tab title="Niveau du locataire">

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/tenants/settings' \
  --header 'authorization: Bearer API2_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{"default_redirection_uri": "<login_url>"}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/tenants/settings");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer API2_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{"default_redirection_uri": "<login_url>"}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/tenants/settings"

	payload := strings.NewReader("{"default_redirection_uri": "<login_url>"}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer API2_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/tenants/settings")
  .header("content-type", "application/json")
  .header("authorization", "Bearer API2_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{"default_redirection_uri": "<login_url>"}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/tenants/settings',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer API2_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {default_redirection_uri: '<login_url>'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer API2_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"default_redirection_uri": @"<login_url>" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/tenants/settings"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/tenants/settings",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{"default_redirection_uri": "<login_url>"}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer API2_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"default_redirection_uri": "<login_url>"}"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer API2_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/tenants/settings", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/tenants/settings")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer API2_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{"default_redirection_uri": "<login_url>"}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer API2_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = ["default_redirection_uri": "<login_url>"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/tenants/settings")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

</Tab></Tabs>

---

La `login_url` doit pointer vers une route de l’application qui redirige vers le point de terminaison `/authorize` d’Auth0, par exemple `https://mycompany.org/login`. Veuillez noter que cette URL utilise le protocole `https` et qu’elle ne peut pas pointer vers `localhost`. `login_url` peut inclure des paramètres de requête et un fragment d’URI.

Conformément à la spécification de l’OIDC relative à la connexion initiée par un tiers, le paramètre `iss` contenant l’identifiant de l’émetteur sera ajouté en tant que paramètre de chaîne de requête à `login_url` avant la redirection.

## Scénarios de redirection de la route de connexion par défaut

### Les utilisateurs ajoutent la page de connexion à leurs favoris

Lorsqu’une application lance le processus de connexion, elle navigue vers `https://{yourDomain}/authorize` avec un ensemble de [paramètres requis](/docs/docs/fr-ca/api/authentication#login). Auth0 redirige ensuite les utilisateurs vers une page `https://{yourDomain}/login`, avec une URL qui ressemble à :

`https://{yourDomain}/login?state=g6Fo2SBjNTRyanlVa3ZqeHN4d1htTnh&...`

Le paramètre `state` renvoie à un enregistrement dans une base de données interne où nous suivons l’état de la transaction d’autorisation. L’enregistrement est supprimé de la base de données interne lorsque la transaction est terminée ou après un certain temps.

Si vous utilisez Organizations et que l’utilisateur ajoute l’invite de connexion de l’organisation à ses favoris, Auth0 inclut également le paramètre `organization` lorsqu’il redirige l’utilisateur vers la route de connexion par défaut.

Parfois, les utilisateurs ajoutent la page de connexion à leurs favoris, et lorsqu’ils naviguent vers l’URL `/login` l’enregistrement de la transaction n’est plus là et Auth0 ne peut pas poursuivre le flux de connexion. Dans ce cas, Auth0 redirigera vers l’URL client par défaut si elle est configurée, ou vers l’URL au niveau du locataire si elle ne l’est pas. Auth0 affichera une page d’erreur si aucune URL de connexion par défaut n’est définie.

### Flux complet de réinitialisation de mot de passe

Une fois que le flux de réinitialisation du mot de passe est terminé et que l’URI par défaut de l’application ou du locataire est configuré, les utilisateurs verront un bouton qui leur permettra de revenir à la page de connexion.

Ce comportement ne se produit que lorsque vous activez l’expérience de connexion universelle. Avec la connexion classique, vous devez configurer la redirection dans le modèle de modification du mot de passe. Pour en savoir plus, consultez [Personnaliser les modèles de courriel](/docs/docs/fr-ca/customize/email/email-templates).

Pour les locataires utilisant la connexion universelle, le point de terminaison [`/post-password-change`](/docs/docs/fr-ca/api/management/v2/#!/Tickets/post_password_change) permet de rediriger les utilisateurs vers une application en particulier. Lorsque `client_id` est indiqué et que l’URI de connexion de l’application est défini, les utilisateurs verront un bouton les renvoyant à l’application après avoir effectué une réinitialisation de mot de passe.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/tickets/password-change' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/tickets/password-change");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddParameter("application/json", "{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/tickets/password-change"

	payload := strings.NewReader("{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/tickets/password-change")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .body("{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/tickets/password-change',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'
  },
  data: {user_id: 'A_USER_ID', client_id: 'A_CLIENT_ID'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN" };
NSDictionary *parameters = @{ @"user_id": @"A_USER_ID",
                              @"client_id": @"A_CLIENT_ID" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/tickets/password-change"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/tickets/password-change",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN"
    }

conn.request("POST", "/{yourDomain}/api/v2/tickets/password-change", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/tickets/password-change")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request.body = "{ "user_id": "A_USER_ID", "client_id": "A_CLIENT_ID" }"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN"
]
let parameters = [
  "user_id": "A_USER_ID",
  "client_id": "A_CLIENT_ID"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/tickets/password-change")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

### Flux complet de vérification par courriel

Les utilisateurs qui ont choisi le courriel comme identifiant reçoivent, dans le cadre de la procédure d’inscription, un courriel de vérification de leur adresse courriel. S’ils cliquent sur le lien, ils accèdent à une page indiquant que le courriel a été vérifié, avec un bouton permettant de revenir à la demande. En cliquant dessus, les utilisateurs seront redirigés vers la page de connexion, et si leur session est déjà valide, ils seront redirigés vers l’application.

Ce comportement ne se produit que lorsque la connexion universelle est activée. Avec la connexion classique, vous devez configurer l’URL de redirection dans le modèle du courriel de vérification.

### Inviter les membres d’une organisation

Les utilisateurs invités à se joindre à une [Organization](/docs/docs/fr-ca/manage-users/organizations/organizations-overview) reçoivent un lien d’invitation par courriel. S’ils cliquent sur le lien, ils sont redirigés vers l’itinéraire de connexion par défaut configuré, auquel sont ajoutés des paramètres propres à l’invitation.

Par exemple, si vous avez une application activée par l’organisation avec une **Application Login URI (URL de connexion à l’application)** réglée sur `https://myapp.com/login`, le lien envoyé dans l’invitation par courriel qu’un utilisateur final reçoit sera : `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.

Ainsi,la route de votre application doit accepter les paramètres d’`invitation` et d’`organization` au moyen de la chaîne de requête. Pour lancer la transaction d’acceptation de l’invitation, les deux paramètres ainsi que l’utilisateur final doivent être transmis à votre point de terminaison Auth0 `/authorize`.

### Témoins désactivés

Auth0 redirige l’utilisateur vers l’URI de connexion de l’application s’il se rend à l’adresse `https://{yourDomain}/authorize` alors que les témoins sont désactivés dans son navigateur. La redirection est envoyée à l’URI de connexion du locataire si l’URI de connexion de l’application n’est pas défini.

Renvoyer l’utilisateur à la page de connexion peut potentiellement provoquer une boucle de redirection. Pour éviter ce problème, utilisez une page de renvoi pour vérifier la disponibilité des témoins; s’ils sont désactivés, avertissez l’utilisateur qu’il doit les activer s’il souhaite continuer.

## En savoir plus

* [Personnaliser les modèles de courriels](/docs/docs/fr-ca/customize/email/email-templates)
* [Vérifier les appels d’API](/docs/docs/fr-ca/troubleshoot/authentication-issues/check-api-calls)
* [Vérifier les messages d’erreur](/docs/docs/fr-ca/troubleshoot/basic-issues/check-error-messages)
* [Gérer les facteurs d’authentification avec l’Authentication API](/docs/docs/fr-ca/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)