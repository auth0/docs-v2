---
title: "Configurer une passerelle SMS personnalisée pour les connexions sans mot de passe"
permalink: "use-sms-gateway-passwordless"
'description': "Apprenez à configurer une passerelle SMS personnalisée pour les connexions sans mot de passe."
'og:title': "Configurer une passerelle SMS personnalisée pour les connexions sans mot de passe"
'og:description': "Apprenez à configurer une passerelle SMS personnalisée pour les connexions sans mot de passe."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Configurer une passerelle SMS personnalisée pour les connexions sans mot de passe"
'twitter:description': "Apprenez à configurer une passerelle SMS personnalisée pour les connexions sans mot de passe."
---


import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Ce guide vous montrera comment utiliser une passerelle SMS personnalisée pour envoyer vos codes à usage unique.

Par défaut, [les connexions SMS sans mot de passe](/docs/docs/fr-ca/authenticate/passwordless/authentication-methods/sms-otp) utilisent [Twilio](https://www.twilio.com) pour envoyer les codes à usage unique. Toutefois, si vous disposez d’une passerelle SMS personnalisée, vous pouvez modifier votre connexion pour l’utiliser à la place.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0 ne prend pas en charge l’authentification de base par message texte.

</Callout>

1. Configurez une connexion SMS sans mot de passe. Pour savoir comment procéder, lisez la section Mettre en œuvre une connexion sans mot de passe dans [Connexions sans mot de passe](/docs/docs/fr-ca/authenticate/passwordless).
2. [Obtenez un jeton d’accès pour Management API](/docs/docs/fr-ca/secure/tokens/access-tokens/management-api-access-tokens). Vous en aurez besoin pour effectuer des appels au Management API afin de mettre à jour votre connexion sans mot de passe.
3. Utilisez le point de terminaison [OBTENIR connexions](/docs/docs/fr-ca/api/management/v2#!/Connections/get_connections) pour récupérer des informations sur les connexions associées à votre locataire. Plus précisément, vous devez obtenir l’identifiant de votre connexion SMS sans mot de passe afin de pouvoir l’utiliser dans un appel API ultérieur qui met à jour la connexion elle-même.
   Veillez à remplacer `ACCESS_TOKEN` par le jeton obtenu à l’étape 1 avant d’effectuer l’appel suivant au Management API :

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url https://your-auth0-tenant.com/api/v2/connections \
  --header 'authorization: Bearer {yourAccessToken}'
```
```csharp C# lines
var client = new RestClient("https://your-auth0-tenant.com/api/v2/connections");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourAccessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://your-auth0-tenant.com/api/v2/connections"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.get("https://your-auth0-tenant.com/api/v2/connections")
  .header("authorization", "Bearer {yourAccessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://your-auth0-tenant.com/api/v2/connections',
  headers: {authorization: 'Bearer {yourAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://your-auth0-tenant.com/api/v2/connections"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://your-auth0-tenant.com/api/v2/connections",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("your-auth0-tenant.com")

headers = { 'authorization': "Bearer {yourAccessToken}" }

conn.request("GET", "/api/v2/connections", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://your-auth0-tenant.com/api/v2/connections")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer {yourAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://your-auth0-tenant.com/api/v2/connections")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

   La réponse du point de terminaison sera un tableau d’objets. Chaque objet représente une connexion affiliée à votre locataire.
4. Déterminez l’identifiant de votre connexion. Vous pouvez trouver l’identifiant associé à votre connexion sans mot de passe en examinant le tableau d’objets que vous avez renvoyé à partir du point de terminaison [OBTENIR connexions](/docs/docs/fr-ca/api/management/v2#!/Connections/get_connections) à l’étape 2.
   Pour trouver l’objet propre à votre connexion sans mot de passe, vous pouvez rechercher la propriété `"name": "sms"`. Notez que la connexion affiche actuellement les informations Twilio que vous avez fournies au cours du processus d’installation.

   ```json lines
   [
       {
           "id": "con_UX85K7K0N86INi9U",
           "options": {
               "disable_signup": false,
               "name": "sms",
               "twilio_sid": "TWILIO_SID",
               "twilio_token": "TWILIO_AUTH_TOKEN",
               "from": "+15555555555",
               "syntax": "md_with_macros",
               "template": "Your SMS verification code is: @@password@@",
               "totp": {
                   "time_step": 300,
                   "length": 6
               },
               "messaging_service_sid": null,
               "brute_force_protection": true
           },
           "strategy": "sms",
           "name": "sms",
           "is_domain_connection": false,
           "realms": [
               "sms"
           ],
           "enabled_clients": []
       }
   ]
   ```

   

   
5. Mettez à jour la connexion. Vous pouvez le faire en effectuant un appel PATCH pour [mettre à jour un point de terminaison de connexion](/docs/docs/fr-ca/api/management/v2#!/Connections/patch_connections_by_id). Plus précisément, vous mettrez à jour l’objet connexions `options` pour fournir des informations sur la passerelle SMS.

   <Warning>

   Vous devez envoyer l’objet d’`options` complet avec chaque appel, sinon vous écraserez les données existantes qui ne seront pas incluses dans les appels suivants.

   </Warning>

   Apportez les modifications suivantes :
   * Supprimez les paramètres `twilio_sid` et `twilio_token`.
   * Ajoutez le paramètre `provider` et attribuez-lui la valeur `sms_gateway`)
   * Ajoutez le paramètre `gateway_url`, et définissez-le à l’URL de votre passerelle SMS. Auth0 doit être capable d’atteindre cette URL pour pouvoir utiliser votre passerelle et envoyer des messages en votre nom.

   Votre charge utile ressemblera à ceci :

   ```json lines
   {
       "options": {
         "strategy": "sms",
         "provider": "sms_gateway",
         "gateway_url": "{urlOfYourGateway}",
         "from": "+1 234 567",
         "template": "Your verification code is: @@password@@",
         "brute_force_protection": true,
         "forward_req_info": "true",
         "disable_signup": false,
         "name": "sms",
         "syntax": "md_with_macros",
         "totp": {
           "time_step": 300,
           "length": 6
         }
       },
       "is_domain_connection": false,
       "enabled_clients": []
   }
   ```

   

   

## Demandes authentifiées

Si votre passerelle SMS accepte les demandes authentifiées basées sur des jetons, vous pouvez ajouter ce qui suit à votre objet `options` :

```json lines
"gateway_authentication": {
    "method": "bearer",
    "subject": "urn:Auth0",
    "audience": "urn:MySmsGateway",
    "secret": "MySecretToSignTheToken",
    "secret_base64_encoded": false
}
```

Lorsque vous incluez `gateway_authentication` dans votre objet `options`, Auth0 ajoute un [Jeton Web JSON](/docs/docs/fr-ca/secure/tokens/json-web-tokens)  à l’en-tête `Authorization` chaque fois qu’il envoie des demandes à votre passerelle SMS. Le jeton contient les valeurs `gateway_authentication.subject` et `gateway_authentication.audience`, et est signé avec `gateway_authentication.secret`.

Si votre secret est encodé en base64-url, définissez `secret_base64_encoded` sur `true`.

Une fois que vous avez mis à jour votre connexion, Auth0 enverra ce qui suit à votre passerelle SMS chaque fois qu’un utilisateur s’inscrit ou se connecte avec votre connexion sans mot de passe.

```json lines
{
  "recipient": "+1 399 999",
  "body": "Your verification code is: 12345",
  "sender": "+1 234 567"
}
```

Si vous définissez la propriété `forward_req_info` de l’objet `options` sur `true`, la passerelle recevra également des informations de la requête HTTP qui a initié le processus sans mot de passe. Ces informations comprennent l’adresse IP du client appelant `/passwordless/start` et son agent utilisateur.

```json lines
{
  "recipient": "+1 399 999",
  "body": "Your verification code is: 12345",
  "sender": "+1 234 567",
  "req" : { 
      "ip" : "167.56.227.117",
      "user-agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36"
       }
}
```

## Gestion des erreurs

Auth0 ne prend en compte que le code HTTP renvoyé par la passerelle SMS; le reste de la réponse est ignoré (p. ex., le corps et le type de la réponse).

Si la passerelle SMS renvoie un code HTTP autre que 200, le point de terminaison `/passwordless/start` renvoie un code HTTP 400 et une réponse qui ressemble à ce qui suit :

```json lines
{
 "error":"sms_provider_error",
 "error_description":"Unexpected response while calling the SMS gateway: <HTTP Code Returned by the SMS Gateway>"}
}
```

Si la passerelle SMS renvoie le code HTTP 401, la `error_description` sera **Échec de l’authentification lors de l’appel à la passerelle SMS : 401**. (Veuillez noter que le texte de la description de l’erreur est susceptible d’être modifié à tout moment).

Auth0 impose un délai de 30 secondes pour les appels HTTP aux passerelles SMS personnalisées. Si la passerelle SMS ne répond pas dans ce délai, le point de terminaison `/passwordless/start` renvoie également un code HTTP 400. La réponse aura le format indiqué ci-dessus et le champ `error_description` sera **Expiration de délai en appelant la passerelle SMS < Code de l’expiration de délai >**. (Encore une fois, le texte de la description de l’erreur est susceptible d’être modifié à tout moment).