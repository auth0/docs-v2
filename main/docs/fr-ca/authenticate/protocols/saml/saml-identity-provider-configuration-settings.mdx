---
title: "Paramètres de configuration du fournisseur d’identités SAML"
permalink: "saml-identity-provider-configuration-settings"
'description': "Décrit les paramètres de configuration du fournisseur d’identités SAML."
'og:title': "Paramètres de configuration du fournisseur d’identités SAML"
'og:description': "Décrit les paramètres de configuration du fournisseur d’identités SAML."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Paramètres de configuration du fournisseur d’identités SAML"
'twitter:description': "Décrit les paramètres de configuration du fournisseur d’identités SAML."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

## Paramètres communs

Il s’agit des paramètres utilisés pour configurer un fournisseur d’identités (<Tooltip href="/docs/docs/fr-ca/glossary?term=idp" tip="Fournisseur d’identité (IdP)
Service de stockage et de gestion des identités numériques." cta="Voir le glossaire">IdP</Tooltip>) <Tooltip href="/docs/docs/fr-ca/glossary?term=security-assertion-markup-language" tip="Security Assertion Markup Language (SAML)
Protocole normalisé permettant à deux parties d’échanger des informations d’authentification sans mot de passe." cta="Voir le glossaire">SAML</Tooltip>.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Si vous avez configuré un [domaine personnalisé](/docs/docs/fr-ca/customize/custom-domains), vous devez utiliser le CNAME de votre domaine personnalisé à la place du domaine Auth0. Pour en savoir plus, consultez [Configurer les fonctionnalités pour utiliser les domaines personnalisés](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains#configure-saml-identity-providers).

</Callout>

### URL de renvoi

Lorsque vous utilisez la <Tooltip href="/docs/docs/fr-ca/glossary?term=single-sign-on" tip="Authentification unique (SSO)
Service qui, après qu’un utilisateur se soit connecté à une application, le connecte automatiquement à d’autres applications." cta="Voir le glossaire">SSO</Tooltip> initié par le fournisseur d’identité, assurez-vous d’inclure le paramètre de connexion dans l’URL de renvoi :

export const codeExample1 = `https://{yourDomain}/login/callback?connection={yourConnectionName}`;

<AuthCodeBlock children={codeExample1} language="text" lines />

Si vous utilisez la fonctionnalité [Organizations](https://auth0.com/docs/manage-users/organizations), vous pouvez éventuellement inclure un paramètre d’organization contenant l’ID de l’organization souhaitée :

export const codeExample2 = `https://{yourDomain}/login/callback?connection={yourConnectionName}&organization={yourCustomersOrganizationId}`;

<AuthCodeBlock children={codeExample2} language="text" lines />

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Pour garantir la connexion à l’aide de cette méthode, la connexion doit être activée pour l’Organization. En outre, vous devez soit configurer [l’abonnement automatique](https://auth0.com/docs/manage-users/organizations/configure-organizations/grant-just-in-time-membership) pour la connexion activée, soit vous assurer que les utilisateurs sont membres de l’organization.

</Callout>

### Identifiant de l’entité

L’identifiant du fournisseur de services est le suivant :

``` lines
urn:auth0:{yourTenant}:{yourConnectionName}
```

Vous pouvez créer un identifiant d’entité personnalisé à l’aide de la propriété `connection.options.entityId`. Pour en savoir plus, lisez [Indiquer un identifiant d’entité personnalisé](/docs/docs/fr-ca/connections/enterprise/saml#specify-a-custom-entity-id).

Vous pouvez obtenir la valeur de l’identifiant d’entité personnalisée en utilisant le point de terminaison Obtenir une connexion :

<AuthCodeGroup>
```bash cURL
curl --request GET \
  --url 'https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D' \
  --header 'authorization: Bearer {yourAccessToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourAccessToken}");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D")
  .header("authorization", "Bearer {yourAccessToken}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D',
  headers: {authorization: 'Bearer {yourAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/connections/%7ByourConnectionID%7D", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer {yourAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Remplacer la valeur de l’en-tête `ACCESS_TOKEN` par un jeton d’accès de Management APIv2.

### La liaison des requêtes SAML

Également appelé **Liaison de protocole**, il est envoyé à l’IdP par Auth0. Si possible, la valeur est fixée de manière dynamique en fonction de `connection.options.protocolBinding` :

<table class="table"><thead>
<tr>
<th>`connection.options.protocolBinding` value</th>
<th>Valeur de liaison de requêtes SAML</th>
</tr>
</thead>
<tbody>
<tr>
<td>Valeur vide ("") ou absente</td>
<td>`HTTP-Redirect`</td>
</tr>
<tr>
<td>`urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect`</td>
<td>`HTTP-Redirect`</td>
</tr>
<tr>
<td>`urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST`</td>
<td>`HTTP-POST`</td>
</tr>
</tbody>
</table>

S’il n’est pas possible de définir la valeur de manière dynamique, il faut alors définir `HTTP-Redirect` (par défaut) ou `HTTP-Post` si vous avez sélectionné cette option dans **Liaison de protocole**.

### Liaison de la réponse SAML

Comment le jeton SAML est reçu par Auth0 du fournisseur d’identité, défini comme `HTTP-Post`.

### Format du NameID

Non spécifié.

### Affirmation et réponse SAML

L’affirmation SAML et la réponse SAML peuvent être signées individuellement ou simultanément.

### URL du service SingleLogout

C’est ici que le fournisseur d’identités SAML enverra les demandes de déconnexion et les réponses :

export const codeExample13 = `https://{yourDomain}/logout`;

<AuthCodeBlock children={codeExample13} language="text" lines />

Les demandes de déconnexion SAML doivent être signées par le fournisseur d’identités.

## Assertions signées

Utilisez les liens suivants pour obtenir la clé publique dans différents formats :

* [CER](https://{yourDomain}/cer?cert=connection)
* [PEM](https://{yourDomain}/pem?cert=connection)
* [PEM brut](https://{yourDomain}/rawpem?cert=connection)
* [PKCS#7](https://{yourDomain}/pb7?cert=connection)
* [Empreinte numérique](https://{yourDomain}/fingerprint?cert=connection)

Télécharger le certificat dans le format demandé par l’IdP.

### Authentification unique initiée par l’IdP

Pour en savoir plus sur la connexion unique initiée par l’IdP, consultez [Configurer l'authentification unique initiée par l’IdP SAML](/docs/docs/fr-ca/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).

## Métadonnées

Certains fournisseurs d’identité SAML peuvent accepter d’importer directement des métadonnées contenant toutes les informations requises. Vous pouvez accéder aux métadonnées de votre connexion dans Auth0 ici :

export const codeExample14 = `https://{yourDomain}/samlp/metadata?connection={yourConnectionName}`;

<AuthCodeBlock children={codeExample14} language="text" lines />

## Organizations

Utilisez l’URL ACS de votre organization dans l’IdP fédéré pour lancer le flux de connexion d’Organizations.

export const codeExample15 = `https://{yourDomain}/samlp?connection={yourConnectionName}&organization=${yourOrgID}`;

<AuthCodeBlock children={codeExample15} language="text" lines />

## En savoir plus

* [Localiser l’identifiant de connexion ou son nom](/docs/docs/fr-ca/authenticate/identity-providers/locate-the-connection-id)
* [Personnaliser les assertions SAML](/docs/docs/fr-ca/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)
* [Dépanner des configurations SAML](/docs/docs/fr-ca/troubleshoot/authentication-issues/troubleshoot-saml-configurations)