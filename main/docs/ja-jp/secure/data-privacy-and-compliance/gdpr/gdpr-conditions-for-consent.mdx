---
title: "GDPR:同意の条件"
permalink: "gdpr-conditions-for-consent"
'description': "GDPR要件の同意条件を遵守するのに役立つAuth0機能について説明します。"
'og:title': "GDPR:同意の条件"
'og:description': "GDPR要件の同意条件を遵守するのに役立つAuth0機能について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14576.0/img/share-image.png"
'twitter:title': "GDPR:同意の条件"
'twitter:description': "GDPR要件の同意条件を遵守するのに役立つAuth0機能について説明します。"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

GDPRの第7条によると、明確かつ利用しやすい方法で、ユーザーの個人データの処理についてユーザーに同意を求める必要があります。また、ユーザーが同意したことを示さなければならず、いつでも同意を取り消すことができる簡単な方法を提供しなければなりません。

この記事では、これらの要件を実装するためのAuth0の機能の使い方について説明します。

<Note>

これらの文書の内容は、法的な助言を意図したものではなく、法的支援の代替と見なされるべきではありません。 GDPRを理解し順守することの最終責任はお客様にあり、Auth0は可能な限りにおいて、お客様がGDPR要件を満たすことを支援します。

</Note>

## 同意を求める

サインアップ時に、ユーザーに同意を求める必要があります。Auth0を使用すれば、ユーザーのメタデータにこの情報を保存できます。ユーザーを認証するときのAuth0の使い方によって、利用できるオプションがいくつかあります。メタデータを使用してソリューションをデザインする前に、制限があることにご注意ください。Auth0は、`user_metadata`の合計サイズを**16 MB**に制限しています。詳細については、[メタデータのフィールド名とデータタイプ](/docs/ja-jp/manage-users/user-accounts/metadata/metadata-fields-data)をご覧ください。

<Warning>

Auth0のメタデータはセキュリティ保護されたデータストアではないため、機密情報の保管に使用されるべきではありません。これには社会保障番号やクレジットカード番号など、高リスクの個人情報が含まれます。Auth0の顧客はメタデータに保管されているデータを評価して、IDとアクセスの管理に必要なものだけを保管することを強くお勧めします。

</Warning>

### Lockを使用する

Lock UIをカスタマイズして、条件および/またはプライバシーステートメントのページ、またユーザーがサインアップするためにチェックする必要がある同意チェックボックスへのリンクを表示できます。これは、`mustAcceptTerms`のLockオプションで設定できます。このプロパティは、`true`に設定されたとき、サインアップ前にチェックを入れる必要があるチェックボックスを条件と一緒に表示します。条件は、languageDictionaryオプションを使用して、指定できます。詳細については、「[Lock構成オプション](/docs/ja-jp/libraries/lock/lock-configuration)」をお読みください。

ユーザーが承認してサインアップすると、最初のログイン時に実行するルールを使用して、`user_metadata`に同意情報を保存します。ルールの詳細については、「[Auth0ルール](/docs/ja-jp/customize/rules)」をお読みください。

データベース接続でユーザーを認証し、サインアップ中にユーザーからより多くの情報を取得したい場合は、Lock UIにカスタムフィールドを追加できます。これは、additionalSignUpFieldsのLockオプションで設定できます。カスタムフィールドは、自動的に`user_metadata`に追加されます。

ソーシャルログインを使用している場合は、カスタムフィールドを追加できませんが、同意と追加情報を求める別のページにユーザーをリダイレクトし、その後認証処理を終わらせるために再びリダイレクトして戻すことができます。これは、リダイレクトルールを使用します。詳細については、[ルール内でユーザーをリダイレクトする](/docs/ja-jp/customize/rules/redirect-users)をお読みください。サインアップのプロセスが完了したら、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=management-api" tip="Management API: 顧客が管理タスクを実行できるようにするための製品。" cta="用語集の表示">Management API</Tooltip>[**更新ユーザー**エンドポイント](/docs/api/management/v2#!/Users/patch_users_by_id)を呼び出して、`user_metadata`に同意の情報を保存します。

これらのシナリオの実装方法については、[GDPR:Lockで同意を追跡する](/docs/ja-jp/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-lock)をご覧ください。

### カスタムUIの使用

データベース接続でカスタムサインアップフォームを使用する場合、ユーザーの同意を取得するために、サインアップ画面にフィールドを追加する必要があります。その後、Auth0にユーザーを作成するために、認証API [**サインアップ**エンドポイント](/docs/api/authentication#signup)を呼び出します。この時点で、`user_metadata`の一部として同意情報を設定できます。

または、SPAのAuth0.jsを使用する場合は、[`signup`](/docs/ja-jp/libraries/auth0js)[メソッド](/docs/ja-jp/libraries/auth0js)[を使用](/docs/ja-jp/libraries/auth0js) してAuth0にユーザーを作成し、`user_metadata`の一部として同意情報を設定できます。

ソーシャルプロバイダーのカスタムサインアップフォームを使用する場合は、サインアップ時にユーザーの同意情報を設定できませんが、ユーザーが作成されたらすぐに更新できます。Management API[**更新ユーザー**エンドポイント](/docs/api/management/v2#!/Users/patch_users_by_id)を呼び出して、`user_metadata`に同意の情報を保存します。

これらのシナリオの実装方法については、「[GDPR:カスタムUIで同意を追跡する](/docs/ja-jp/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-custom-ui)」をご覧ください。

### 再同意とユーザーの移行

既存のユーザーに同意を求める必要があり、ユーザーを既存のデータベースからAuth0に移行することを決めた場合は、[自動ユーザー移行](/docs/ja-jp/manage-users/user-migration/configure-automatic-migration-from-your-database)機能を使用できます。これを有効にすると、ユーザーが初めてログインするたびに（これが有効になっているため）、パスワードをリセットする必要なく、Auth0で作成されます。これを行うには、

* ユーザーのデータの使用方法、データが使用される期間、ユーザーの権利など、ユーザーに表示される通知を詳述し、ＵＩサインアップボックスをカスタマイズする必要があります。
* 旧条件および以前のプライバシー認証に応じて、ユーザーに対して再同意が必要かどうかを判断します。

条件を変更するたびに、再度ユーザーに同意を求める**必要があります**ので、ご注意ください。

## 同意の追跡

GDPRによると、個人データの処理にユーザーが同意したことを示すことができなければなりません。

Auth0を使用すれば、`user_metadata`の一部としてユーザーの'同意情報を保存できます。ユーザーの同意したか否かを示すフラグのみを保存するか、同意情報および優先設定一式（たとえば、ユーザーが同意した日、同意した条件など）を保存できます。その後、Management APIを使用してこの情報にアクセス、操作できます。

またManagement APIは、ユーザー検索と、ユーザーメタデータの更新またはユーザーの一括エクスポートのためのエンドポイントについて、いくつかのオプションを提供します。

Management APIにアクセスするには、アクセストークンが必要です。Management APIのアクセストークンの取得方法については、「[Management APIのアクセストークン](/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens)」をご覧ください。

### メールアドレスでユーザーを検索する

メールアドレスを使用してユーザーを検索するには、[**Search User by Email（メールアドレスでユーザー検索）**](/docs/ja-jp/manage-users/user-search/user-search-best-practices)[エンドポイント](/docs/ja-jp/manage-users/user-search/user-search-best-practices)を使用します。

返されるフィールドを制限するために、**fields**要求パラメーターを`user_metadata`に設定します。こうすることで、完全なユーザープロファイルの代わりに、user_metadataのみが返されます。

要求例：

<AuthCodeGroup>
```bash cURL
curl --request GET \
--url 'https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata' \
--header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN'
``` lines
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main
import (
"fmt"
"net/http"
"io/ioutil"
)
func main() {
url := "https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata"
req, _ := http.NewRequest("GET", url, nil)
req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
res, _ := http.DefaultClient.Do(req)
defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)
fmt.Println(res)
fmt.Println(string(body))
}
``` lines
```java Java
HttpResponse response = Unirest.get("https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata")
.header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
.asString();
```
```javascript Node.JS
var axios = require("axios").default;
var options = {
method: 'GET',
url: 'https://{yourDomain}/api/v2/users-by-email',
params: {email: 'USER_EMAIL_ADDRESS', fields: 'user_metadata'},
headers: {authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'}
};
axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});
``` lines
```obj-c Obj-C
#import 
NSDictionary \*headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN" };
NSMutableURLRequest \*request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata"]
cachePolicy:NSURLRequestUseProtocolCachePolicy
timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];
NSURLSession \*session = [NSURLSession sharedSession];
NSURLSessionDataTask \*dataTask = [session dataTaskWithRequest:request
completionHandler:^(NSData \*data, NSURLResponse \*response, NSError \*error) {
if (error) {
NSLog(@"%@", error);
} else {
NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*) response;
NSLog(@"%@", httpResponse);
}
}];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "GET",
CURLOPT_HTTPHEADER => [
"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
``` lines
```python Python
import http.client
conn = http.client.HTTPSConnection("")
headers = { 'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN" }
conn.request("GET", "/{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata", headers=headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
response = http.request(request)
puts response.read_body
``` lines
```swift Swift
import Foundation
let headers = ["authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN"]
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

応答例

```json lines
[
  {},
  {
    "user_metadata": {
      "consent": {
	    "given": true,
	    "date": "01/23/2018",
	    "text_details": "some-url"
	  }
    }
  }
]
```

### IDでユーザーを検索する

IDを使用してユーザーを検索するには、[**Get a User（ユーザーの取得）**](/docs/ja-jp/manage-users/user-search/user-search-best-practices)[エンドポイント](/docs/ja-jp/manage-users/user-search/user-search-best-practices)を使用します。

返されるフィールドを制限するために、**fields**要求パラメーターを`user_metadata`に設定します。こうすることで、完全なユーザープロファイルの代わりに、`user_metadata`のみが返されます。

要求例：

<AuthCodeGroup>
```bash cURL
curl --request GET \
--url 'https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata' \
--header 'authorization: Bearer {yourMgmtApiAccessToken}'
``` lines
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
IRestResponse response = client.Execute(request);
```
```go Go
package main
import (
"fmt"
"net/http"
"io/ioutil"
)
func main() {
url := "https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata"
req, _ := http.NewRequest("GET", url, nil)
req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")
res, _ := http.DefaultClient.Do(req)
defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)
fmt.Println(res)
fmt.Println(string(body))
}
``` lines
```java Java
HttpResponse response = Unirest.get("https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata")
.header("authorization", "Bearer {yourMgmtApiAccessToken}")
.asString();
```
```javascript Node.JS
var axios = require("axios").default;
var options = {
method: 'GET',
url: 'https://{yourDomain}/api/v2/users/%7ByourUserID%7D',
params: {fields: 'user_metadata'},
headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}
};
axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});
``` lines
```obj-c Obj-C
#import 
NSDictionary \*headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}" };
NSMutableURLRequest \*request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata"]
cachePolicy:NSURLRequestUseProtocolCachePolicy
timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];
NSURLSession \*session = [NSURLSession sharedSession];
NSURLSessionDataTask \*dataTask = [session dataTaskWithRequest:request
completionHandler:^(NSData \*data, NSURLResponse \*response, NSError \*error) {
if (error) {
NSLog(@"%@", error);
} else {
NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*) response;
NSLog(@"%@", httpResponse);
}
}];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "GET",
CURLOPT_HTTPHEADER => [
"authorization: Bearer {yourMgmtApiAccessToken}"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
``` lines
```python Python
import http.client
conn = http.client.HTTPSConnection("")
headers = { 'authorization': "Bearer {yourMgmtApiAccessToken}" }
conn.request("GET", "/{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata", headers=headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'
response = http.request(request)
puts response.read_body
``` lines
```swift Swift
import Foundation
let headers = ["authorization": "Bearer {yourMgmtApiAccessToken}"]
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

応答例

```json lines
{
  "user_metadata": {
    "consent": {
	    "given": true,
	    "date": "01/23/2018",
	    "text_details": "some-url"
  	}
  }
}
```

### 同意情報を更新する

ユーザーの`user_metadata`を更新するには、[**Update a Uwer（ユーザーの更新）**エンドポイント](/docs/api/management/v2#!/Users/patch_users_by_id)を使用します。

要求をどのように構成するかは、メタデータの構成の仕方（ルートプロパティか、内部プロパティか）によって異なります。

メタデータがルートプロパティとして保存されている場合：

```json lines
{
  "consentGiven": true,
  "consentDetails": "some-url"
}
```

メタデータが内部プロパティとして保存されている場合：

```json lines
{
  "consent": {
    "given": true,
    "text_details": "some-url"
  }
}
```

#### ルートプロパティの更新

ルートレベルのプロパティの更新はマージされるため、更新したいフィールドの値を送信するだけです。たとえば、同意日を追加して、`01/23/2018`に設定したいとします。

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
--url 'https://{yourDomain}/api/v2/users/USER_ID' \
--header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \
--header 'content-type: application/json' \
--data '{"user_metadata":{"consentDate":"01/24/2018"}}'
``` lines
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"user_metadata":{"consentDate":"01/24/2018"}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main
import (
"fmt"
"strings"
"net/http"
"io/ioutil"
)
func main() {
url := "https://{yourDomain}/api/v2/users/USER_ID"
payload := strings.NewReader("{"user_metadata":{"consentDate":"01/24/2018"}}")
req, _ := http.NewRequest("PATCH", url, payload)
req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
req.Header.Add("content-type", "application/json")
res, _ := http.DefaultClient.Do(req)
defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)
fmt.Println(res)
fmt.Println(string(body))
}
``` lines
```java Java
HttpResponse response = Unirest.patch("https://{yourDomain}/api/v2/users/USER_ID")
.header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
.header("content-type", "application/json")
.body("{"user_metadata":{"consentDate":"01/24/2018"}}")
.asString();
```
```javascript Node.JS
var axios = require("axios").default;
var options = {
method: 'PATCH',
url: 'https://{yourDomain}/api/v2/users/USER_ID',
headers: {
authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',
'content-type': 'application/json'
},
data: {user_metadata: {consentDate: '01/24/2018'}}
};
axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});
``` lines
```obj-c Obj-C
#import 
NSDictionary \*headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN",
@"content-type": @"application/json" };
NSDictionary \*parameters = @{ @"user_metadata": @{ @"consentDate": @"01/24/2018" } };
NSData \*postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];
NSMutableURLRequest \*request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
cachePolicy:NSURLRequestUseProtocolCachePolicy
timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];
NSURLSession \*session = [NSURLSession sharedSession];
NSURLSessionDataTask \*dataTask = [session dataTaskWithRequest:request
completionHandler:^(NSData \*data, NSURLResponse \*response, NSError \*error) {
if (error) {
NSLog(@"%@", error);
} else {
NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*) response;
NSLog(@"%@", httpResponse);
}
}];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "PATCH",
CURLOPT_POSTFIELDS => "{"user_metadata":{"consentDate":"01/24/2018"}}",
CURLOPT_HTTPHEADER => [
"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN",
"content-type: application/json"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
``` lines
```python Python
import http.client
conn = http.client.HTTPSConnection("")
payload = "{"user_metadata":{"consentDate":"01/24/2018"}}"
headers = {
'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
'content-type': "application/json"
}
conn.request("PATCH", "/{yourDomain}/api/v2/users/USER_ID", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/users/USER_ID")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{"user_metadata":{"consentDate":"01/24/2018"}}"
response = http.request(request)
puts response.read_body
``` lines
```swift Swift
import Foundation
let headers = [
"authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
"content-type": "application/json"
]
let parameters = ["user_metadata": ["consentDate": "01/24/2018"]] as [String : Any]
let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

これにより、ユーザープロファイルに新しいプロパティ**user_metadata.consentDate**が追加され、 顧客が同意した日を保持します。応答は完全なユーザープロファイルです。更新されたメタデータは以下のようになります。

```json lines
{
  "consentGiven": true,
  "consentDate": "01/23/2018",
  "consentDetails": "some-url"
}
```

#### 内部プロパティの更新

内部プロパティを更新するには、1つのプロパティしか更新しない場合も、メタデータオブジェクト全体を送信する必要があります。オブジェクト全体を含めなかった場合、Auth0は既存のプロパティを削除します。

同意日の内部プロパティを追加し、`01/23/2018`に設定しましょう。

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
--url 'https://{yourDomain}/api/v2/users/USER_ID' \
--header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \
--header 'content-type: application/json' \
--data '{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}'
``` lines
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main
import (
"fmt"
"strings"
"net/http"
"io/ioutil"
)
func main() {
url := "https://{yourDomain}/api/v2/users/USER_ID"
payload := strings.NewReader("{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}")
req, _ := http.NewRequest("PATCH", url, payload)
req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
req.Header.Add("content-type", "application/json")
res, _ := http.DefaultClient.Do(req)
defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)
fmt.Println(res)
fmt.Println(string(body))
}
``` lines
```java Java
HttpResponse response = Unirest.patch("https://{yourDomain}/api/v2/users/USER_ID")
.header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
.header("content-type", "application/json")
.body("{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}")
.asString();
```
```javascript Node.JS
var axios = require("axios").default;
var options = {
method: 'PATCH',
url: 'https://{yourDomain}/api/v2/users/USER_ID',
headers: {
authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',
'content-type': 'application/json'
},
data: {
user_metadata: {consent: {given: true, date: '01/23/2018', text_details: 'some-url'}}
}
};
axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});
``` lines
```obj-c Obj-C
#import 
NSDictionary \*headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN",
@"content-type": @"application/json" };
NSDictionary \*parameters = @{ @"user_metadata": @{ @"consent": @{ @"given": @YES, @"date": @"01/23/2018", @"text_details": @"some-url" } } };
NSData \*postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];
NSMutableURLRequest \*request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
cachePolicy:NSURLRequestUseProtocolCachePolicy
timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];
NSURLSession \*session = [NSURLSession sharedSession];
NSURLSessionDataTask \*dataTask = [session dataTaskWithRequest:request
completionHandler:^(NSData \*data, NSURLResponse \*response, NSError \*error) {
if (error) {
NSLog(@"%@", error);
} else {
NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*) response;
NSLog(@"%@", httpResponse);
}
}];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "PATCH",
CURLOPT_POSTFIELDS => "{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}",
CURLOPT_HTTPHEADER => [
"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN",
"content-type: application/json"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
``` lines
```python Python
import http.client
conn = http.client.HTTPSConnection("")
payload = "{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}"
headers = {
'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
'content-type': "application/json"
}
conn.request("PATCH", "/{yourDomain}/api/v2/users/USER_ID", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/users/USER_ID")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}"
response = http.request(request)
puts response.read_body
``` lines
```swift Swift
import Foundation
let headers = [
"authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
"content-type": "application/json"
]
let parameters = ["user_metadata": ["consent": [
"given": true,
"date": "01/23/2018",
"text_details": "some-url"
]]] as [String : Any]
let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

これにより、ユーザープロファイルに新しいプロパティ**user_metadata.consentDate**が追加され、 顧客が同意した日を保持します。応答は完全なユーザープロファイルです。更新されたメタデータは以下のようになります。

```json lines
{
  "consent": {
    "given": true,
    "date": "01/23/2018",
    "text_details": "some-url"
  }
}
```

### 同意情報のエクスポート

Management APIを使用してユーザーのリストをエクスポートするには、[**User Export（ユーザーエクスポート）**](/docs/ja-jp/manage-users/user-search/user-search-best-practices) [エンドポイント](/docs/ja-jp/manage-users/user-search/user-search-best-practices)を使用します。

このエンドポイントは、接続に関するすべてのユーザーをエクスポートするジョブを作成します。接続のIDが必要です。このIDを見つけるには、 [**Get Connections（接続する）** エンドポイント](/docs/api/management/v2#!/Connections/get_connections)を使用します（**name**パラメーターにこれを取得するためだけに接続名を設定することができます）。

接続IDとManagement APIのアクセストークンを取得したら、ユーザーのエクスポートを開始できます。要求と応答の例を見るには、「[ユーザーのインポートとエクスポート](/docs/ja-jp/manage-users/user-migration)」をご覧ください。Management APIのアクセストークンの取得方法については、「[Management APIのアクセストークン](/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens)」をご覧ください。

また以下を行う必要があります。

* 同意の追跡方法を決めます。ユーザーの同意日のみだけでなく、ユーザーが同意した条件のバージョンに関する情報も含めることをお勧めします。また、許可を撤回したユーザーについての情報を保持する配列も含めることをお勧めします（ユーザーは複数回、同意と撤回ができることをお忘れなく）。
* 同意を保存したい場所を選択します：Auth0のデータベースまたは他のどこか。

## 同意の撤回

アプリを使用して同意を撤回するオプションをユーザーに提供する必要があります。このオプションは、簡単にアクセスでき、はっきりと見分けがつくようにする必要があります。ユーザーが同意の撤回を決定したら、対応する必要があります。

最初に、同意の撤回にどのように対処するか決める必要があります。ユーザーを削除しますか？それとも削除済みとしてフラグを付けますか？

### ユーザーを削除

ユーザーを削除するには、[**Delete a User（ユーザーの削除）**エンドポイント](/docs/api/management/v2#!/Users/delete_users_by_id)を使用します。

<AuthCodeGroup>
```bash cURL
curl --request DELETE \
--url 'https://{yourDomain}/api/v2/users/USER_ID' \
--header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN'
``` lines
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.DELETE);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```
```go Go
package main
import (
"fmt"
"net/http"
"io/ioutil"
)
func main() {
url := "https://{yourDomain}/api/v2/users/USER_ID"
req, _ := http.NewRequest("DELETE", url, nil)
req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
res, _ := http.DefaultClient.Do(req)
defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)
fmt.Println(res)
fmt.Println(string(body))
}
``` lines
```java Java
HttpResponse response = Unirest.delete("https://{yourDomain}/api/v2/users/USER_ID")
.header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
.asString();
```
```javascript Node.JS
var axios = require("axios").default;
var options = {
method: 'DELETE',
url: 'https://{yourDomain}/api/v2/users/USER_ID',
headers: {authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'}
};
axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});
``` lines
```obj-c Obj-C
#import 
NSDictionary \*headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN" };
NSMutableURLRequest \*request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
cachePolicy:NSURLRequestUseProtocolCachePolicy
timeoutInterval:10.0];
[request setHTTPMethod:@"DELETE"];
[request setAllHTTPHeaderFields:headers];
NSURLSession \*session = [NSURLSession sharedSession];
NSURLSessionDataTask \*dataTask = [session dataTaskWithRequest:request
completionHandler:^(NSData \*data, NSURLResponse \*response, NSError \*error) {
if (error) {
NSLog(@"%@", error);
} else {
NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*) response;
NSLog(@"%@", httpResponse);
}
}];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "DELETE",
CURLOPT_HTTPHEADER => [
"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
``` lines
```python Python
import http.client
conn = http.client.HTTPSConnection("")
headers = { 'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN" }
conn.request("DELETE", "/{yourDomain}/api/v2/users/USER_ID", headers=headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/users/USER_ID")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Delete.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
response = http.request(request)
puts response.read_body
``` lines
```swift Swift
import Foundation
let headers = ["authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN"]
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

このエンドポイントの応答本文は空白のため、ユーザーが正常に削除されたことを確認したい場合は、メールアドレスを使用してユーザーの取得を試みます。エンドポイントがエラーを返したら、ユーザーの削除が成功したことを意味します。

### 削除済みとしてユーザーにフラグを付ける

ユーザーを削除したくない場合は、[**app_metadata** エンドポイント](/docs/api/management/v2#!/Users/patch_users_by_id)を使用し、削除済みとしてプロファイルにフラグを付けます。その後、そのようにフラグ付けされたプロファイルのユーザーに対して、認証プロセスが失敗するようにコードを追加します。

これにより、今後の使用のために、削除済みのユーザーの記録を保持できます。

#### プロファイルにフラグを付ける

削除済みとしてユーザーにフラグを付けるには、app_metadataを使用します。以下の例では、**［deleted（削除済み）］**と呼ばれるプロパティを、**app_metadata**フィールドに追加する方法を示しています。これにより、このプロパティがtrueに設定されたユーザー全員を削除済みとして取り扱うように認証プロセスを構成できます。

ユーザーのメタデータを更新するには、[**Update a User（ユーザーの更新）**エンドポイント](/docs/api/management/v2#!/Users/patch_users_by_id)を使用します。

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
--url 'https://{yourDomain}/api/v2/users/USER_ID' \
--header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \
--header 'content-type: application/json' \
--data '{"app_metadata":{"deleted":true}}'
``` lines
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"app_metadata":{"deleted":true}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main
import (
"fmt"
"strings"
"net/http"
"io/ioutil"
)
func main() {
url := "https://{yourDomain}/api/v2/users/USER_ID"
payload := strings.NewReader("{"app_metadata":{"deleted":true}}")
req, _ := http.NewRequest("PATCH", url, payload)
req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
req.Header.Add("content-type", "application/json")
res, _ := http.DefaultClient.Do(req)
defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)
fmt.Println(res)
fmt.Println(string(body))
}
``` lines
```java Java
HttpResponse response = Unirest.patch("https://{yourDomain}/api/v2/users/USER_ID")
.header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
.header("content-type", "application/json")
.body("{"app_metadata":{"deleted":true}}")
.asString();
```
```javascript Node.JS
var axios = require("axios").default;
var options = {
method: 'PATCH',
url: 'https://{yourDomain}/api/v2/users/USER_ID',
headers: {
authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',
'content-type': 'application/json'
},
data: {app_metadata: {deleted: true}}
};
axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});
``` lines
```obj-c Obj-C
#import 
NSDictionary \*headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN",
@"content-type": @"application/json" };
NSDictionary \*parameters = @{ @"app_metadata": @{ @"deleted": @YES } };
NSData \*postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];
NSMutableURLRequest \*request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
cachePolicy:NSURLRequestUseProtocolCachePolicy
timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];
NSURLSession \*session = [NSURLSession sharedSession];
NSURLSessionDataTask \*dataTask = [session dataTaskWithRequest:request
completionHandler:^(NSData \*data, NSURLResponse \*response, NSError \*error) {
if (error) {
NSLog(@"%@", error);
} else {
NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*) response;
NSLog(@"%@", httpResponse);
}
}];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "PATCH",
CURLOPT_POSTFIELDS => "{"app_metadata":{"deleted":true}}",
CURLOPT_HTTPHEADER => [
"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN",
"content-type: application/json"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
``` lines
```python Python
import http.client
conn = http.client.HTTPSConnection("")
payload = "{"app_metadata":{"deleted":true}}"
headers = {
'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
'content-type': "application/json"
}
conn.request("PATCH", "/{yourDomain}/api/v2/users/USER_ID", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/users/USER_ID")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{"app_metadata":{"deleted":true}}"
response = http.request(request)
puts response.read_body
``` lines
```swift Swift
import Foundation
let headers = [
"authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
"content-type": "application/json"
]
let parameters = ["app_metadata": ["deleted": true]] as [String : Any]
let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

#### フラグ付けされたユーザーのログインを無効にする

次に、削除済みとフラグ付けされたユーザーのログインを無効にする必要があります。これを行うには、ルールを追加します（認証パイプラインの一部として実行するJavaScriptスニペット）。

1. [［Auth0 Dashboard］>［Auth Pipeline（Authパイプライン）］>［Rules（ルール）］](https://manage.auth0.com/#/rules)に移動して、ルールを作成します。
2. 以下のスクリプトをコピーします。

   ```javascript lines
   function (user, context, callback) {
     user.app_metadata = user.app_metadata || {};
     if (user.app_metadata.deleted){
     	return callback(new UnauthorizedError('Access denied (deleted user)'));
     }
     callback(null, user, context);
   }
   ```

   

   

   スクリプトは以下を実行します。
   1. **deleted（削除済み）**メタデータプロパティ（`user.app_metadata.deleted`）の値を確認します。
   2. `user.app_metadata.deleted = true`の場合、アプリに`Access denied (deleted user)`エラーを返します。
3. ルールに名前を付けて、変更を保存します。

また以下を行う必要があります。

* 同意の撤回が十分に詳述されていることを確認する。
* 顧客が同意を撤回できるエリアをアプリに設定する。

## もっと詳しく

* [GDPR:データの最小化](/docs/ja-jp/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)
* [GDPR:データポータビリティ](/docs/ja-jp/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)
* [GDPR：ユーザーデータを安全に保護する](/docs/ja-jp/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)
* [GDPR:データのアクセス権、訂正および消去の権利](/docs/ja-jp/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)