---
description: ''
og:description: How to install, initialize and use auth0.js v9
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Auth0.js v9の参考情報
og:url: https://auth0.com/docs/
permalink: auth0js
title: Auth0.js v9の参考情報
twitter:description: How to install, initialize and use auth0.js v9
twitter:title: Auth0.js v9の参考情報
---

Auth0.js is a client-side JavaScript library for Auth0. It supports both [hosted login and embedded login](/docs/authenticate/login/universal-vs-embedded-login) use cases.

The full API documentation for the library is [here](https://auth0.github.io/auth0.js/index.html).

<Warning>

Embedded login for web applications uses [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) unless you [configure a custom domain](/docs/customize/custom-domains) for your tenant. Cross-origin authentication uses third-party cookies to allow for secure authentication transactions across different origins.

</Warning>

## そのまま使えるサンプル

The [example directory](https://github.com/auth0/auth0.js/tree/master/example) of the auth0.js library is a ready-to-go app that can help you to quickly and easily try out auth0.js. In order to run it, follow these quick steps:

1. If you don't have [node](http://nodejs.org/) installed, do that now
2. Download dependencies by running `npm install` from the root of this project
3. Finally, execute `npm start` from the root of this project, and then browse to your app running on the node server, presumably at `http://localhost:3000/example`.

## セットアップと初期化

それでは、プロジェクトにauth0.jsを統合しましょう。ここでは、[インストールの方法](#installation-options)、[auth0.jsの初期化](#initialization)、[サインアップ](#signup)、[ログイン](#login)、[ログアウト](#logout)などについて説明します。

### Configure your Auth0 application for embedded login

When implementing embedded login, the library will use cross-origin calls inside hidden iframes to perform authentication. To make sure this can be done securely, Auth0 needs to know the domains where you will be hosting your applications.

Add the domain to the **Allowed Web Origins** field. You can find this field in the [Application Settings](https://manage.auth0.com/#/applications) area of your Dashboard.

### インストールオプション

プロジェクトでauth0.jsを使用するには、いくつかのオプションがあります。ニーズに合わせて以下のいずれかを選択します。

Install via [npm](https://npmjs.org) or [yarn](https://yarnpkg.com):

```bash lines
npm install auth0-js

yarn add auth0-js
```

初期化

```js lines
import auth0 from 'auth0-js';
```

Auth0アプリケーションの新しいインスタンスを次のように初期化します。

```html wrap lines
<script src="https://cdn.auth0.com/js/auth0/9.18/auth0.min.js"></script>
```

### 使用可能なパラメーター

クロックスキューの問題により、時折「`The token was issued in the future`（トークンが未来に発行された）」というエラーが発生することがあります。`leeway`パラメーターを使用して、IDトークンの有効期限までに数秒の余裕を持たせ、これを防ぎます。

```html lines
<script type="text/javascript">
  var webAuth = new auth0.WebAuth({
    domain:       '{yourDomain}',
    clientID:     '{yourClientId}'
  });
</script>
```

#### Scope（スコープ）

auth0.js v9でのデフォルトの`スコープ`値は、`openid profile email`です。

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `domain` | required | (String) Your Auth0 account domain (ex. myaccount.auth0.com) |
| `clientID` | required | (String) Your Auth0 client ID |
| `redirectUri` | optional\* | (String) The default `redirectUri` used. Defaults to an empty string (none). **If you do not provide a global `redirectUri` value here, you will need to provide a redirectUri value for *each* method you use.** |
| `scope` | optional | (String) The default <Tooltip tip="Scope: Mechanism that determines actions applications can perform on a user's behalf with information previously created in an online resource." cta="View Glossary" href="/docs/glossary?term=scope%28s%29">scope(s)</Tooltip> used by the application. Using scopes can allow you to return specific claims for specific fields in your request. You should read our [documentation on scopes](/docs/get-started/apis/scopes) for further details. |
| `audience` | optional | (String) The default audience to be used for requesting API access. |
| `responseType` | optional\* | (String) The default `responseType` used. It can be any space separated list of the values `code`, `token`, `id_token`. It defaults to `'token'`, unless a `redirectUri` is provided, then it defaults to `'code'`. **If you do not provide a global `responseType` value, you will need to provide a `responseType` value for *each* method you use.** |
| `responseMode` | optional | (String) This option is omitted by default. Can be set to `'form_post'` in order to send the token or code to the `'redirectUri'` via POST. Supported values are `query`, `fragment` and `form_post`. |
| `leeway` | optional | (Integer) A value in seconds; leeway to allow for clock skew with regard to ID Token expiration times. |
| `_disableDeprecationWarnings` | optional | (Boolean) Disables the deprecation warnings, defaults to `false`. |

ログイン

##### ログインのメソッドは、アプリケーションで必要なauthの種類に従って選ぶことができます。

webAuth.popup.authorize()

<Card title="Running Auth0.js locally">

If you don't specify at least the above scope when initializing auth0.js, and you are running your website from `http://localhost` or `http://127.0.0.1`, calling the `getSSOData()` method will result in the following error in the browser console:

`Consent required. When using getSSOData, the user has to be authenticated with the following scope: openid profile email`

That will not happen when you run your application in production or if you specify the `openid profile email` scope. You can read more about this in the [User consent and third-party applications](/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) document.

</Card>

## ホスト型のログインでは、`/authorize()`メソッドを呼び出す必要があります。

ソーシャルログインの場合、`connection`パラメーターを指定する必要があります。

### webAuth.popup.authorize()

The `authorize()` method can be used for logging in users through <Tooltip tip="Universal Login: Your application redirects to Universal Login, hosted on Auth0's Authorization Server, to verify a user's identity." cta="View Glossary" href="/docs/glossary?term=Universal+Login">Universal Login</Tooltip> or social connections as shown in the examples below. This method invokes the `/authorize` endpoint of the Authentication API, and can take a variety of parameters through the `options` object.

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `audience` | optional | (String) The default audience to be used for requesting API access. |
| `connection` | optional | (String) Specifies the connection to use rather than presenting all connections available to the application. |
| `scope` | optional | (String) The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OIDC scopes about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](/docs/secure/tokens/json-web-tokens/create-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Token">Refresh Token</Tooltip>. |
| `responseType` | optional | (String) It can be any space separated list of the values `code`, `token`, `id_token`. It defaults to `'token'`, unless a `redirectUri` is provided, then it defaults to `'code'`. |
| `clientID` | optional | (String) Your Auth0 client ID. |
| `redirectUri` | optional | (String) The URL to which Auth0 will redirect the browser after authorization has been granted for the user. |
| `state` | optional | (String) An arbitrary value that should be maintained across redirects. It is useful to mitigate CSRF attacks and for any contextual information (for example, a return URL) that you might need after the authentication process is finished. For more information, see [State Parameter](/docs/secure/attack-protection/state-parameters). auth0.js, when used in single-page applications, handles the state generation and validation automatically if not specified. |
| `prompt` | optional | (String) A value of `login` will force the login page to show regardless of current session. A value of `none` will attempt to bypass the login prompts if a session already exists (see the [silent authentication](/docs/authenticate/single-sign-on#silent-authentication) documentation for more details). |

ポップアップを使ったデフォルト認可（ユーザーにAuth0のユニバーサルログインが表示されます）：

`webAuth.authorize({//Any additional options can go here});`

ポップアップを使用したソーシャルログインの場合は、`authorize`を使用します。

`webAuth.authorize({connection: 'twitter'});`

### ポップアップ認証の結果の処理

ポップアップ認証を使用する場合、`redirectUri`を指定する必要があります。ここでは、宛先のページが`webAuth.popup.callback`メソッドを使用して認可の結果をコールバックに知らせます。簡単な実装は、以下のようになります：

このような最小限の機能性のみを備えた（この応答を処理するためだけにアプリケーション全体を再読み込みしない）ハンドラーが理想的です。

```js lines
webAuth.popup.authorize({
  responseType: 'token'
  redirectUri: 'https://{yourApp}/popup_response_handler.html'
  //Any additional options can go here
}, function(err, authResult) {
  //do something
});
```

Dashboardのアプリケーション構成ページで、`redirectUri`をアプリケーションの**［Allowed Callback URLs（許可されているコールバックURL）］**リストに追加する必要があります。

```js lines
webAuth.popup.authorize({
  responseType: 'token'
  redirectUri: 'https://{yourApp}/popup_response_handler.html',
  connection: 'twitter'
}, function(err, authResult) {
  //do something
});
```

#### パスワードレス認証は、ユーザーがメールやテキストメッセージでワンタイムパスワードを受信することにより、ログインできるようにします。それには、パスワードレス処理を開始し、コード（またはリンク内のコード）を生成してユーザーに送信し、検証方法を介してユーザーの資格情報を承認する必要があります。このプロセスは、ログイン画面の形で実行し、ユーザーにメールアドレス（または電話番号）とそこに送信したばかりのコードの入力を求めます。コードではなく、パスワードレスのリンクを送信することもできます。ユーザーは、メールやテキストに含まれているリンクをクリックするだけでエンドポイントに到達し、このデータが同じ検証方法を使って自動的に検証されます（ユーザーが手動でコードを入力しない点のみが異なります）。

パスワードレス認証を開始する

```html lines
<!-- popup_response_handler.html -->
<html>
  <body>
    <script src="https://cdn.auth0.com/js/auth0/9.18/auth0.min.js"></script>
    <script type="text/javascript">
      var webAuth = new auth0.WebAuth({
        domain:       'YOUR_AUTH0_DOMAIN',
        clientID:     'YOUR_CLIENT_ID'
      });
      webAuth.popup.callback();
    </script>
  </body>
</html>
```

パスワードレスのトランザクションを開始するには、オプションの`phoneNumber`と`email`パラメーターのうち、必ず1つを送信する必要があることにご注意ください。

パスワードレスログイン

### パスワードレス認証は、ユーザーがメールやテキストメッセージでワンタイムパスワードを受信することにより、ログインできるようにします。それには、パスワードレス処理を開始し、コード（またはリンク内のコード）を生成してユーザーに送信し、検証方法を介してユーザーの資格情報を承認する必要があります。このプロセスは、ログイン画面の形で実行し、ユーザーにメールアドレス（または電話番号）とそこに送信したばかりのコードの入力を求めます。コードではなく、パスワードレスのリンクを送信することもできます。ユーザーは、メールやテキストに含まれているリンクをクリックするだけでエンドポイントに到達し、このデータが同じ検証方法を使って自動的に検証されます（ユーザーが手動でコードを入力しない点のみが異なります）。

<Warning>

Embedded login for web applications uses [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) unless you [configure a custom domain](/docs/customize/custom-domains) for your tenant. Cross-origin authentication uses third-party cookies to allow for secure authentication transactions across different origins.

</Warning>

The `login` method can be used for embedded login through [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) for database connections, using `/co/authenticate`.

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `username` | optional | (String) The username to present for authentication. **Either** `username` or `email` must be present. |
| `email` | optional | (String) The email to present for authentication. **Either** `username` or `email` must be present. |
| `password` | required | (String) The password to present for authentication. |
| `realm` | required | (String) The name of the database connection against which to authenticate. |

```js lines
webAuth.login({
  realm: 'tests',
  username: 'testuser',
  password: 'testpass',
});
```

### パスワードレス認証を開始する

The `crossOriginVerification()` method can be used to help provide cross-origin authentication to customers who have third-party cookies disabled in their browsers. Further details about its usage can be read in the [cross-origin authentication](/docs/authenticate/login/cross-origin-authentication) document.

### パスワードレスのトランザクションを開始するには、オプションの`phoneNumber`と`email`パラメーターのうち、必ず1つを送信する必要があることにご注意ください。

パスワードレス認証を完了する


```js lines
// Calculate URL to redirect to
var url = webAuth.client.buildAuthorizeUrl({
  clientID: '{yourClientId}', // string
  responseType: 'token id_token', // code
  redirectUri: 'https://{yourApp}/callback',
  state: '{yourState}',
  nonce: '{yourNonce}'
});

// Redirect to url
// ...
```

The `state` parameter is an opaque value that Auth0 will send back to you. This method helps prevent CSRF attacks, and it needs to be specified if you redirect to the URL yourself instead of calling `webAuth.authorize()`. For more information, see [State Parameter](/docs/secure/attack-protection/state-parameters).

### Single Sign-On with embedded authentication

Apps with embedded login must meet two criteria in order to have <Tooltip tip="Single Sign-On (SSO): Service that, after a user logs into one applicaton, automatically logs that user in to other applications." cta="View Glossary" href="/docs/glossary?term=Single+Sign-on">Single Sign-on</Tooltip> (SSO).

1. Both of the applications attempting SSO must be first-party applications. SSO with third-party applications will not work.
2. They need to make use of custom domains and have both the applications which intend to have SSO as well as the Auth0 tenant on the same domain. Traditionally, Auth0 domains are in the format `foo.auth0.com`, but custom domains allow you to use the same domain for each of the applications in question as well as your Auth0 tenant, preventing the risk of CSRF attacks.

Our recommendation is to use Universal ホスト型のログインでは、`/authorize()`メソッドを呼び出す必要があります。 instead of setting up SSO in embedded login scenarios. Universal ホスト型のログインでは、`/authorize()`メソッドを呼び出す必要があります。 is the most reliable and stable way to perform SSO, and is the only way to do so if you must use multiple domains for your applications, or use [third-party applications](/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).

## authResultを抽出してユーザー情報を取得する

<Tooltip tip="Passwordless: Form of authentication that does not rely on a password as the first factor." cta="View Glossary" href="/docs/glossary?term=Passwordless">Passwordless</Tooltip> authentication allows users to log in by receiving a one-time password through email or text message. The process will require you to start the passwordless process, generating and dispatching a code to the user (or a code within a link), followed by accepting their credentials through the verification method. That could happen in the form of a login screen which asks for their (email or phone number) and the code you just sent them. It could also be implemented in the form of a passwordless link instead of a code sent to the user. They would simply click the link in their email or text and it would hit your endpoint and verify this data automatically using the same verification method (just without manual entry of a code by the user).

上に示すように、`client.userInfo`メソッドは、返された`accessToken`を渡して呼び出すことができます。その場合、`/userinfo`エンドポイントに要求が送られ、以下の例と同様の形式で、ユーザー情報が入った`user`オブジェクトが返されます。


```js lines
var webAuth = new auth0.WebAuth({
  clientID: '{yourClientId}',
  domain: '{yourDomain}',
  redirectUri: 'http://example.com',
  responseType: 'token id_token'
});
```

### この情報を使って、アプリケーションのニーズに合わせ、何らかの処理を行うことができます。1つの例として、Management APIを使ってユーザーの全プロファイル情報を取得する方法をご紹介します。

nonceの使用

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `connection` | required | (String) Specifies how to send the code/link to the user. Value must be either `email` or `sms`. |
| `send` | required | (String) Value must be either `code` or `link`. If `null`, a link will be sent. |
| `phoneNumber` | optional | (String) The user's phone number for delivery of a code or link via SMS. |
| `email` | optional | (String) The user's email for delivery of a code or link via email. |

デフォルトでは（および`responseType`に`id_token`が含まれている場合）、`auth0.js`は`webAuth.authorize`を呼び出す時にランダムな`nonce`を生成し、これをローカルストレージに保存し、それを`webAuth.parseHash`で取り出します。このデフォルトの動作はほとんどのケースに適していますが、場合によっては開発者が`nonce`を管理しなければならないこともあります。

```js lines
webAuth.passwordlessStart({
    connection: 'email',
    send: 'code',
    email: 'foo@bar.com'
  }, function (err,res) {
    // handle errors or continue
  }
);
```

### 開発者が生成した`nonce`を使用する場合、`webAuth.authorize`と`webAuth.parseHash`の両方にオプションとしてこれを提供する必要があります。

`webAuth.parseHash({nonce:'1234'}, callback);`

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `connection` | required | (String) Specifies how to send the code/link to the user. Value must be either `email` or `sms` and the same as the value passed to `passwordlessStart`. |
| `verificationCode` | required | (String) The code sent to the user, either as a code or embedded in a link. |
| `phoneNumber` | optional | (String) The user's phone number to which the code or link was delivered via SMS. |
| `email` | optional | (String) The user's email to which the code or link was delivered via email. |

エラーコードと説明

Auth0.jsが埋め込みログインに使用される場合、`/co/authenticate`エンドポイントが使用されますが、以下のようなエラーが生じる可能性があります。

```js lines
webAuth.passwordlessLogin({
    connection: 'email',
    email: 'foo@bar.com',
    verificationCode: '389945'
  }, function (err,res) {
    // handle errors or continue
  }
);
```

## また、`error`または`error_description`プロパティがなくても、一般エラーの403が起きることもあります。応答のボディは、次のようになります：

ログアウト

ユーザーをログアウトさせるには、`logout()`メソッドを使用します。このメソッドは、次のようなパラメータを含むoptionsオブジェクトを受け取ります。

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `state` | optional | (String) An opaque value the application adds to the initial request that Auth0 includes when redirecting back to the application. This value is used by auth0.js to prevent CSRF attacks. |
| <Tooltip tip="Nonce: Arbitrary number issued once in an authentication protocol to detect and prevent replay attacks." cta="View Glossary" href="/docs/glossary?term=nonce">nonce</Tooltip> | optional | (String) Used to verify the ID Token |
| `hash` | optional | (String) The URL hash (if not provided, `window.location.hash` will be used by default) |

サインアップ

| **Item** | **Description** |
| --- | --- |
| `accessToken` | An <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=Access+Token">Access Token</Tooltip> for the API, specified by the `audience` |
| `expiresIn` | A string containing the expiration time (in seconds) of the `accessToken` |
| `idToken` | An ID Token JWT containing user profile information |

```js lines
webAuth.parseHash({ hash: window.location.hash }, function(err, authResult) {
  if (err) {
    return console.log(err);
  }

  webAuth.client.userInfo(authResult.accessToken, function(err, user) {
    // Now you have the user's information
  });
});
```

ユーザーのサインアップには、`signup`メソッドを使用します。このメソッドは、次のようなパラメータを含むoptionsオブジェクトを受け取ります。

```json lines
{
    "sub": "auth0|123456789012345678901234",
    "nickname": "johnfoo",
    "name": "johnfoo@gmail.com",
    "picture": "https://gravatar.com/avatar/example.png",
    "updated_at": "2018-05-07T14:16:52.013Z",
    "email": "johnfoo@gmail.com",
    "email_verified": "false"
}
```

You can now do something else with this information as your application needs, such as acquire the user's entire set of profile information with the <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip>, as described below.

## checkSessionを使った新しいトークンの取得

また、`audience`と`scope`を指定することによって、`webAuth`の初期化の際に使用されたAPIとは異なるAPIのトークンを取得することもできます。
ただし、ブラウザーではサードパーティのクッキーが有効になっている**必要があります**。有効になっていなければ、**checkSession()**は現在のユーザーのセッションにアクセスできません（ユーザーに何も表示せずに新しいトークンを取得することが不可能になります）。ユーザーが[SafariのITPを有効](/troubleshoot/troubleshoot-authentication/renew-tokens-when-using-safari)にしている場合にも同様のことが起こります。
`webAuth.authorize({`<Tooltip tip="Nonce: Arbitrary number issued once in an authentication protocol to detect and prevent replay attacks." cta="View Glossary" href="/docs/glossary?term=nonce">nonce</Tooltip>: '1234', responseType: 'token id_token'});
checkSession()でのポーリング

パスワードのリセット要求

```js lines
webAuth.checkSession({
  nonce: '1234',
}, function (err, authResult) {
    ...
});
```

The `webAuth.checkSession` method will automatically verify that the returned <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip>'s `nonce` claim is the same as the option.

## すると、ユーザーに、パスワードリセット用のリンクを含んだメールが届きます。

ユーザー管理

<Warning>

Error descriptions are intended to be human readable. The description **should not be parsed by any code** and is subject to change at any time.

</Warning>

| **Status** | **Code** | **Description** |
| --- | --- | --- |
| 400 | invalid_request | Invalid request body. All and only of client_id, credential_type, username, otp, realm are required. |
| 401 | unauthorized_client | Cross origin login not allowed. |
| 400 | unsupported_credential_type | Unknown credential type parameter. |
| 400 | invalid_request | Unknown realm non-existent-connection. |
| 403 | access_denied | Wrong email or password. |
| 403 | access_denied | Authentication error |
| 403 | blocked_user | Blocked user |
| 401 | password_leaked | This login attempt has been blocked because the password you're using was previously disclosed through a data breach (not in this application). |
| 429 | too_many_attempts | Your account has been blocked after multiple consecutive login attempts. We've sent you a notification via your preferred contact method with instructions on how to unblock it. |
| 429 | too_many_attempts | We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator. |

Management APIの機能を使うと、異なるプロバイダーからの個別のユーザーアカウントをリンクしたり、リンクを解除したりして、1つのプロファイルにまとめることができます（詳細については「[ユーザーアカウントのリンク](/users/user-account-linking)」を参照してください）。また、ユーザーメタデータを更新することもできます。
`Origin https://test.app is not allowed.`

## まず、Management APIの呼び出しに使用可能なアクセストークンを取得する必要があります。auth0.jsを初期化する際に`

また、`checkSession()`を使用してこれを行うこともできます。

If the `clientID` parameter is included, the `returnTo` URL that is provided must be listed in the Application's **Allowed まず、Management APIの呼び出しに使用可能なアクセストークンを取得する必要があります。auth0.jsを初期化する際に` URLs** in the [Auth0 dashboard](https://manage.auth0.com/#). However, if the `clientID` parameter is not included, the `returnTo` URL must be listed in the **Allowed まず、Management APIの呼び出しに使用可能なアクセストークンを取得する必要があります。auth0.jsを初期化する際に` URLs** at the account level in the [Auth0 dashboard](https://manage.auth0.com/#).

```js lines
webAuth.logout({
  returnTo: 'some url here',
  clientID: 'some client ID here'
});
```

## `read:current_user`

`update:current_user_identities`

| **Parameter** | **Required** | **Description** |
| --- | --- | --- |
| `email` | required | (String) User's email address |
| `password` | required | (String) User's desired password |
| `username` | required\* | (String) User's desired username.  \*Required if you use a database connection and you have enabled **Requires Username** |
| `connection` | required | (String) The database connection name on your application upon which to attempt user account creation |
| `user_metadata` | optional | (JSON object) Additional attributes used for user information. Will be stored in [user\_metadata](/docs/manage-users/user-accounts/metadata) |

`create:current_user_metadata`

```html lines
<h2>Signup Database Connection</h2>
<input class="signup-email" />
<input type="password" class="signup-password" />
<input type="button" class="signup-db" value="Signup!" />
<script type="text/javascript">
    $('.signup-db').click(function (e) {
        e.preventDefault();
        webAuth.signup({
            connection: 'Username-Password-Authentication',
            email: $('.signup-email').val(),
            password: $('.signup-password').val(),
            user_metadata: { plan: 'silver', team_id: 'a111' }
        }, function (err) {
            if (err) return alert('Something went wrong: ' + err.message);
            return alert('success signup without login!')
        });
    });
</script>
```

## `update:current_user_metadata`

`delete:current_user_metadata`

The call to `checkSession` can be used to get a new token for the API that was specified as the <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> when `webAuth` was initialized:

```js lines
webAuth.checkSession({}, function (err, authResult) {
  // err if automatic parseHash fails
  ...
});
```

`delete:current_user_device_credentials`

アクセストークンを取得したら、そのアカウントのAuth0ドメインとアクセストークンを渡して新しい`auth0.Management`インスタンスを作成することができます。

```js lines
webAuth.checkSession(
  {
    audience: `https://mydomain/another-api/˜`,
    scope: 'read:messages'
  }, function (err, authResult) {
  // err if automatic parseHash fails
  ...
});
```

Note that `checkSession()` triggers any [rules](/docs/customize/rules) you may have set up, so you should check on your rules in the [Dashboard](https://manage.auth0.com/#/rules) prior to using it.

ユーザープロファイルデータを取得するには、`getUser()`メソッドを使用します。このメソッドには、`userId`とコールバックをパラメーターとして渡します。メソッドはユーザープロファイルを返します。ここで必要とされる`userID`は、`client.userInfo`メソッドから取得したものと同じであることにご注意ください。

However, the browser **must** have third-party cookies enabled. Otherwise, **checkSession()** is unable to access the current user's session (making it impossible to obtain a new token without displaying anything to the user). The same will happen if users have [Safari's ITP enabled](/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).

Remember to add the URL where the authorization request originates from, to the **Allowed Web Origins** list of your Auth0 application in the [Dashboard](https://manage.auth0.com/#) under your application's **Settings**.

<Warning>

If the connection is a social connection and you are using Auth0 dev keys, the `checkSession` call will always return `login_required`.

</Warning>

### ユーザーのリンク

In some multi-application scenarios, where Single まず、Management APIの呼び出しに使用可能なアクセストークンを取得する必要があります。auth0.jsを初期化する際に` is desired (a user logging out of one application needs to be logged out of other applications), an application can be set up to periodically poll Auth0 using `checkSession()` to see if a session exists. If the session does not exist, you can then log the user out of the application. The same polling method can be used to implement silent authentication for a Single Sign-on (SSO) scenario.

The poll interval between checks to `checkSession()` should be at least 15 minutes between calls to avoid any issues in the future with rate limiting of this call.

## ユーザーアカウントをリンクすると、ユーザーがどのアカウントからでも認証できるようになり、どのアカウントを使用してログインしても同じプロファイルが引き出されます。Auth0では、デフォルトですべてのアカウントが個別のプロファイルとして扱われるため、ユーザーのアカウントをリンクしたい場合は以下の手順が必要です。

アカウントをリンクすると、セカンダリーアカウントは、ユーザーデータベースの中で別途のアカウントとして存在しなくなり、プライマリーアカウントの一部としてしかアクセスできなくなります。

```js lines
$('.change_password').click(function () {
    webAuth.changePassword({
      connection: 'db-conn',
      email:   'foo@bar.com'
    }, function (err, resp) {
      if(err){
        console.log(err.message);
      }else{
        console.log(resp);
      }
    });
  });
```

アカウントがリンクされている場合、セカンダリ―アカウントのメタデータはプライマリーアカウントのメタデータと**統合されません**。また、リンクが解除されると、セカンダリーアカウントが再び独立した際にプライマリーアカウントのメタデータは保持されません。

## User management

The Management API provides functionality that allows you to link and unlink separate user accounts from different providers and update user metadata. For more information, read [User Account Linking](/docs/manage-users/user-accounts/user-account-linking).

To get started, you first need to obtain a an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> that can be used to call the Management API. You can do it by specifying the `https://{yourDomain}/api/v2/` audience when initializing auth0.js, in which case you will get the access token as part of the authentication flow.

If you use [custom domains](/docs/customize/custom-domains), you will need to instantiate a new copy of `webAuth` using your Auth0 domain rather than your custom one, for use with the Management API calls, as it only works with Auth0 domains.

```js lines
var webAuth = new auth0.WebAuth({
  clientID: '{yourClientId}',
  domain: '{yourDomain}',
  redirectUri: 'http://example.com',
  audience: `https://{yourDomain}/api/v2/`,
  scope: 'read:current_user',
  responseType: 'token id_token'
});
```

You can also do so by using `checkSession()`:

```js lines
webAuth.checkSession(
  {
    audience: `https://{yourDomain}/api/v2/`,
    scope: 'read:current_user'
  }, function(err, result) {
     // use result.accessToken
  }
);
```

You must specify the specific scopes you need. You can ask for the following scopes:

* `read:current_user`
* `update:current_user_identities`
* `create:current_user_metadata`
* `update:current_user_metadata`
* `delete:current_user_metadata`
* `create:current_user_device_credentials`
* `delete:current_user_device_credentials`

Once you have the access token, you can create a new `auth0.Management` instance by passing it the account's Auth0 domain, and the access token.

```js lines
var auth0Manage = new auth0.Management({
  domain: '{yourDomain}',
  token: 'ACCESS_TOKEN'
});
```

### Getting the user profile

In order to get the user profile data, use the `getUser()` method, with the `userId` and a callback as parameters. The method returns the user profile. Note that the `userID` required here will be the same one fetched from the `client.userInfo` method.
`auth0Manage.getUser(userId, cb);`

### Updating the user profile

When updating user metadata, you will need to first create a `userMetadata` object, and then call the `patchUserMetadata` method, passing it the user id and the `userMetadata` object you created. The values in this object will overwrite existing values with the same key, or add new ones for those that don't yet exist in the user metadata. For more information, read [Metadata](/docs/manage-users/user-accounts/metadata).
`auth0Manage.patchUserMetadata(userId, userMetadata, cb);`

### Linking users

Linking user accounts will allow a user to authenticate from any of their accounts and no matter which one they use, still pull up the same profile upon login. Auth0 treats all of these accounts as separate profiles by default, so if you wish a user's accounts to be linked, this is the way to go.

The `linkUser` method accepts two parameters, the primary `userId` and the secondary user's ID Token (the token obtained after login with this identity). The user ID in question is the unique identifier for the primary user account. The ID should be passed with the provider prefix, e.g., `auth0|1234567890` or `facebook|1234567890`, when using this method. See [User Account Linking](/docs/manage-users/user-accounts/user-account-linking) for details.
`auth0Manage.linkUser(userId, secondaryUserToken, cb);`

After linking the accounts, the second account will no longer exist as a separate entry in the user database, and will only be accessible as part of the primary one.
When accounts are linked, the secondary account's metadata is not merged with the primary account's metadata, and if they are ever unlinked, the secondary account will likewise not retain the primary account's metadata when it becomes separate again.