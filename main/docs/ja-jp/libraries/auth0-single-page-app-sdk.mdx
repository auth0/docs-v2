---
description: ''
og:description: Auth0 SDK for single page applications using Authorization Code Grant
  Flow with PKCE.
og:image: https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
og:title: Auth0 Single-Page App SDK
og:url: https://auth0.com/docs/
permalink: auth0-single-page-app-sdk
title: Auth0 Single-Page App SDK
twitter:description: Auth0 SDK for single page applications using Authorization Code
  Grant Flow with PKCE.
twitter:title: Auth0 Single-Page App SDK
---

Auth0 Single-Page App SDKは新しいJavaScriptライブラリーで、シングルページアプリ（SPA）でAuth0を使って認証と認可を実装します。高水準のAPIを提供して、大量の詳細情報を処理しているため、作成するコードの量を低減しながら、SPAにベストプラクティスを実装することができます。

The Auth0 SPA SDK handles grant and protocol details, token expiration and renewal, as well as token storage and caching. Under the hood, it implements [Universal Login](/docs/authenticate/login/auth0-universal-login) and the [Authorization Code Grant Flow with PKCE](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).

The [library](https://github.com/auth0/auth0-spa-js) and [API documentation](https://auth0.github.io/auth0-spa-js/) are hosted on GitHub.

If you encounter any problems or errors when using the new JavaScript SDK, please [read the FAQ](https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md) to see if your issue is covered there.

## プロジェクトでAuth0 SPA SDKを使用するには、いくつかのオプションがあります。

CDNから：`<script src=")`」をお読みください。

* From the CDN: `<script src="https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js"></script>`. For more information, read the [FAQ](https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#how-to-use-from-a-cdn).
* With [npm](https://npmjs.org): `npm install @auth0/auth0-spa-js`
* With [yarn](https://yarnpkg.com): `yarn add @auth0/auth0-spa-js`

## クライアントを作成する

### まず、`Auth0Client`クライアントプロジェクトの新しいインスタンスを作成する必要があります。`Auth0Client`インスタンスを作成してから、アプリケーションのレンダリングまたは初期化を行います。これを行うには、async/awaitメソッドまたはpromiseを使用します。クライアントには必ずインスタンスを1つだけ作成します。

`Auth0Client`のインスタンスを作成する。

`getTokenSilently`を呼び出し、ユーザーセッションを更新する。

* `getTokenSilently`からのエラーをすべて抑止する（`login_required`を除く）。
* async/awaitを使用する
* promiseを使用する

#### ユーザーがログアウトするのにクリックするボタンを追加します。

```jsx lines
import { createAuth0Client } from '@auth0/auth0-spa-js';

const auth0 = await createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}'
});
```

#### ログアウト

```jsx lines
createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}'
}).then(auth0 => {
  //...
});
```

SDKを同期的に初期化する

* ログインしてユーザー情報を取得する
* 次に、ユーザーがクリックしてログインを始めるボタンを作成します。
* クリックしてログイン

```jsx lines
import { Auth0Client } from '@auth0/auth0-spa-js';

const auth0 = new Auth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}'
});
```

### 作成したボタンのクリックイベントを待ち合わせます。イベントが発生した際には、適切なログインメソッドを実行してユーザーを認証します（この例では`loginWithRedirect()`）。ユーザーが認証されたら、`getUser()`メソッドでユーザープロファイルを取得できます。

async/awaitを使用する

`<button id="login">Click to Login</button>`

APIを呼び出す

#### ユーザーがログアウトするのにクリックするボタンを追加します。

```jsx lines
document.getElementById('login').addEventListener('click', async () => {
  await auth0.loginWithRedirect({
    authorizationParams: {
      redirect_uri: 'http://localhost:3000/'
    }
  });
  //logged in. you can get the user profile like this:
  const user = await auth0.getUser();
  console.log(user);
});
```

#### ログアウト

```jsx lines
document.getElementById('login').addEventListener('click', () => {
  auth0.loginWithRedirect({
    authorizationParams: {
      redirect_uri: 'http://localhost:3000/'
    }
  }).then(token => {
    //logged in. you can get the user profile like this:
    auth0.getUser().then(user => {
      console.log(user);
    });
  });
});
```

### ログアウト

To call your API, start by getting the user's <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=Access+Token">Access Token</Tooltip>. Then use the Access Token in your request. In this example, the `getTokenSilently` method is used to retrieve the Access Token:

`<button id="callApi">Call an API</button>`

#### ユーザーがログアウトするのにクリックするボタンを追加します。

```jsx lines
document.getElementById('callApi').addEventListener('click', async () => {
  const accessToken = await auth0.getTokenSilently();
  const result = await fetch('https://exampleco.com/api', {
    method: 'GET',
    headers: {
      Authorization: 'Bearer ' + accessToken
    }
  });
  const data = await result.json();
  console.log(data);
});
```

#### ログアウト

```jsx lines
document.getElementById('callApi').addEventListener('click', () => {
  auth0
    .getTokenSilently()
    .then(accessToken =>
      fetch('https://exampleco.com/api', {
        method: 'GET',
        headers: {
          Authorization: 'Bearer ' + accessToken
        }
      })
    )
    .then(result => result.json())
    .then(data => {
      console.log(data);
    });
});
```

### リフレッシュトークンのローテーションを使用する

Auth0 SPA SDKはデフォルトでトークンをメモリーに保管します。ところが、ページの更新やブラウザーのタブでは永続性が途絶えてしまします。代わりに、SDKの初期化時に`cacheLocation`プロパティを`localstorage`に設定することで、トークンをローカルストレージに保存するよう選択できます。これは、Auth0のセッションCookieがアクセストークンを長期保管するのに対して、ブラウザーのプライバシー保護技術がそのアクセスを妨げる弊害を低減するのに役立ちます。

`<button id="logout">Logout</button>`

```jsx lines
$('#logout').click(async () => {
  auth0.logout({
    logoutParams: {
      returnTo: 'http://localhost:3000/'
    }
  });
});
```

### このためには、初期化時に`useRefreshTokens`を`true`に設定してSDKを構成します。

The Auth0 SPA SDK stores tokens in memory by default. However, this does not provide persistence across page refreshes and browser tabs. Instead, you can opt-in to store tokens in local storage by setting the `cacheLocation` property to `localstorage` when initializing the SDK. This can help to mitigate some of the effects of browser privacy technology that prevents access to the Auth0 <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/docs/glossary?term=session+cookie">session cookie</Tooltip> by storing Access Tokens for longer.

<Warning>

Storing tokens in browser local storage provides persistence across page refreshes and browser tabs. However, if an attacker can achieve running JavaScript in the SPA using a cross-site scripting (XSS) attack, they can retrieve the tokens stored in local storage. A vulnerability leading to a successful XSS attack can be either in the SPA source code or in any third-party JavaScript code (such as bootstrap, jQuery, or Google Analytics) included in the SPA.

Read more about [token storage](/docs/secure/tokens/token-best-practices).

</Warning>


```jsx lines
const auth0 = await createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}',
  cacheLocation: 'localstorage'
});
```

### 構成を終えると、SDKは認可ステップ中に`offline_access`スコープを要求します。さらに、`getTokenSilently`は`/oauth/token`エンドポイントを呼び出し、フレッシュトークンをアクセストークンに直接交換します。SDKはリフレッシュトークンの保管について、ストレージ設定に従います。SDKがデフォルトのメモリー内ストレージに構成されている場合、リフレッシュトークンはページが更新されると失われます。

The Auth0 SPA SDK can be configured to use [rotating Refresh Tokens](/docs/secure/tokens/refresh-tokens/refresh-token-rotation) to get new access tokens silently. These can be used to bypass browser privacy technology that prevents access to the Auth0 session cookie when authenticating silently, as well as providing built-in reuse detection.

以下は、SDKでさまざまなメソッドを使った例です。3つの例でjQueryが使用されていることに注意してください。


```jsx lines
const auth0 = await createAuth0Client({
  domain: '{yourDomain}',
  clientId: '{yourClientId}',
  useRefreshTokens: true
});

// Request a new access token using a refresh token
const token = await auth0.getTokenSilently();
```

<Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Tokens">Refresh Tokens</Tooltip> will also need to be [configured for your tenant](/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation) before they can be used in your SPA.

Auth0で`/authorize`エンドポイントにリダイレクトし、[ユニバーサルログイン](/universal-login)フローを開始します。
ポップアップでログインする

## ユニバーサルログインのページでポップアップ画面を使用してログインします。

ユーザーが認証フローを完了するのに、デフォルトの60秒のタイムアウトよりも長くかかった場合には、認証が中断されます。この際には、コードでエラーをキャッチして、以下のいずれかを行う必要があります。

### 再試行し、`error.popup.close`を使ってポップアップを手動で閉じることをユーザーに求めます。

Redirect to the `/authorize` endpoint at Auth0, starting the [Universal Login](/docs/authenticate/login/auth0-universal-login) flow:

```jsx lines
$('#loginRedirect').click(async () => {
  await auth0.loginWithRedirect({
    authorizationParams: {
      redirect_uri: 'http://localhost:3000/'
    }
  });
});
```

### リダイレクトのコールバックでログインする

Use a popup window to log in using the <Tooltip tip="Universal Login: Your application redirects to Universal Login, hosted on Auth0's Authorization Server, to verify a user's identity." cta="View Glossary" href="/docs/glossary?term=Universal+Login">Universal Login</Tooltip> page:

```jsx lines
$('#loginPopup').click(async () => {
  await auth0.loginWithPopup();
});
```

ユーザーの関与なくアクセストークンを取得する

非表示のiframe と`prompt=none`を使用するか、またはリフレッシュトークンをローテーションさせることで、サイレントモードで新しいアクセストークンを取得します。リフレッシュトークンは、SDKの構成時に`useRefreshTokens`が`true`に設定されている場合に使用されます。

```jsx lines
$('#loginPopup').click(async () => {
  try {
    await auth0.loginWithPopup();
  } catch {error}
  if (error instanceof auth0.PopupTimeoutError) {
    // custom logic to inform user to retry
    error.popup.close();
  }
});
```

メモリー内ストレージ（デフォルト）の設定でリフレッシュトークンが使用されると、新しいトークンは対応しているブラウザーのウェブワーカー（Web Worker）を使って取得されます。

```jsx lines
$('#loginPopup').click(async () => {
  const popup = window.open(
    '',
    'auth0:authorize:popup',
    'left=100,top=100,width=400,height=600,resizable'
  );
  try {
    await auth0.loginWithPopup({ popup });
  } catch {error}
  if (error instanceof auth0.PopupTimeoutError) {
    // custom logic to inform user to retry
    error.popup.close();
  }
});
```

### ポップアップでアクセストークンを取得する

アクセストークンはポップアップでも取得することができます。`getTokenSilently`とは違って、サードパーティのCookieがデフォルトで阻止されているブラウザーでも動作します。

```jsx lines
$('#loginRedirectCallback').click(async () => {
  await auth0.handleRedirectCallback();
});
```

### 異なるオーディエンスにアクセストークンを取得する

オプションは、ユーザー認証時に要求された、異なるオーディエンスとそのスコープを持つアクセストークンを取得する`getTokenSilently`に渡すこともできます。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Getting an Access Token silently without using Refresh Tokens will not work in browsers that block third-party cookies, such as Safari and Brave. To learn more about the custom domain workaround, read [Troubleshoot Renew Tokens When Using Safari](/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).

</Callout>

ユーザーを取得する

```jsx lines
$('#getToken').click(async () => {
  const token = await auth0.getTokenSilently();
});
```

The `getTokenSilently()` method requires you to have **Allow Skipping User Consent** enabled in your [API Settings in the Dashboard](https://manage.auth0.com/#/apis). Additionally, user consent [cannot be skipped on 'localhost'](/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications).

### IDトークンのクレームを取得する

認証されたユーザーのIDトークンにあるクレームを取得するには、`getIdTokenClaims`メソッドを呼び出します。

```jsx lines
$('#getTokenPopup').click(async () => {
  const token = await auth0.getTokenWithPopup({
    authorizationParams: {
      audience: 'https://mydomain/api/',
      scope: 'read:rules'
    }
  });
});
```

### ログアウト（デフォルト）

Options may be passed to `getTokenSilently` that get an Access Token with a different <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> and scope of that which was requested at user authentication time.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

This only works when not using Refresh Tokens (`useRefreshTokens: false`), as a Refresh Token is bound to the particular audience and scope that was requested at user authentication time.

</Callout>

```jsx lines
$('#getToken_audience').click(async () => {
  const differentAudienceOptions = {
    authorizationParams: {
      audience: 'https://mydomain/another-api/',
      scope: 'read:rules',
      redirect_uri: 'http://localhost:3000/callback.html'
    }
  };
  const token = await auth0.getTokenSilently(differentAudienceOptions);
});
```

### クライアントIDなしでログアウトする

クライアントIDが指定されていないログアウトのアクションを開始するには、`logout`メソッドを呼び出し、`clientId: null`を含めます。

```jsx lines
$('#getUser').click(async () => {
  const user = await auth0.getUser();
});
```

### Get ID Token claims

You can get the claims of the authenticated user's <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+Token">ID Token</Tooltip> by calling the `getIdTokenClaims` method:

```jsx lines
$('#getIdTokenClaims').click(async () => {
  const claims = await auth0.getIdTokenClaims();
  // if you need the raw id_token, you can access it
  // using the __raw property
  const id_token = claims.__raw;
});
```

### リフレッシュトークンのローテーションを使用する (default)

You can initiate a logout action by calling the `logout` method:

```jsx lines
$('#logout').click(async () => {
  auth0.logout({
    logoutParams: {
      returnTo: 'http://localhost:3000/'
    }
  });
});
```

### リフレッシュトークンのローテーションを使用する with no client ID

You can initiate a logout action with no <Tooltip tip="Client ID: Identification value given to your registered resource from Auth0." cta="View Glossary" href="/docs/glossary?term=Client+ID">Client ID</Tooltip> specified by calling the `logout` method and including `clientId: null`:

```jsx lines
$('#logoutNoClientId').click(async () => {
  auth0.logout({
    clientId: null,
    logoutParams: {
      returnTo: 'http://localhost:3000/'
    }
  });
});
```

## Learn more

* [Validate Access Tokens](/docs/secure/tokens/access-tokens/validate-access-tokens)