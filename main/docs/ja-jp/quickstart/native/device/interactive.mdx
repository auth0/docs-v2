---
title: "デバイス認可フロー"
permalink: "interactive"
'description': "このチュートリアルでは、デバイス認可フローを使用して、入力に制約のあるデバイスからAPIを呼び出す方法について説明します。"
'og:title': "デバイス認可フロー"
'og:description': "このチュートリアルでは、デバイス認可フローを使用して、入力に制約のあるデバイスからAPIを呼び出す方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/media/platforms/device.svg"
'twitter:title': "デバイス認可フロー"
'twitter:description': "このチュートリアルでは、デバイス認可フローを使用して、入力に制約のあるデバイスからAPIを呼び出す方法について説明します。"
---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/recipe.jsx";
import { LoggedInForm } from "/snippets/Login.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

export const sections = [
  { id: "前提条件", title: "前提条件" },
  { id: "デバイスコードを要求する", title: "デバイスコードを要求する" },
  { id: "デバイスコードを受け取る", title: "デバイスコードを受け取る" },
  { id: "デバイスのアクティベーションを要求する", title: "デバイスのアクティベーションを要求する" },
  { id: "トークンエンドポイントをポーリングする", title: "トークンエンドポイントをポーリングする" },
  { id: "ユーザーの認可", title: "ユーザーの認可" },
  { id: "トークンを受け取る", title: "トークンを受け取る" },
  { id: "apiを呼び出す", title: "APIを呼び出す" },
  { id: "リフレッシュトークン", title: "リフレッシュトークン" },
  { id: "トラブルシューティング", title: "トラブルシューティング" },
  { id: "実装例", title: "実装例" },
  { id: "制限事項", title: "制限事項" }
]

<Recipe>
  <Content>
    このチュートリアルでは、デバイス認可フローを使用して、入力に制約のあるデバイスからAPIを呼び出す方法について説明します。 ログインして、アカウント用に構成された例を参考にこのクイックタートに従うことをお勧めします。対話型のエクスペリエンスには、Device Flow Playgroundを使用することができます。

      <Section id={sections[0].id} title={sections[0].title} stepNumber="1">
      - ネイティブアプリケーションを登録する。
      - **OIDC準拠** のトグルが有効になっていることを確認する。詳細については、「OIDC準拠の認証」をお読みください。
      - アプリケーションの付与タイプに**デバイスコード** を追加する。詳細については、「付与タイプを更新する」をお読みください。
      - リフレッシュトークンを有効にしたい場合には、アプリケーションの付与タイプに**リフレッシュトークン** を追加する。
      - アプリケーションに少なくとも1つの接続を構成して有効化する。
      - APIをAuth0に登録する。

        - リフレッシュトークンを使用している場合には、**［Allow Offline Access（オフラインアクセスの許可）］** を有効にする。詳細については、「APIの設定」をお読みください。
      - デバイスのユーザーコードの設定を構成して、ランダムに生成されたユーザーコードの文字セット、形式、長さを定義する。
      </Section>

      <Section id={sections[1].id} title={sections[1].title} stepNumber="2">
      ユーザーがデバイスアプリケーションを起動して、それを認可したい場合には、アプリケーションがAuth0 Authentication APIからのデバイスコードを要求して、ユーザーのセッションに関連付けなければなりません。

      デバイスコードを取得するには、アプリケーションがAuthentication APIのデバイス認可フローで[認証エンドポイント](https://auth0.com/docs/api/authentication#-post-oauth-device-code-)を呼び出す必要があります：

      <AuthCodeGroup>
      ```bash cURL lines
      curl --request post \
        --url 'https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code' \
        --header 'content-type: application/x-www-form-urlencoded'
      ```
      ```csharp C# lines
      var client = new RestClient("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code");
      var request = new RestRequest(Method.POST);
      request.AddHeader("content-type", "application/x-www-form-urlencoded");
      IRestResponse response = client.Execute(request);
      ```

      ```go Go lines 
      package main
      import (
      "fmt"
      "net/http"
      "io/ioutil"
      )
      func main() {
      url := "https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code"
      req, _ := http.NewRequest("post", url, nil)
      req.Header.Add("content-type", "application/x-www-form-urlencoded")
      res, _ := http.DefaultClient.Do(req)
      defer res.Body.Close()
      body, _ := ioutil.ReadAll(res.Body)
      fmt.Println(res)
      fmt.Println(string(body))
      }
      ```
      ```java Java lines
      HttpResponse<String> response = Unirest.post("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code")
        .header("content-type", "application/x-www-form-urlencoded")
        .asString();
      ```
      ```javascript Node.JS lines
      var axios = require("axios").default;
      var options = {
      method: 'post',
      url: 'https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code',
      headers: {'content-type': 'application/x-www-form-urlencoded'}
      };
      axios.request(options).then(function (response) {
      console.log(response.data);
      }).catch(function (error) {
      console.error(error);
      });
      ```
      ```obj-c Obj-C lines 
      #import <Foundation/Foundation.h>
      NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };
      NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

      [request setHTTPMethod:@"post"];
      [request setAllHTTPHeaderFields:headers];
      NSURLSession *session = [NSURLSession sharedSession];
      NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                  if (error) {

                                                      NSLog(@&quot;%@&quot;, error);

                                                  } else {

                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                      NSLog(@&quot;%@&quot;, httpResponse);

                                                  }

                                              }];

      [dataTask resume];
      ```
      ```php PHP lines 
      $curl = curl_init();
      curl_setopt_array($curl, [
      CURLOPT_URL => "https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code",
      CURLOPT_RETURNTRANSFER => true,
      CURLOPT_ENCODING => "",
      CURLOPT_MAXREDIRS => 10,
      CURLOPT_TIMEOUT => 30,
      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
      CURLOPT_CUSTOMREQUEST => "post",
      CURLOPT_HTTPHEADER => [
      &quot;content-type: application/x-www-form-urlencoded&quot;

      ],
      ]);
      $response = curl_exec($curl);
      $err = curl_error($curl);
      curl_close($curl);
      if ($err) {
      echo "cURL Error #:" . $err;
      } else {
      echo $response;
      }
      ```
      ```python Python lines
      import http.client
      conn = http.client.HTTPSConnection("")
      headers = { 'content-type': "application/x-www-form-urlencoded" }
      conn.request("post", "/dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code", headers=headers)
      res = conn.getresponse()
      data = res.read()
      print(data.decode("utf-8"))
      ```
      ```ruby Ruby lines
      require 'uri'
      require 'net/http'
      require 'openssl'
      url = URI("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code")
      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      request = Net::HTTP::Post.new(url)
      request["content-type"] = 'application/x-www-form-urlencoded'
      response = http.request(request)
      puts response.read_body
      ```
      ```swift Swift lines 
      import Foundation
      let headers = ["content-type": "application/x-www-form-urlencoded"]
      let request = NSMutableURLRequest(url: NSURL(string: "https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/device/code")! as URL,
                                          cachePolicy: .useProtocolCachePolicy,

                                      timeoutInterval: 10.0)

      request.httpMethod = "post"
      request.allHTTPHeaderFields = headers
      let session = URLSession.shared
      let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
      if (error != nil) {
      print(error)

      } else {
      let httpResponse = response as? HTTPURLResponse

      print(httpResponse)

      }
      })
      dataTask.resume()
      ```
      </AuthCodeGroup>

      </Section>

      <Section id={sections[2].id} title={sections[2].title} stepNumber="3">
      デバイスアプリケーションはHTTP 200応答と次のようなペイロードを受け取るはずです：

      ```
      {
      "device_code": "GmRh...k9eS",
      "user_code": "WDJB-MJHT",
      "verification_uri": "https://my-tenant.auth0.com/device",
      "verification_uri_complete": "https://my-tenant.auth0.com/device?user_code=WDJB-MJHT",
      "expires_in": 900,
      "interval": 5
      }
      ```
      </Section>

      <Section id={sections[3].id} title={sections[3].title} stepNumber="4">
      デバイスアプリケーションは、`device_code`と`user_code`の受信後に、ユーザーに`verification_uri`で`user_code`を入力するよう指示する必要があります。

      <Frame>![](/docs/images/ja-jp/cdy7uua7fh8z/3Q9q41wocl6SojRoiGefXT/a98582a3c86740aaeb3d957f2dc4afe6/request-device-activation.png)</Frame>

      <Info>
      `device_code`はユーザーに直接提供するものではないため、ユーザーが混乱しないように、処理中に表示するべきではありません。
      </Info>

      <Info>
      CLIをビルドする際は、この手順をスキップし、`verification_uri_complete`を使って直接ブラウザーを開くことができます。
      </Info>
      </Section>

      <Section id={sections[4].id} title={sections[4].title} stepNumber="5">
      ユーザーによるアクティベーションを待っている間、デバイスアプリケーションはAuthentication API [POST /oauth/tokenエンドポイント](https://auth0.com/docs/api/authentication#-post-oauth-token-)を断続的に呼び出して、応答を適切に処理する必要があります。

      <Info>
      デバイスアプリケーションが確実にその`interval`（秒単位）または成功応答の受信で長い方の時間を待機して、ネットワーク遅延の問題を回避するようにします。
      </Info>

      ```
      curl --request POST \
      --url 'https://{yourDomain}/oauth/token' \
      --header 'content-type: application/x-www-form-urlencoded' \
      --data grant_type=urn:ietf:params:oauth:grant-type:device_code \
      --data device_code=AUTH0_SCOPES \
      --data 'client_id={yourClientId}'
      ```
      </Section>

      <Section id={sections[5].id} title={sections[5].title} stepNumber="6">
      ユーザーはQRコードをスキャンするか、アクティベーションページを開いてユーザーコードを入力します：

      <Frame>![](/docs/images/ja-jp/cdy7uua7fh8z/7IwrVX4s5a36CvfY95rKCo/1f0734161a6e1fb6acbefb674896bf74/Device_Activation_-_Japanese.png)</Frame>

      確認ページが表示され、ユーザーが正しいデバイスであることを確認します：

      <Frame>![](/docs/images/ja-jp/cdy7uua7fh8z/5dwhOyM1HRNwfV3Co4Da2o/41706a37843a99b6c21117d4aebcd881/Device_Confirmation_-_Japanese.png)</Frame>

      ユーザーがサインインして、トランザクションが完了します。この手順には、以下の1つ以上のプロセスが含まれます。

      - ユーザーを認証する
      - 認証を行うために、ユーザーをIDプロバイダーへリダイレクトする
      - アクティブなSSOセッションを確認する
      - デバイスに関してユーザーの同意がまだ得られていない場合には、同意を得る

      <Frame>![](/docs/images/ja-jp/cdy7uua7fh8z/3GqqaNB7sjcAYTQiTnEEsn/26ff7d214f4f02f4a703941908045cd1/Login_screen_-_Japanese.png)</Frame>

      認証と同意が成功すると、確認のプロンプトが表示されます：

      <Frame>![](/docs/images/ja-jp/cdy7uua7fh8z/2TsQpMa8fzifiojuEXLvDo/2e19d86a58bb4af653307f3086911d87/Success_message_-_Japanese.png)</Frame>

      この時点で、ユーザーの認証とデバイスの認可は完了しています。
      </Section>

      <Section id={sections[6].id} title={sections[6].title} stepNumber="7">
      ユーザーがデバイスアプリケーションを認可すると、HTTP 200応答と次のペイロードを受け取ります：

      ```
      {
      "access_token": "eyJz93a...k4laUWw",
      "refresh_token": "GEbRxBN...edjnXbL",
      "id_token": "eyJ0XAi...4faeEoQ",
      "token_type": "Bearer",
      "expires_in": 86400
      }
      ```

      <Info>
      トークンは検証してから保存します。方法については、「**アクセストークンを検証する** 」と「**IDトークンを検証する** 」をお読みください。
      </Info>

      アクセストークンは、Authentication APIの[ユーザー情報取得エンドポイント](https://auth0.com/docs/api/authentication#get-user-info)（デバイスアプリケーションが`openid`スコープを要求した場合）、または`audience`パラメーターが指定したAPIを呼び出すために使用されます。独自のAPIを呼び出す場合には、デバイスアプリケーションは使用する前にアクセストークンを検証しなければなりません。

      IDトークンには、[デコードと抽出](/docs/ja-jp/tokens/id-tokens#id-token-payload)が必要なユーザー情報が含まれています。デバイスアプリケーションが`openid`スコープを要求した場合には、Authentication APIは`id_token`のみを返します。

      リフレッシュトークンは、アクセストークンまたはIDトークンの期限が切れたときに、新しいトークンの取得に使用されます。`audience`パラメーターが指定するAPIに**［Allow Offline Access（オフラインアクセスの許可）］** 設定が有効化されていて、デバイスアプリケーションが`offline_access`スコープを要求した場合には、Authentication APIは`refresh_token`のみを返します。
      </Section>

      <Section id={sections[7].id} title={sections[7].title} stepNumber="8">
      APIを呼び出すには、デバイスアプリケーションはアクセストークンをベアラートークンとしてHTTP要求の`Authorization`ヘッダーで渡さなければなりません。

      ```
      curl --request GET \
      --url https://myapi.com/api \
      --header 'authorization: Bearer AUTH0_API_ACCESS_TOKEN' \
      --header 'content-type: application/json'
      ```
      </Section>

      <Section id={sections[8].id} title={sections[8].title} stepNumber="9">
      ユーザーに新しいアクセストークンを取得するために、デバイスアプリケーションは、`refresh_token`パラメーターを指定してAuthentication API [POST /oauth/tokenエンドポイント](https://auth0.com/docs/api/authentication#-post-oauth-token-)を呼び出すことができます。

      ```
      curl --request POST \
      --url 'https://{yourDomain}/oauth/token' \
      --header 'content-type: application/x-www-form-urlencoded' \
      --data grant_type=refresh_token \
      --data 'client_id={yourClientId}' \
      --data 'client_secret={yourClientSecret}' \
      --data refresh_token=AUTH0_REFRESH_TOKEN
      ```

      要求が成功すると、デバイスアプリケーションはHTTP 200応答で次のペイロードを受け取ります：

      ```
      {
      "access_token": "eyJ...MoQ",
      "expires_in": 86400,
      "scope": "openid offline_access",
      "id_token": "eyJ...0NE",
      "token_type": "Bearer"
      }
      ```

      リフレッシュトークンの詳細については、「[リフレッシュトークン](/docs/ja-jp/secure/tokens/refresh-tokens)」をお読みください。
      </Section>

      <Section id={sections[9].id} title={sections[9].title} stepNumber="10">
      テナントログは実行されるあらゆるやり取りを記録し、問題の解決に利用することができます。

      | \*\*コード\*\* | \*\*名前\*\* | \*\*説明\*\* |
      | --- | --- | --- |
      | `fdeaz` | デバイス認可要求の失敗 |  |
      | `fdeac` | デバイスのアクティベーションに失敗 |  |
      | `fdecc` | ユーザーがデバイス確認をキャンセル |  |
      | `fede` | 交換の失敗 | アクセストークンのデバイスコード |
      | `sede` | 交換の成功 | アクセストークンのデバイスコード |

      ### トークンの応答

      ユーザーによるデバイスの認可を待っている間には、さまざまなHTTP 4xx応答を受け取ります。

      #### 認可待ち

      このエラーは、ユーザーの操作を待っている間に表示されます。このチュートリアルの前の手順で推奨されている`interval`を使ってポーリングを継続してください。

      ```
      `HTTP 403`
      {
      "error": "authorization_pending",
      "error_description": "..."
      }
      ```

      #### 減速

      ポーリングが速すぎます。このチュートリアルの前の手順で推奨されている間隔を使ってポーリングしてください。ネットワーク遅延が原因でこのエラーを受け取ることを避けるには、ポーリング要求の応答を受け取ってから間隔をカウントし始めるようにします。

      ```
      `HTTP 429`
      {
      "error": "slow_down",
      "error_description": "..."
      }
      ```

      #### 有効期限切れのトークン

      ユーザーによるデバイスの認可が遅かったため、`device_code`の期限が切れました。アプリケーションはユーザーにフローの失効を通知して、フローをもう一度始めるように促す必要があります。

      <Info>
      `expired_token`エラーは一度だけ返されます。それ以降は、エンドポイントが`invalid_grant`エラーを返します。
      </Info>

      ```
      `HTTP 403`
      {
      "error": "expired_token",
      "error_description": "..."
      }
      ```

      #### アクセス拒否

      アクセスが拒否された場合には、次を受け取ります：

      ```
      `HTTP 403`
      {
      "error": "access_denied",
      "error_description": "..."
      }
      ```

      これは、以下を含むさまざまな原因で発生します。

      - ユーザーがデバイスの認可を拒否した。
      - 認可サーバーがトランザクションを拒否した。
      - 構成済みのアクションがアクセスを拒否した。
      </Section>

      <Section id={sections[10].id} title={sections[10].title} stepNumber="11">
      以下の例を参考に、このフローを実際のアプリケーションに実装する方法を確認してください。

      - [Device Authorization Playground](https://auth0.github.io/device-flow-playground/)
      - [AppleTV（Swift）](https://github.com/pushpabrol/auth0-device-flow-appletv)：AppleTVからのデバイス認可フローにAuth0を使用する方法を示す簡素なアプリケーションです。
      - [CLI（Node.js）](https://gist.github.com/panva/652c61e7d847e0ed99926c324fa91b36)：認可コードフローではなく、デバイス認可フローを使用するCLIの実装例です。大きな違いは、CLIがWebサーバーのホスティングやポートの待ち受けを必要としないことです。
      </Section>

      <Section id={sections[11].id} title={sections[11].title} stepNumber="12">
      デバイス認可フローを使用するには、デバイスアプリケーションに以下が必要です。

      - Server Name Indication（SNI）に対応している
      - ネイティブアプリケーション
      - [認証方法](/docs/ja-jp/secure/application-credentials#application-authentication-methods)が**［None（なし）］** に設定されている
      - [OIDCに準拠](/docs/ja-jp/dashboard/reference/settings-application#oauth)
      - 動的クライアント登録（Dynamic Client Registration）

      また、デバイス認可フローには以下を使用できません：

      - Auth0の開発者キーを使用したソーシャル接続（新しいユニバーサルログインエクスペリエンス
      - ホストされたログインページやアクションからクエリ文字列パラメーターへのアクセス
      </Section>

    ## 次のステップ
    成功です！ここまで来れば、アプリケーションにログイン、ログアウト、ユーザープロファイル情報が備わっているはずです。

    これでクイックスタートチュートリアルは終了ですが、機能はまだまだたくさんあります。Auth0でできることについて詳しくは、以下をご覧ください。

    - [Auth0 Dashboard](https://manage.auth0.com/#) - Auth0のテナントやアプリケーションを構成して管理する方法について説明します

    - [Auth0 Marketplace](https://marketplace.auth0.com/) - Auth0の機能性を拡張できる各種の統合を見つけられます
  </Content>

  <SideMenu sections={sections}>
      <SideMenuSectionItem id={sections[0].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[1].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[2].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[3].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[4].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[5].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[6].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[7].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[8].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[9].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[10].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[11].id}>
        <SignUpForm />
      </SideMenuSectionItem>

    </SideMenu>
</Recipe>
