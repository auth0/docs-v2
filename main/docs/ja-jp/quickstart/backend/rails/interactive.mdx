---
title: "Ruby on Rails APIに認可を追加する"
permalink: "interactive"
'description': "このチュートリアルでは、カスタムAuth0Clientクラス内のjwt Gemを使って、アクセストークンの検証を実施します。"
'og:title': "Ruby on Rails APIに認可を追加する"
'og:description': "このチュートリアルでは、カスタムAuth0Clientクラス内のjwt Gemを使って、アクセストークンの検証を実施します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/media/platforms/rails.png"
'twitter:title': "Ruby on Rails APIに認可を追加する"
'twitter:description': "このチュートリアルでは、カスタムAuth0Clientクラス内のjwt Gemを使って、アクセストークンの検証を実施します。"
sidebarTitle: Ruby on Rails API
---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/recipe.jsx";
import { LoggedInForm } from "/snippets/Login.jsx";
import ApplicationController from "/snippets/quickstart/backend/rails/application_controller.rb.mdx";
import Auth0Client from "/snippets/quickstart/backend/rails/auth0_client.rb.mdx";
import Secured from "/snippets/quickstart/backend/rails/secured.rb.mdx";
import PublicController from "/snippets/quickstart/backend/rails/public_controller.rb.mdx";
import PrivateController from "/snippets/quickstart/backend/rails/private_controller.rb.mdx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

export const sections = [
  { id: "アクセス許可を定義する", title: "アクセス許可を定義する" },
  { id: "依存関係をインストールする", title: "依存関係をインストールする" },
  { id: "auth0clientクラスを作成する", title: "Auth0Clientクラスを作成する" },
  { id: "secured-concernを定義する", title: "Secured concernを定義する" },
  { id: "applicationcontrollerにsecure-concernを含める", title: "ApplicationControllerにSecure concernを含める" },
  { id: "パブリックエンドポイントを作成する", title: "パブリックエンドポイントを作成する" },
  { id: "プライベートエンドポイントを作成する", title: "プライベートエンドポイントを作成する" }
]

<Recipe>
  <Content>
    このチュートリアルでは、カスタム`Auth0Client`クラス内の[**jwt** ](https://github.com/jwt/ruby-jwt) Gemを使って、アクセストークンの検証を実施します。`Secured`と呼ばれるConcernを使って、受信アクセストークンからの認証を必要とするエンドポイントを認可します。

    Auth0 DashboardでAPIをまだ作成していない場合は、対話型のセレクターを使ってAuth0 APIを新規作成します。そうでない場合は、プロジェクトに既存のAPIを選択します。

    Auth0 Dashboardを使って初めてAPIをセットアップする場合には、[使用の開始ガイド](/docs/ja-jp/get-started/auth0-overview/set-up-apis)を確認してください。

    それぞれのAuth0 APIにはAPI識別子があり、アプリケーションにアクセストークンの検証で使用されます。

    <Info>
    **Auth0を初めてご利用ですか？** [Auth0の仕組み](/docs/ja-jp/overview)と、OAuth 2.0フレームワークを用いた[API認証と認可の実装](/docs/ja-jp/api-auth)について説明します。
    </Info>

      <Section id={sections[0].id} title={sections[0].title} stepNumber="1">
      アクセス許可は、ユーザーの代わりに、提供されたアクセストークンを使ってどのようにしてリソースにアクセスできるのかを定義できるようにします。たとえば、ユーザーがマネージャーアクセスレベルを持つ場合には、`messages`リソースに対して読み出しアクセスを付与し、管理者アクセスレベルを持つ場合には、書き込みアクセスを付与することができます。

      Auth0 Dashboardの[［APIs］](https://manage.auth0.com/#/apis)セクションにある**［Permissions（権限）］** ビューで使用可能なアクセス許可を定義することができます。

      <Frame>![［Auth0 Dashboard］>［Applications（アプリケーション）］>［APIs］>［Specific API（特定のAPI］>［Permissions（権限）］タブ](/docs/images/ja-jp/cdy7uua7fh8z/1s3Yp5zqJiKiSWqbPSezNO/acef814282795bef6921535f044f96e9/Quickstarts_API.png)</Frame>

      <Info>
      以下の例では`read:messages`スコープを使用します。
      </Info>
      </Section>

      <Section id={sections[1].id} title={sections[1].title} stepNumber="2">
      **jwt** Gemをインストールします。

      ```
      gem 'jwt'
      bundle install
      ```
      </Section>

      <Section id={sections[2].id} title={sections[2].title} stepNumber="3">
      `Auth0Client`と呼ばれるクラスを作成します。このクラスは要求の`Authorization`ヘッダーから得た受信アクセストークンをデコードし検証します。

      `Auth0Client`クラスはAuth0テナントの公開鍵を取得し、これを使ってアクセストークンの署名を検証します。`Token`構造体は`validate_permissions`メソッドを定義し、必要なスコープの配列を指定してアクセストークン内の特定の`scope`を検索し、トークンのペイロードに存在するかを確認します。
      </Section>

      <Section id={sections[3].id} title={sections[3].title} stepNumber="4">
      受信要求の`Authorization`ヘッダー内でアクセストークンを検索する`Secured`と呼ばれるConcernを作成します。

      トークンが存在する場合、`Auth0Client.validate_token`は`jwt` Gemを使用してトークンの署名を確認し、トークンのクレームを検証します。

      Concernには、アクセストークンが有効であることを検証するほか、トークンに要求されたリソースにアクセスするのに十分な**スコープ** があることを確認するためのメカニズムも整備されています。この例では、`Auth0Client`クラスから`Token.validate_permissions`メソッドを呼び出すことで、ブロックを受け取りアクセス許可を確認する`validate_permissions`メソッドを定義します。

      `/private-scoped`ルートでは、定義されたスコープはペイロードに入ってくるスコープと交差され、別の配列から1つ以上の項目が含まれているかを判定します。
      </Section>

      <Section id={sections[4].id} title={sections[4].title} stepNumber="5">
      アプリケーションコントローラーに`Secure` concernを追加すると、認可を必要とするコントローラーで`before_action`フィルターのみを使用すればよいことになります。
      </Section>

      <Section id={sections[5].id} title={sections[5].title} stepNumber="6">
      パブリックエンドポイント`/api/public`を処理するようにコントローラーを作成します。

      `/public`エンドポイントでは認可は必要でないため、`before_action`は必要ありません。
      </Section>

      <Section id={sections[6].id} title={sections[6].title} stepNumber="7">
      `/api/private`と`/api/private-scoped`というプライベートエンドポイントを処理するようにコントローラーを作成します。

      `/api/private`は、追加スコープのないアクセストークンを含む認証された要求に使用することができます。

      `/api/private-scoped`は、`read:messages`スコープが付与されたアクセストークンを含む認証された要求に使用することができます。

      保護されたエンドポイントは`Secured` concernから`authorize`メソッドを呼び出す必要があります。そのためには、`before_action :authorize`を使用します。これによって、`Secured.authorize`メソッドが`PrivateController`の各アクションの前に呼び出されます。

      ### APIを呼び出す

      APIを呼び出すにはアクセストークンが必要です。テスト用のアクセストークンは、[API設定](https://manage.auth0.com/#/apis)の**［Test（テスト）］** ビューから取得することができます。

      <Frame>![［Auth0 Dashboard］>［Applications（アプリケーション）］>［API］>［Specific API（特定のAPI］>［Test（テスト）］タブ](/docs/images/ja-jp/cdy7uua7fh8z/6jeVBuypOGX5qMRXeJn5ow/dd20eb74e1e9079287762ce33dcf8e2d/Quickstart_Example_App_API.png)</Frame>

      要求の`Authorization`ヘッダーにアクセストークンを指定します。

      <AuthCodeGroup>
        ```bash cURL lines
        curl --request get \
        --url 'http:///%7ByourDomain%7D/api_path' \
        --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'
        ```

        ```csharp C# lines
        var client = new RestClient("http:///%7ByourDomain%7D/api_path");
        var request = new RestRequest(Method.GET);
        request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "http:///%7ByourDomain%7D/api_path"
        req, _ := http.NewRequest("get", url, nil)
        req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.get("http:///%7ByourDomain%7D/api_path")
        .header("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'get',
        url: 'http:///%7ByourDomain%7D/api_path',
        headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```obj-c Obj-C lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_ACCESS_TOKEN_HERE" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_ACCESS_TOKEN_HERE" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPConnection("")
        headers = { 'authorization': "Bearer YOUR_ACCESS_TOKEN_HERE" }
        conn.request("get", "/%7ByourDomain%7D/api_path", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        url = URI("http:///%7ByourDomain%7D/api_path")
        http = Net::HTTP.new(url.host, url.port)
        request = Net::HTTP::Get.new(url)
        request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines
        import Foundation
        let headers = ["authorization": "Bearer YOUR_ACCESS_TOKEN_HERE"]
        let request = NSMutableURLRequest(url: NSURL(string: "http:///%7ByourDomain%7D/api_path")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "get"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
        </AuthCodeGroup>


      <Note>
      ##### チェックポイント
      アプリケーションの構成が完了したら、アプリケーションを実行して次の点を確認します：
      GET /api/publicが認証を必要としない要求に使用できる。
      GET /api/privateが認証された要求に使用できる。
      GET /api/private-scopedがread:messagesスコープが付与されたアクセストークンを含む認証された要求に使用できる。
      </Note>
      </Section>

    ## 次のステップ

    成功です！ここまで来れば、アプリケーションにログイン、ログアウト、ユーザープロファイル情報が備わっているはずです。

    これでクイックスタートチュートリアルは終了ですが、機能はまだまだたくさんあります。Auth0でできることについて詳しくは、以下をご覧ください。

    *   [Auth0 Dashboard](https://manage.auth0.com/#) - Auth0のテナントやアプリケーションを構成して管理する方法について説明します
    *   [omniauth-auth0 SDK](https://github.com/auth0/omniauth-auth0) - このチュートリアルで使用されているSDKをより詳しく説明します
    *   [Auth0 Marketplace](https://marketplace.auth0.com/) - Auth0の機能性を拡張できる各種の統合を見つけられます
  </Content>

  <SideMenu sections={sections}>
      <SideMenuSectionItem id={sections[0].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[1].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[2].id}>
        <AuthCodeGroup>
          <Secured/>
          <ApplicationController/>
          <Auth0Client/>
          <PublicController/>
          <PrivateController/>
        </AuthCodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[3].id}>
        <AuthCodeGroup>
          <Secured/>
          <ApplicationController/>
          <Auth0Client/>
          <PublicController/>
          <PrivateController/>
        </AuthCodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[4].id}>
        <AuthCodeGroup>
          <ApplicationController/>
          <Auth0Client/>
          <Secured/>
          <PublicController/>
          <PrivateController/>
        </AuthCodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[5].id}>
        <AuthCodeGroup>
          <PublicController/>
          <ApplicationController/>
          <Auth0Client/>
          <Secured/>
          <PrivateController/>
        </AuthCodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[6].id}>
        <AuthCodeGroup>
          <PrivateController/>
          <ApplicationController/>
          <Auth0Client/>
          <Secured/>
          <PublicController/>
        </AuthCodeGroup>
      </SideMenuSectionItem>

    </SideMenu>
</Recipe>
