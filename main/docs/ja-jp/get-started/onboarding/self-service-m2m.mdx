---
title: "セルフサービスマシンツーマシン"
permalink: "self-service-m2m"
'description': "M2Mビジネスケースをオンボーディングする方法について説明します。"
'og:title': "セルフサービスマシンツーマシン"
'og:description': "M2Mビジネスケースをオンボーディングする方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "セルフサービスマシンツーマシン"
'twitter:description': "M2Mビジネスケースをオンボーディングする方法について説明します。"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

ビジネスケースがAPIやバックエンドサーバーなどの非インタラクティブなオーディエンスにサービスを提供する場合は、マシンツーマシン（M2M）構成でオンボードします。

## ユースケース

次の場合は、M2Mオンボーディングパスを使用します。

* サービスツーサービス通信をサポートする
* 保護されたリソースまたはAPIにアクセスする必要があるサーバー上でスケジュールされたジョブまたはcronタスクが実行されている
* IoTデバイスがバックエンドサービスまたはAPIと通信できるようにする
* ユーザーの関与なし、またはユーザートークンの有効期限が切れた後に他のAPIレイヤーと通信する必要があるAPIレイヤーがある
* ユーザーが認証される前に呼び出す必要がある特権APIがある（つまり、Auth0テナントのアクションまたはカスタムデータベーススクリプトから）
* APIゲートウェイを使用してバックエンドサービスを管理する
* 非対話型アプリケーションや、daemonやバックエンドサービスなど人間との対話を含まないその他のツールを使用またはサポートする

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

これらのサービスは引き続き認証にM2Mアクセストークンが必要です。

</Callout>

## このガイドの使用方法

このガイドは、Auth0でM2M実装を作成するための経路です。検討すべき考慮事項、ベストプラクティス、概念を提供します。

* 「アーキテクチャ」では、ソフトウェア開発ライフサイクルと既存のインフラストラクチャをサポートするようにAuth0を構成することをお勧めします。
* 「アカウントの作成」では、Auth0でAPIインスタンスを作成する手順と、マシンツーマシン認証に必要な認証フロー（または権限許可）をサポートするアプリケーションを作成する手順を示します。
* 「認証」では、認証に使用する必要がある権限許可と、設定できるアクセストークンおよびアクセス許可（またはスコープ）について説明します。
* 「ブランディング」では、証明書の管理方法に応じて、カスタムドメインの構成方法に関する情報をどこで入手できるかをアドバイスします。
* 「デプロイメントの自動化」では、デプロイメントを支援するツールについて読むことができます。
* 「品質保証」では、ユニットテストと、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=auth0-dashboard" tip="Auth0 Dashboard: サービスを構成するためのAuth0の主製品。" cta="用語集の表示">Auth0 Dashboard</Tooltip>で提供される準備チェックについて詳しく説明します。

## アーキテクチャ

Auth0アカウントとテナント、またはAuth0サービスのグループと構造を構成する前に、既存のエコシステムでAuth0の機能を最大限に活用できるように既存のインフラストラクチャのマップを作成します。

一般的なシナリオで説明したように、Auth0を構成する前に、アプリケーションドメイン、ネットワークドメイン、またはM2Mデバイスドメインに他の非対話型テクノロジーを考慮する必要があるかもしれません。M2Mシナリオの例を確認するには、「[サーバー + API](/docs/ja-jp/get-started/architecture-scenarios/server-application-api/part-1)」を参照してください。Nodeを使ったハンズオン・ラボやAPIのデプロイをテストするには、[GitHubリポジトリ](https://www.google.com/url?q=https://github.com/auth0-training/labs-node-working-with-apis&sa=D&source=docs&ust=1723578190947730&usg=AOvVaw3IXRQG9ogH4pW6LEY047T6)にアクセスしてください。

現在の技術スタックを視覚化したり、Auth0が現在のソフトウェア開発ライフサイクル（SDLC）にどのように適合するかを計画したりできます。これは、必要なテナントの数を判断するのに役立ちます。

### 考慮事項

新しいアカウントを作成したり、最初のテナントを構成したりする前に、次の点を考慮する必要があります。

* 特定のエンドポイントを呼び出すためにAPIを分割またはグループ化する方法。

  + これにより、アクセストークンのオーディエンスやその他のクレームが決定されます。
* リソースのサードパーティコンシューマーは、呼び出しごとにアクセストークンを要求する場合があります。呼び出しが多すぎると、[レート制限](/docs/ja-jp/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/self-service-public)に影響する可能性があります。

## アカウントの作成

アーキテクチャの計画ができたので、Auth0アカウントとテナントを構成します。Auth0サービスにサインアップすると、最初の[テナント](/docs/ja-jp/get-started/auth0-overview/create-tenants)が作成されます。ここで、Auth0アセット、サービス、およびリソースを構成します。[サインアップ](https://auth0.com/signup)して開始します。

<Card title="開始する前に">

Auth0 Dashboard内またはAuth0 Management APIを使用して、以下を作成します。

* APIを表すAPI
* クライアントの資格情報フローを使用するM2Mアプリケーション

アカウントを作成する前に、構成情報を計画することをお勧めします。

* テナント名には、Auth0ドメインにおけるロールが含まれます。名前を決める前に、「[テナントの特性](https://auth0.com/docs/get-started/auth0-overview/create-tenants#create-a-tenant-and-domain)」をお読みください。
* ユースケースに必要となるAuth0機能を検討します。機能によっては、プロフェッショナルおよびエンタープライズプラン以外では、ご利用いただけません。
* 開発、ステージング、本番など、複数の環境に対応する必要があるか決定します。詳細については、「[複数の環境をセットアップする](/docs/ja-jp/get-started/auth0-overview/create-tenants/set-up-multiple-environments)」をお読みください。
* テナント内に登録するサードパーティアプリケーションが関連するユースケースがある場合、[OIDCクライアント登録](https://openid.net/specs/openid-connect-registration-1_0.html)の仕様に基づいて、[動的アプリケーション登録](/docs/ja-jp/get-started/applications/dynamic-client-registration)を使用することができます。
* 「[バックエンドサービスおよびAPIライブラリー](https://auth0.com/docs/libraries#backend)」をお読みのうえ、クイックスタートをお試しください。

</Card>

### テナントのプロビジョニング

アーキテクチャの計画ができたので、Auth0アカウントと<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" href="/docs/ja-jp/glossary?term=tenant" tip="テナント: Auth0では、単一のソフトウェアインスタンスに対して特定の権限があるアクセスを共有する、論理的に分離されたユーザーのグループのこと。複数のテナントが同じマシン上で実行している場合でも、その中の1つのテナントが別のテナントのデータにアクセスすることはできません。" cta="用語集の表示">テナント</Tooltip>を構成します。

<Warning>

Auth0 DashboardでAPIを作成すると、APIのテストアプリケーションが自動的に生成されます。[Management API](https://auth0.com/docs/api/management/v2/)でAPIをプログラムで作成する場合、別の呼び出しでテストアプリケーションを作成する必要があるかもしれません。

</Warning>

#### APIの登録

このセクションでは、Auth0でAPIを作成します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0ダッシュボード内、あるいは管理API[リソースサーバーの更新](https://auth0.com/docs/api/management/v2/resource-servers/patch-resource-servers-by-id)エンドポイントを呼​び出すことで、いつでもAPIを更新できます。

</Callout>

<Tabs><Tab title="Auth0ダッシュボード">

まず、Auth0 DashboardでAPI用のインスタンスを作成します。

1. 指示に従って[APIを登録](/docs/ja-jp/get-started/auth0-overview/set-up-apis)します。

[［Authentication（認証）］](https://auth0.com/docs/get-started/onboarding/self-service-m2m#authentication)セクションで、M2M認証用のAPI設定を構成します。

</Tab><Tab title="Mangement API">

APIをプログラムで登録するには、Management APIを使用します。Management APIを使用するには、アクセストークンが必要です。方法については、「[Management APIトークン](/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens)」をお読みください。

Management API Explorerで提供されているサンプルを使用して、Management API[リソースサーバーの作成](https://auth0.com/docs/api/management/v2/resource-servers/post-resource-servers)エンドポイントを呼び出し、本文に次のパラメーターを含めます：

<table class="table"><thead>
<tr>
<th><strong>フィールド</strong></th>
<th><strong>説明</strong></th>
<th><strong>例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Name（名前）</strong></td>
<td>APIのわかりやすい名前です。機能性には影響しません。</td>
<td>`yourDomain`</td>
</tr>
<tr>
<td><strong>Identifier（識別子）</strong></td>
<td>APIの一意の識別子です。URLの使用を推奨します。Auth0では、末尾にスラッシュを含むURLが区別されます。たとえば、`https://example.com`と`https://example.com/`は異なる識別子として扱われます。このURLは公開されているURLでなくても構いません。Auth0がAPIを呼び出すことはありません。この値は後で変更できません。</td>
<td>`https://{yourDomain}`</td>
</tr>
<tr>
<td><strong>JSON Web Token (JWT) Profile（JSON Web Token（JWT）プロファイル）</strong></td>
<td>このプロファイルが、APIに発行されるアクセストークンの形式を決定します。使用できる値は`Auth0`と`RFC 9068`です。詳細については、「<a href="/docs/ja-jp/secure/tokens/access-tokens/access-token-profiles">アクセストークンのプロファイル</a>」を参照してください。</td>
<td>`access_token`</td>
</tr>
<tr>
<td><strong>JSON Web Token (JWT) Signing Algorithm（JSON Web Token（JWT）署名アルゴリズム）</strong></td>
<td>アクセストークンの署名に使用されるアルゴリズムです。使用できる値は`HS256`、`PS256`、`RS256`です。`RS256`を選択すると、トークンはテナントの秘密鍵で署名されます。</td>
<td>`HS256`</td>
</tr>
</tbody>
</table>

</Tab></Tabs>

### アプリケーションの関連付け

アプリケーションとAPIの間に関連付けを作成して、アプリケーションがAPIからアクセストークンを要求できるようにする必要があります。クライアント権限許可について詳細は、認証のセクションで説明します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0のAPIには、構成前に確認の必要がある設定が複数あります。詳細については、「[APIの設定](/docs/ja-jp/get-started/apis/api-settings)」をお読みください。

</Callout>

<Tabs><Tab title="Auth0 Dashboard">

DashboardでAPIを作成する場合、Auth0は自動的にテストアプリケーションを生成し、APIに関連付けます。

1. [［Auth0 Dashboard］ > ［Applications（アプリケーション）］](https://manage.auth0.com/#/applications)に移動します。
2. API作成時に作成したテストM2Mテストアプリケーションを選択します。

   <Callout icon="file-lines" color="#0EA5E9" iconType="regular">

   後から開発向けまたは運用向けの別のアプリケーションを作成するには、[マシンツーマシン（M2M）アプリケーションを登録](/docs/ja-jp/get-started/auth0-overview/create-applications/machine-to-machine-apps)の手順に従います。

   </Callout>

3. **［API］** ビューに切り替え、このアプリケーションに対して有効にしたいAPIを見つけます。
4. **［Authorize（認可）］** トグルを有効にし、右側にある矢印ボタンを選択してカードを展開します。
5. **［Update（更新）］** を選択します。

   <Frame>![［Dashboard］ > ［Applications（アプリケーション）］ > ［APIs］](/docs/images/ja-jp/cdy7uua7fh8z/6L2R46XVdYw1kifRfMifRz/364292a89a04a152938e6901072ea662/Timesheet_API.png)</Frame>

   <Callout icon="file-lines" color="#0EA5E9" iconType="regular">

   このビューでは、ドロップダウンを選択して、追加したいスコープを選択できます。スコープについては、［Authentication（認証）］セクションのアクセストークンについて説明するときに詳しく説明します。

   </Callout>

</Tab><Tab title="Mangement API">

APIに関連付けるアプリケーションを作成します。Management API Explorerで提供されているサンプルを使用して、以下を行います：

1. [Create a Client（クライアントの作成）](https://auth0.com/docs/api/management/v2/clients/post-clients)エンドポイントを呼び出します。`app_type`を`non-interactive`に設定する必要があります。
2. [Create Client Grant（クライアントの許可の作成）](https://auth0.com/docs/api/management/v2/client-grants/post-client-grants)エンドポイントを呼び出し、アプリケーションをAPIに関連付けます。

アプリケーションとテナント設定の詳細については、「[テナント設定](/docs/ja-jp/get-started/tenant-settings)」をお読みください。

</Tab></Tabs>

## 認証

あるAPIを別のAPIから呼び出す場合、または認証されたユーザーコンテキストがない状況から呼び出す場合は、ユーザーではなくアプリケーションを認可する方法が必要です。これは、アプリケーションが認証され（`client_id`と`client_secret`を使用）、1回の呼び出しで認可される1ステッププロセスです。

非対話型アプリケーションまたはサービスの認証では、クライアント権限許可または認証フローを選択する必要があります。Auth 2.0[クライアントの資格情報フロー](https://tools.ietf.org/html/rfc6749#section-4.4)は、人間の介入を必要とせず、M2Mアプリケーションに最適です。

<Card title="開始する前に">

Auth0 DashboardやManagement APIで、以下のことを行います。

* クライアントの資格情報フローを使用するようにアプリケーションを設定します。
* M2Mアクセストークンのスコープを更新します。

認証方式を構成する前に以下のことを行います。

* マシンツーマシン認証については、「[クライアントの資格情報フロー](/docs/ja-jp/get-started/authentication-and-authorization-flow/client-credentials-flow)」を参照してください。これは非対話型の認証と認可のワークフローです。
* APIのアクセスレベルを決定します。これは、APIを作成する際に構成する[スコープ](/docs/ja-jp/get-started/apis/scopes/api-scopes)や権限を決めるのに役立ちます。

</Card>

### クライアントの資格情報フローを構成する

Auth0 Dashboardまたは<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=management-api" tip="Management API: 顧客が管理タスクを実行できるようにするための製品。" cta="用語集の表示">Management API</Tooltip>を使用して、アクセストークンと引き換えにクライアント資格情報を提供する認証フローを設定できます。

Auth0 DashboardまたはManagement APIを使用するには、「[付与タイプを更新する](/docs/ja-jp/get-started/applications/update-grant-types)」の手順に従ってください。

### M2Mアクセストークン

トークンベースの認証では、非対話型クライアントは、[Authentication APIトークンエンドポイント](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow)への呼び出しで`client_id`と`client_secret`を提供し、[アクセストークン](/docs/ja-jp/secure/tokens/access-tokens)を取得します。このアクセストークンにより、保護されたAPIへのアクセスが許可されます。

デフォルトのプロファイルまたは形式は、2つのトークンプロファイルに関連付けられたAuth0トークンプロファイルです。トークンプロファイルをRFC 9068に変更することもできます。詳細については、「[アクセストークンのプロファイル](/docs/ja-jp/secure/tokens/access-tokens/access-token-profiles)」をお読みください。トークンが有効であることを確認するために、APIは[署名アルゴリズム](/docs/ja-jp/get-started/applications/signing-algorithms)をチェックします。デフォルトの署名アルゴリズムは、キーベースのアルゴリズムであるRSA256です。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0は、資格情報としてクライアントIDとクライアントシークレットを提供するほか、他のクライアント認証方法もサポートしています。これらのメソッドは、M2Mの構成の[秘密鍵JWT](/docs/ja-jp/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)の推奨を含め、エンタープライズプランで利用できます。詳細については、「[アプリケーションの資格情報](/docs/ja-jp/secure/application-credentials)」をお読みください。

</Callout>

#### 例

`/oauth/token`エンドポイントへの要求は、次のサンプルのようになります。

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=client_credentials \
  --data client_id=YOUR_CLIENT_ID \
  --data client_secret=YOUR_CLIENT_SECRET \
  --data audience=YOUR_API_IDENTIFIER
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'client_credentials',
    client_id: 'YOUR_CLIENT_ID',
    client_secret: 'YOUR_CLIENT_SECRET',
    audience: 'YOUR_API_IDENTIFIER'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=client_credentials" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id=YOUR_CLIENT_ID" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_secret=YOUR_CLIENT_SECRET" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&audience=YOUR_API_IDENTIFIER" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=client_credentials".data(using: String.Encoding.utf8)!)
postData.append("&client_id=YOUR_CLIENT_ID".data(using: String.Encoding.utf8)!)
postData.append("&client_secret=YOUR_CLIENT_SECRET".data(using: String.Encoding.utf8)!)
postData.append("&audience=YOUR_API_IDENTIFIER".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

応答は、次のサンプルのようになります。

```json lines
HTTP/1.1 200 OK
Content-Type: application/json
{
  "access_token":"eyJz93a...k4laUWw",
  "token_type":"Bearer",
  "expires_in":86400
}
```

#### トークンの有効期限

アクセストークンには、トークンの有効期間の制限があります。通信はバックチャネルで行われるため、リフレッシュトークンを使用してセッションを延長することはできません。アクセストークンの有効期限を1時間に設定することを検討してください。特定の環境に合わせて、セキュリティとパフォーマンスのバランスを取る必要がある場合があります。詳細については、「[アクセストークンのライフタイムを更新する](/docs/ja-jp/secure/tokens/access-tokens/update-access-token-lifetime)」を参照してください。

### Scopes（スコープ）

非対話型クライアントまたはサービスがAPIを呼び出す前に、APIが許可する権限またはスコープを定義する必要があります。Auth0 Dashboardでスコープを設定して、Authentication APIへの認証要求に含めることができます。APIスコープの使用方法についてその他の例は、「[APIスコープ](/docs/ja-jp/get-started/apis/scopes/api-scopes)」を参照してください。

スコープを構成するには、Auth0 Dashboardの[APIの権限を追加](/docs/ja-jp/get-started/apis/add-api-permissions)の手順に従うか、Management APIに提供されているサンプルを使用します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

アクセストークンにカスタムクレームを追加するには、アクションマシンツーマシンフローを使用できます。詳細については、「マシンツーマシンフロー」をお読みください。

</Callout>

## ブランディング

非対話型クライアントやバックチャネルで動作するサービスを提供する場合でも、既存のブランドの外観と雰囲気に合わせてエクスペリエンスをカスタマイズできます。

### カスタムドメイン

Auth0は、`/authorize`エンドポイントを呼び出してアクセストークンを要求するときに、カスタムドメインの使用をサポートします。

<Card title="M2Mオンボーディング - カスタムドメイン">

Auth0ダッシュボードでは、次の操作を行う必要があります。

* Auth0サービスで使用する前に、ドメインを登録して検証します。
* 独自の証明書を管理するか、Auth0管理の証明書を使用するかを決定します。証明書の詳細については、「[証明書管理のオプション](https://auth0.com/docs/customize/custom-domains#certificate-management-options)」をお読みください。
* 自己管理証明書に使用するTLS（SSL）のバージョンと暗号がAuth0でサポートされていることを確認します。詳細ついては、「[TLS（SSL）のバージョンと暗号](/docs/ja-jp/customize/custom-domains/self-managed-certificates/tls-ssl)」をお読みください。

</Card>

1. Auth0管理の証明書を使用してカスタムドメインを構成するには、「[Auth0管理証明書を使ってカスタムドメインを構成する](/docs/ja-jp/customize/custom-domains/auth0-managed-certificates)」の手順に従ってください。

   1. 独自の証明書を管理する場合は、「[自己管理証明書を使ってカスタムドメインを構成する](/docs/ja-jp/customize/custom-domains/self-managed-certificates)」の手順に従ってください。

      <Callout icon="file-lines" color="#0EA5E9" iconType="regular">

      カスタムドメインで証明書を管理するには、エンタープライズサブスクリプションが必要です。詳細については、「[Auth0の価格設定](https://auth0.com/pricing/)」と「[ログイン](/docs/ja-jp/authenticate/login)」をお読みください。

      </Callout>

2. 「[カスタムドメインを使用したAPI構成](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains#apis)」を確認してください。カスタムドメインを組み込むには、API設定を調整する必要がある場合があります。

カスタムドメインで問題が発生した場合は、「[カスタムドメインのトラブルシューティング](/docs/ja-jp/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)」を確認してください。

## デプロイメント自動化

Auth0は、使用可能なデプロイメント自動化アプローチに関していくつかの異なるオプションをサポートしており、それぞれを組み合わせて使用することができます。

<Card title="ベストプラクティス">

デプロイメントの自動化をどのように構成する場合でも、デプロイメント前にカスタムコードとアクションの単体テストを実行し、デプロイメント後にテナントに対して統合テストを実行することをお勧めします。

</Card>

### CLIツールのデプロイ

アーキテクチャセクションで推奨されているように、開発、テスト、および本番用のAuth0テナントを用意する必要があります。これらのテナントは、品質チェックとテストのために同一の構成を共有する必要がありますが、環境間で構成が一致しないためにエラーが発生する可能性があります。たとえば、各環境には異なるクライアントIDとクライアントシークレットがあります。

これらの不一致エラーを軽減するには、Deploy CLIツールを使用して、Auth0インスタンスを既存のCI/CDパイプラインと統合できます。動的なキーワード置換を使用すると、同様の構成を共有するテナントの環境変数を置き換えることができます。詳細については、「[Deploy CLIツール](/docs/ja-jp/deploy-monitor/deploy-cli-tool)」と「[キーワードの置換](/docs/ja-jp/deploy-monitor/deploy-cli-tool/keyword-replacement)」をご覧ください。

### Real-time Webtask Logs拡張機能

Real-time Webtask Logs拡張機能は、`console.log`出力やその他の例外など、カスタムコードのすべてのログをリアルタイムで表示します。Auth0 Actionsまたはその他のカスタムロジックを使用している場合は、この拡張機能を使用してデバッグとトラブルシューティングを行うことができます。インストールと構成の詳細については、「[Real-time Webtask Logs拡張機能](/docs/ja-jp/customize/extensions/real-time-webtask-logs)」をご覧ください。

## 品質保証

品質保証は、本番稼働前に問題を特定する上で重要です。プロジェクトの性質に応じて、Auth0との統合の一環として検討する必要があるさまざまな種類の品質保証テストがあります。

* 予期しない本番負荷にさらされた場合、APIはどのように機能しますか?
* サードパーティアプリケーションによってレート制限はどのように影響を受けますか?

Auth0のウィジェットやユニバーサルログインのような機能を使用していない場合、多くのブラウザーやデバイスで、ユーザビリティやアクセシビリティのベストプラクティスをすぐに利用することはできません。機能要件が満たされ、予期しないイベントが正しく処理されるように、アプリケーションとAuth0の統合をテストするためのガイダンスと、Auth0 Actionsなどの個々の拡張モジュールのユニットテストが提供されています。また、Auth0の「[ペネトレーションテストポリシー](/docs/ja-jp/troubleshoot/customer-support/operational-policies/penetration-testing-policy)」を確認し、「[負荷テストポリシー](/docs/ja-jp/troubleshoot/customer-support/operational-policies/load-testing-policy)」と組み合わせて活用できるモックテストを完了して、予期しない負荷の下でもアプリケーションを確実に動作させることをお勧めします。

### ユニットテスト

ユニットテストは、Auth0 Actionsなどの拡張性のユニットを検証します。カスタムコードを使用している場合は、デプロイメント前にテストフレームワーク（[Mocha](https://mochajs.org/)など）を使用して追加コードをテストすることをお勧めします。

### モックテスト

Auth0の[負荷テストポリシー](/docs/ja-jp/troubleshoot/customer-support/operational-policies/load-testing-policy)と負荷テストの必要性のバランスを取るために、Auth0のエンドポイントのモックテストを作成するのが一般的です。これは、テストを制約することなく、構成が想定されたインターフェイスでの動作を確認するための有効な方法です。[MockServer](http://www.mock-server.com/)、[JSON Server](https://github.com/typicode/json-server)、さらに[Postman](https://learning.getpostman.com/docs/postman/mock_servers/setting_up_mock/)などのツールも使用できます。

## Deployment（デプロイ）

「[デプロイメントとモニタリング](/docs/ja-jp/deploy-monitor)」のセクションでは、デプロイメントのベストプラクティスに関するガイダンスを提供しています。「[導入前](/docs/ja-jp/deploy-monitor/pre-deployment-checks)[の確認事項](/docs/ja-jp/deploy-monitor/pre-deployment-checks)」、特に組み込みの「[Auth0 Dashboard準備状況チェック](/docs/ja-jp/deploy-monitor/pre-deployment-checks/how-to-run-production-checks)」を確認することをお勧めします。

準備チェックを確認するには、[［Auth0 Dashboard］>［Run Readiness Checks（準備状況チェックの実行）］](https://manage.auth0.com/#/production-checks)を選択し、テナント名と環境タグの下のドロップダウンメニューを選択します。

<Frame>![Auth0 Dashboard > Readiness Checklist](/docs/images/ja-jp/cdy7uua7fh8z/7iu1CzH0NgaXJbLBNWXZli/ea20f97de93711c0c995ea9fedcf20fa/Readiness_Checks_-_Japanese.png)</Frame>

フィルターを使用して、選択したアプリケーションに準備状況チェックを適用できます。**これらのチェックは、構成済みのAPIには適用されません** 。

特定の構成に適用されないチェックについては、**［Dismiss（閉じる）］** を選択して最終結果から削除できます。

本番稼働前に最終チェックの「[デプロイメントのベストプラクティス](/docs/ja-jp/deploy-monitor/deployment-best-practices)」を確認し、[ログ](/docs/ja-jp/deploy-monitor/logs)を利用してサービスを監視することをお勧めします。

## もっと詳しく

* [Auth0の概要](/docs/ja-jp/get-started/auth0-overview)
* [ソリューションの概要（サーバーアプリ + API）](/docs/ja-jp/get-started/architecture-scenarios/server-application-api/part-1)
* [クライアントの資格情報フローを使用してAPIを呼び出す](/docs/ja-jp/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow)
* [Management APIを使ってログイベントを取得する](/docs/ja-jp/deploy-monitor/logs/retrieve-log-events-using-mgmt-api)
* [本番環境のManagement APIアクセストークンの取得](/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)