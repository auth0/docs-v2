```go title="internal/handlers/api.go"
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/yourorg/myapi/internal/auth"
	jwtmiddleware "github.com/auth0/go-jwt-middleware/v3"
	"github.com/auth0/go-jwt-middleware/v3/validator"
)

// PublicHandler - no authentication required
func PublicHandler(w http.ResponseWriter, r *http.Request) {
	response := map[string]string{
		"message": "Hello from a public endpoint! You don't need to be authenticated to see this.",
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// PrivateHandler - requires valid JWT
func PrivateHandler(w http.ResponseWriter, r *http.Request) {
	response := map[string]string{
		"message": "Hello from a private endpoint! You need to be authenticated to see this.",
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// ScopedHandler - requires 'read:messages' permission
func ScopedHandler(w http.ResponseWriter, r *http.Request) {
	// Extract validated claims using generics (v3 feature)
	claims, err := jwtmiddleware.GetClaims[*validator.ValidatedClaims](r.Context())
	if err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(`{"message":"Unauthorized."}`))
		return
	}

	// Check for required scope in custom claims
	customClaims, ok := claims.CustomClaims.(*auth.CustomClaims)
	if !ok || !customClaims.HasScope("read:messages") {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusForbidden)
		w.Write([]byte(`{"message":"Insufficient scope."}`))
		return
	}

	response := map[string]string{
		"message": "Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.",
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}
```
