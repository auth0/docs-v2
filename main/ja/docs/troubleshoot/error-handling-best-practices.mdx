---
title: エラー処理のベストプラクティス
description: APIコールから返されるエラー状態は、適切な方法で処理されなければなりません。これを怠ると、未処理の例外状況につながり、結果としてパイプラインの実行が早期に終了し、最終的に認証エラーが返されることになります。
---

## エラーログを外部サービスに送信する

異常な操作の可視性と診断を向上させるために、エラーイベントログを外部サービスに送信することをお勧めします。サブスクリプションプランで提供されるログ保持期間を超えてログイベントを保持および分析するには、[Auth0のログストリーミングを使用してください](/docs/customize/log-streams)。DataDogやAWS EventBridgeなどのサービスを利用できます。また、Auth0 Marketplaceの[ログストリーミング](https://marketplace.auth0.com/features/log-streaming)セクションで外部サービスにログを送信する機能も提供しています。

## ルールでエラーオブジェクトを使用する

ルールの実行時間には制約があります。詳細については、[カスタムデータベースアクションスクリプト実行のベストプラクティス](/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)をお読みください。この時間内にエラー状態からの回復が不可能（または可能性が低い）場合は、エラー状態を明示的に返す必要があります。これは、Node の`Error`オブジェクトのインスタンスを返すことで、ルールの実行を完了するだけです。例えば：

`return callback(new Error('some description'));`

詳細については、[Class: Error on nodejs.org](https://nodejs.org/api/errors.html#errors_class_error)をお読みください。

あるいは、Auth0固有の`UnauthorizedError`のインスタンスを返すこともできます。これにより、`unauthorized`エラー条件が、提供されたエラー説明とともに、認証を開始したアプリケーション（つまり、`/authorize`エンドポイントへのリダイレクトが開始されたアプリケーション）に返されます。これにより、アプリケーションは条件付きの再試行機能を提供でき、特定の条件に基づいてアクセスを拒否するルールを実装できます：

`return callback(new UnauthorizedError('some description'), user, context);`

## 意味のあるエラーコードの説明を使用する

UnauthorizedError`UnauthorizedError`オブジェクトは提供された説明のみを返します。未認証エラー条件に対して特定の処理を行うために、説明に簡単にアクセスできるエラーコード情報を含めることをお勧めします。例えば：

`'[00043] - my specific error description'`)

## 例外処理

キャッチされていないJavaScript例外などの予期しないエラー条件は、パイプラインの実行が早期に終了する原因となり、最終的に認証エラーが返されることになります。

非同期操作を含む状況では、`catch`ハンドラを使用する必要があります。`Promise`オブジェクト処理を使用する場合。`Promise`オブジェクト処理は、非同期操作以外のエラー処理にも効果的です。以下に示すように、`Promise`オブジェクトを使用して、例えば同期関数呼び出しをラップすることで、プロミスチェーンなどを使用してカスケードエラー処理を実装しやすくなります。Promiseオブジェクトの詳細については、[MDN Web DocsのPromise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)をお読みください。プロミスチェーンの詳細については、[javascript.infoのPromisesを使用したエラー処理](https://javascript.info/promise-error-handling)。

```js lines
return new Promise(function(resolve, reject) {
    jwt.verify(
      token,
      secret,{
      clockTolerance: 5},
      function(err, decoded) {
        if (err) {
          reject(err);
        } else {
          resolve(decoded);
      }
    });
  });
```

あるいは、`try...catch`処理を使用して、同期操作中に発生するJavaScript例外を処理することができます。詳細については、[`try...catch`のMDN Web Docsを参照してください](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)。このタイプの例外処理を設定すると、しばしばパフォーマンスコストが発生するため、慎重に使用する必要があります。ルールのパフォーマンスは可能な限り最適である必要があります。より実用的なアプローチは、例外が発生した後に処理するのではなく、例外の発生を防ぐ処理を実装することです。ベストプラクティスの詳細については、[パフォーマンスのベストプラクティス](/docs/troubleshoot/performance-best-practices)を参照してください。

## ルールで初期化されていないオブジェクトを避ける

初期化されていないオブジェクトを使用すると、例外が発生する可能性があります。オブジェクトの存在が疑わしい場合は、宣言の一部として初期化を含めることをお勧めします。例えば：

`user.user_metadata = user.user_metadata || {}`)

ルールにおいて、最初から例外の発生を防ぐ措置を講じることがベストプラクティスであり、通常、例外処理を実装するよりもパフォーマンスとリソース使用の面でコストが低くなります。
