---
title: "Personnaliser les pages d’erreur"
permalink: "custom-error-pages"
'description': "Découvrez comment créer une page d’erreur personnalisée pour les événements d’erreur d’autorisation."
'og:title': "Personnaliser les pages d’erreur"
'og:description': "Découvrez comment créer une page d’erreur personnalisée pour les événements d’erreur d’autorisation."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Personnaliser les pages d’erreur"
'twitter:description': "Découvrez comment créer une page d’erreur personnalisée pour les événements d’erreur d’autorisation."
---

Lorsqu’une erreur d’autorisation se produit et que votre URL de rappel est valide, le serveur d’autorisations renvoie les paramètres d’erreur et d’état appropriés à votre URL de rappel. Si votre URL de rappel n’est pas valide, votre application affichera la [page d’erreur Auth0 par défaut](/docs/fr-ca/authenticate/login/auth0-universal-login/error-pages).

Votre application peut également afficher la page d’erreur Auth0 par défaut pour des raisons autres qu’une URL de rappel non valide, tel que :

* Les paramètres obligatoires sont manquants lors de l’appel du point de terminaison [Login](https://auth0.com/docs/api/authentication#login) d’Auth0 Authentication API.
* L’utilisateur ouvre un lien de réinitialisation de mot de passe expiré (avec la Connexion classique).
* L’utilisateur accède à une page de connexion marquée comme signet et une [Route de connexion par défaut](/docs/fr-ca/authenticate/login/auth0-universal-login/configure-default-login-routes) n’est pas spécifiée.

## Paramètres

Si vous optez pour la configuration d’une page d’erreur personnalisée, le serveur d’autorisations renverra des paramètres à l’URL en tant que chaîne de requête.

<table class="table"><thead>
<tr>
<th><strong>Paramètre</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`client_id`</td>
<td>Identifiant de l’application Auth0.</td>
</tr>
<tr>
<td>`connection`</td>
<td>Connexion utilisée au moment de l’erreur.</td>
</tr>
<tr>
<td>`lang`</td>
<td>Langue utilisée au moment de l’erreur.</td>
</tr>
<tr>
<td>`error`</td>
<td>Code d’erreur de l’erreur.</td>
</tr>
<tr>
<td>`error_description`</td>
<td>Description de l’erreur.</td>
</tr>
<tr>
<td>`tracking`</td>
<td>Identifiant utilisé par Auth0 pour trouver des erreurs dans les journaux internes.</td>
</tr>
</tbody>
</table>

Les paramètres présentés varient en fonction du type d’erreur et sont propres à la demande. Par exemple, si la requête qui a abouti à une erreur ne contenait pas un `client_id`, le serveur d’autorisations ne renverra pas le paramètre `client_id`.

## Afficher une page d’erreur personnalisée

Si vous souhaitez afficher une page d’erreur personnalisée, deux options s’offrent à vous :

1. Rediriger les utilisateurs vers une page d’erreur personnalisée à l’aide d’Auth0 Dashboard ou de Auth0 Management API.
2. Configurer Auth0 pour afficher une page d’erreur personnalisée en votre nom via Management API.

### Redirigez les utilisateurs vers une page d’erreur personnalisée à l’aide de Dashboard

Utilisez Dashboard pour configurer Auth0 en redirigeant les utilisateurs vers une page d’erreur personnalisée :

1. Accédez à [Auth0 Dashboard > Tenant Settings (Paramètres du locataire)](https://manage.auth0.com/#/tenant/) .
2. Localisez la section **Error Pages (Pages d’erreur)**.
3. Sélectionnez l’option **Redirect users to your own error page (Rediriger les utilisateurs vers votre propre page d’erreur)**.
4. Saisissez l’URL de la page d’erreur qui sera vue par vos utilisateurs et sélectionnez **Save (Enregistrer)**.

### Redirigez les utilisateurs vers une page d’erreur personnalisée à l’aide de Management API.

Utilisez le point de terminaison de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip> [Update Tenant Settings (Mettre à jour les paramètres du locataire)](/docs/fr-ca/api/management/v2/#!/Tenants/patch_settings). Remplacez la valeur du paramètre fictif `{mgmtApiAccessToken}` avec votre jeton d’accès de Management API et mettez à jour la valeur du champ `url` dans le corps JSON pour pointer vers l’emplacement de la page d’erreur.

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/tenants/settings' \
  --header 'authorization: Bearer {mgmtApiAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"error_page": {"html": "", "show_log_link":false, "url": "http://www.example.com"}}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/tenants/settings");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer {mgmtApiAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/tenants/settings"

	payload := strings.NewReader("{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("authorization", "Bearer {mgmtApiAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/tenants/settings")
  .header("authorization", "Bearer {mgmtApiAccessToken}")
  .header("content-type", "application/json")
  .body("{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/tenants/settings',
  headers: {
    authorization: 'Bearer {mgmtApiAccessToken}',
    'content-type': 'application/json'
  },
  data: {error_page: {html: '', show_log_link: false, url: 'http://www.example.com'}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {mgmtApiAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"error_page": @{ @"html": @"", @"show_log_link": @NO, @"url": @"http://www.example.com" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/tenants/settings"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/tenants/settings",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {mgmtApiAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}"

headers = {
    'authorization': "Bearer {mgmtApiAccessToken}",
    'content-type': "application/json"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/tenants/settings", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/tenants/settings")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer {mgmtApiAccessToken}'
request["content-type"] = 'application/json'
request.body = "{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer {mgmtApiAccessToken}",
  "content-type": "application/json"
]
let parameters = ["error_page": [
    "html": "",
    "show_log_link": false,
    "url": "http://www.example.com"
  ]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/tenants/settings")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Champ</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`{mgmtApiAccessToken}`</td>
<td>[Jeton d’accès à Management API] (/api/management/v2/tokens) avec la permission `update:tenant_settings`.</td>
</tr>
<tr>
<td>`show_log_link`</td>
<td>Indique s’il faut afficher un lien vers l’erreur dans les journaux des locataires. Les valeurs valides sont `true (vrai)` et `false (faux)`.</td>
</tr>
<tr>
<td>`url`</td>
<td>Emplacement de la page d’erreur personnalisée vers laquelle vous voulez rediriger.</td>
</tr>
</tbody>
</table>

### Afficher une page d’erreur personnalisée

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Lorsque des erreurs sont affichées dans le cadre du widget de connexion classique (comme un lien de réinitialisation d’un mot de passe expiré), aucune page d’erreur personnalisée hébergée par Auth0 n’est affichée, même si elle est configurée.

</Callout>

Utilisez le point de terminaison de Management API [Update Tenant Settings (Mettre à jour les paramètres du locataire)](/docs/fr-ca/api/management/v2/#!/Tenants/patch_settings). Remplacez la valeur du paramètre fictif `{mgmtApiAccessToken}` avec votre jeton d’accès à Management API et mettez à jour la valeur du champ `html` dans le corps JSON vers une chaîne contenant le code HTML de votre page.

Vous pouvez utiliser la syntaxe Liquid pour inclure les variables suivantes :

* `{client_id}`
* `{connection}`
* `{lang}`
* `{error}`
* `{error_description}`
* `{tracking}`

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url https://login.auth0.com/api/v2/tenants/settings \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"error_page": {"html": "<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'\''now'\'' | date: '\''%Y %h'\''}}.</h1>", "show_log_link": false, "url": ""}}'
```
```csharp C# lines
var client = new RestClient("https://login.auth0.com/api/v2/tenants/settings");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"error_page\": {\"html\": \"

# {{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.

\", \"show_log_link\": false, \"url\": \"\"}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://login.auth0.com/api/v2/tenants/settings"

	payload := strings.NewReader("{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.patch("https://login.auth0.com/api/v2/tenants/settings")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://login.auth0.com/api/v2/tenants/settings',
  headers: {
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'content-type': 'application/json'
  },
  data: {
    error_page: {
      html: '<h1>{{error | escape }} {{error_description | escape }} This error was generated {{\'now\' | date: \'%Y %h\'}}.</h1>',
      show_log_link: false,
      url: ''
    }
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"error_page": @{ @"html": @"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>", @"show_log_link": @NO, @"url": @"" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://login.auth0.com/api/v2/tenants/settings"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://login.auth0.com/api/v2/tenants/settings",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("login.auth0.com")

payload = "{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}"

headers = {
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("PATCH", "/api/v2/tenants/settings", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://login.auth0.com/api/v2/tenants/settings")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["error_page": [
    "html": "<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>",
    "show_log_link": false,
    "url": ""
  ]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://login.auth0.com/api/v2/tenants/settings")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Champ</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`{mgmtApiAccessToken}`</td>
<td><a href="/docs/fr-ca/api/management/v2/tokens">Jeton d’accès du Management API</a> avec la permission `update:tenant_settings`.</td>
</tr>
<tr>
<td>`show_log_link`</td>
<td>Indique s’il faut afficher un lien vers l’erreur dans les journaux des locataires. Les valeurs valides sont `true` et `false`.</td>
</tr>
<tr>
<td>`html`</td>
<td>HTML de la page d’erreur personnalisée que vous souhaitez afficher.</td>
</tr>
</tbody>
</table>

Pour éviter les vulnérabilités XSS, vérifiez votre modèle personnalisé à l’aide des filtres [escape](https://shopify.github.io/liquid/filters/escape/) et [strip_html](https://shopify.github.io/liquid/filters/strip_html/) de Liquid.

## En savoir plus

* [Connexion universelle Auth0](/docs/fr-ca/authenticate/login/auth0-universal-login)