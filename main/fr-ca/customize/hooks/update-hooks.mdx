---
title: "Mettre à jour des hooks"
permalink: "update-hooks"
'description': "Apprenez comment mettre à jour les appels en utilisant le Dashboard ou Management API. Les hooks peuvent également être importés et exportés à l’aide de l’outil Auth0 Deploy CLI."
'og:title': "Mettre à jour des hooks"
'og:description': "Apprenez comment mettre à jour les appels en utilisant le Dashboard ou Management API. Les hooks peuvent également être importés et exportés à l’aide de l’outil Auth0 Deploy CLI."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Mettre à jour des hooks"
'twitter:description': "Apprenez comment mettre à jour les appels en utilisant le Dashboard ou Management API. Les hooks peuvent également être importés et exportés à l’aide de l’outil Auth0 Deploy CLI."
---

<Warning>

La date de fin de vie (EOL) des Règles et des Appels sera le **18 novembre 2026**. Ils ne sont plus disponibles pour les nouveaux locataires créés à partir du **16 octobre 2023**. Les locataires actuels ayant des hooks actifs conserveront l’accès aux produit Hooks jusqu’à la fin de leur durée de vie.

Nous vous conseillons vivement d’utiliser les Actions pour étendre Auth0. Avec les Actions, vous avez accès à des informations de type enrichies, à une documentation intégrée et à des packages `npm` publics, et vous pouvez connecter des intégrations externes qui optimisent votre expérience d’extensibilité globale. Pour en savoir plus sur ce que les Actions proposent, consultez [Comprendre comment fonctionnent Auth0 Actions](/docs/fr-ca/customize/actions/actions-overview).

Pour vous aider dans votre migration, nous proposons des guides qui vous aideront à [migrer des Règles vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions) et à [migrer des Hooks vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions). Nous avons également une page dédiée à la [Migration vers les Actions](https://auth0.com/extensibility/movetoactions) qui met en évidence les comparaisons de fonctionnalités, [une démo des Actions](https://www.youtube.com/watch?v=UesFSY1klrI)  et d’autres ressources pour vous aider dans votre parcours de migration.

Pour en savoir plus sur l’obsolescence des Règles et des Appels, consultez notre article de blog : [Preparing for Rules and Hooks End of Life (Préparation à la fin de vie des règles et des crochets)](https://auth0.com/blog/preparing-for-rules-and-hooks-end-of-life/).

</Warning>

<Warning>

Comme nous prévoyons de supprimer les fonctions Règles et Hooks en 2026, vous devez créer de nouvelles Règles ou de nouveaux Hooks uniquement dans votre environnement de développement et uniquement pour tester la migration vers les Actions.

Pour apprendre à migrer vos Règles vers des Actions, consultez [Migrer des règles vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions). Pour apprendre à migrer vos Hooks vers des Actions, consultez la section [Migrer des Hooks vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions).

</Warning>

Vous pouvez mettre à jour les hooks en utilisant Dashboard ou <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

Vous pouvez également importer et exporter des hooks à l’aide de l’outil [Deploy CLI](/docs/fr-ca/deploy-monitor/deploy-cli-tool).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

En option, vous pouvez ajouter des secrets (tels que des clés Twilio ou des chaînes de connexion à la base de données) aux hooks.

</Callout>

## Renommer les hooks en utilisant Dashboard

1. Allez à [Dashboard Auth0 > Pipeline auth > Hooks](https://manage.auth0.com/#/) et cliquez sur l’icône de roue dentée à côté du hook que vous souhaitez renommer.
2. Cliquez sur **Renommer**.
3. Saisissez un nouveau nom pour le hook et cliquez sur **Renommer**.

   <Frame>![Auth0 Rename Hooks](/images/fr-ca/cdy7uua7fh8z/2Xp8Z3uYGoGZrF5EGXLPLQ/6c68c77f97133b2066219a68540b1e73/Screen_Shot_2021-05-19_at_12.08.00_PM.png)</Frame>

## Mettre à jour les scripts d’appels en utilisant Dashboard

1. Allez à [Dashboard Auth0 > Pipeline Auth > Hooks](https://manage.auth0.com/#/) et cliquez sur l’icône de crayon à côté du hook que vous souhaitez mettre à jour.

   <Frame>![Auth0 Hooks select a Hook](/images/fr-ca/cdy7uua7fh8z/2y2R713TkAvQWIMZPMd1zh/bf0a657261f2d090492660ea5962e0a3/dashboard-hooks-list.png)</Frame>

2. Mettez à jour le crochet en utilisant l’Éditeur de crochet et cliquez sur l’icône de disque pour enregistrer votre changement.

   <Frame>![Auth0 Hook Editor](/images/fr-ca/cdy7uua7fh8z/26u71QdXxZxg5zIH8SJQAg/e9bbd25b99d9b8fd44c281b6de83a5a3/dashboard-hooks-edit_menu.png)</Frame>

## Mettre à jour les hooks en utilisant Management API

Effectuez une requête `PATCH` au [point de terminaison Mise à jour d’un hook](/docs/fr-ca/api/management/v2/#!/Hooks/patch_hooks_by_id). Assurez-vous de remplacer les valeurs des paramètres fictifs `HOOK_ID` et `MGMT_API_ACCESS_TOKEN` avec l’ID de votre appel et votre jeton d’accès de Management API, respectivement.

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "name": "HOOK_NAME", "script": "HOOK_SCRIPT", "enabled": "true" }'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/hooks/HOOK_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/hooks/HOOK_ID"

	payload := strings.NewReader("{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/hooks/HOOK_ID")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {name: 'HOOK_NAME', script: 'HOOK_SCRIPT', enabled: 'true'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"name": @"HOOK_NAME",
                              @"script": @"HOOK_SCRIPT",
                              @"enabled": @"true" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/hooks/HOOK_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/hooks/HOOK_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/hooks/HOOK_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/hooks/HOOK_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "name": "HOOK_NAME",
  "script": "HOOK_SCRIPT",
  "enabled": "true"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/hooks/HOOK_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

<table class="table"><thead>
<tr>
<th>Valeur</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`HOOK_ID`</td>
<td>ID du Hook à mettre à jour.</td>
</tr>
<tr>
<td>`HOOK_NAME`</td>
<td>Nom de l’appel à créer.</td>
</tr>
<tr>
<td>`HOOK_SCRIPT`</td>
<td>Script qui contient le code pour l’appel. Il doit correspondre à ce que vous entreriez en créant un nouvel appel en utilisant Dashboard.</td>
</tr>
</tbody>
</table>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

La propriété `enabled` représente la règle activée (`true`) ou désactivée (`false`).

</Callout>

<Card title="Gérer les limitations de taux lors d’une requête API depuis un Hook">

Si vous faites une requête API Auth0 à partir d’un script de Hook, vous devrez gérer les limitations de taux. Pour ce faire, vérifiez l’en-tête `X-RateLimit-Remaining` et gérez la situation de manière adéquate lorsque le numéro retourné s’approche de 0.

De plus, ajoutez le code nécessaire pour gérer les cas dans lesquels vous dépassez les limites de taux et recevez un code de statut HTTP `429`(`Too Many Requests`). Dans ce cas, si une nouvelle requête est nécessaire, il est recommandé de prévoir un délai d’attente pour éviter de se retrouver dans une boucle infinie de tentatives.

</Card>

