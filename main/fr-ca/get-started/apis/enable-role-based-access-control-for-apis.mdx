---
title: "Activer le contrôle d'accès basé sur les rôles (RBAC) pour les API"
permalink: "enable-role-based-access-control-for-apis"
'description': "Découvrez comment activer le contrôle d'accès basé sur les rôles (RBAC) pour une API à l’aide de Auth0 Dashboard ou de Management API."
'og:title': "Activer le contrôle d'accès basé sur les rôles (RBAC) pour les API"
'og:description': "Découvrez comment activer le contrôle d'accès basé sur les rôles (RBAC) pour une API à l’aide de Auth0 Dashboard ou de Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Activer le contrôle d'accès basé sur les rôles (RBAC) pour les API"
'twitter:description': "Découvrez comment activer le contrôle d'accès basé sur les rôles (RBAC) pour une API à l’aide de Auth0 Dashboard ou de Management API."
---

Vous pouvez activer le [contrôle d'accès basé sur les rôles (RBAC)](/docs/fr-ca/manage-users/access-control/rbac) à l’aide de <Tooltip href="/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> ou de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>. Cela permet d’activer l’ensemble de fonctionnalités de l’API Authorization Core.

Lorsque le RBAC est activé, la demande `scope` du jeton d’accès comprend une intersection des autorisations demandées et des autorisations attribuées à l’utilisateur, indépendamment des autorisations également incluses dans le jeton d’accès. Lorsque le RBAC est désactivé, une application peut demander n’importe quelle autorisation définie pour l’API, et la demande `scope` inclut toutes les autorisations demandées.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Si vous configurez des [Actions](/docs/fr-ca/customize/actions)

</Callout>

## Dashboard

1. Rendez-vous dans [Dashboard > Applications > API](https://manage.auth0.com/#/apis) et cliquez sur le nom de l’API pour l’afficher.

   <Frame>![Liste des API d’applications Dashboard](/images/fr-ca/cdy7uua7fh8z/3rhmhghYZDSi6YWHRA5yMQ/29b5fc5ca1dcedd82e9e7fff1fc8ecc8/2025-02-27_10-28-06.png)</Frame>

2. Faites défiler jusqu’aux **RBAC Settings (Paramètres RBAC)** et activez la bascule **Enable RBAC (Activer RBAC)**.

   <Frame>![Auth0 Dashboard (Tableau de bord Auth0) - API - Settings (Paramètres) - RBAC toggle (Bouton à bascule RBAC)](/images/fr-ca/cdy7uua7fh8z/65tKb6aj0ktc2qXLUVlV3e/69577ee902e42174a89a00cbdb27e355/2025-02-27_10-10-54.png)</Frame>

3. Pour inclure toutes les autorisations attribuées à l’utilisateur dans la demande `permissions` du jeton d’accès, activez la bascule **Add Permissions in the Access Token (Ajouter des autorisations au jeton d’accès)**, puis cliquez sur **Save (Enregistrer)**. Inclure les autorisations dans le jeton d’accès vous permet de faire peu d’appels pour récupérer les autorisations, mais augmente la taille du jeton.
   Une fois que vous avez activé la bascule **Add Permissions in the Access Token (Ajouter des autorisations au jeton d’accès)**, Auth0 met également à jour le dialecte de votre jeton en fonction du [access token profile](/docs/fr-ca/secure/tokens/access-tokens/access-token-profiles) que vous avez défini pour l’API :

   * Si le dialecte de votre token est `access_token`, Auth0 le met à jour en `access_token_authz`, ce qui équivaut à `access_token` avec la demande `permissions` incluse.
   * Si le dialecte de votre jeton est `rfc9068_profile`, Auth0 le met à jour en`rfc9068_profile_authz`, ce qui équivaut à `rfc9068_profile` avec la demande `permissions` incluse.

   Pour en savoir plus sur les dialectes de jetons disponibles, consultez [Options de dialecte des jetons](#token-dialect-options).

## Management API

Pour activer le RBAC à l’aide de Management API, envoyez une requête PATCH au point de terminaison [Update a resource server (Mettre à jour un serveur de ressources)](https://auth0.com/docs/api/management/v2/resource-servers/patch-resource-servers-by-id). Dans la requête PATCH, définissez `enforce_policies` sur `true` :

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/resource-servers/API_ID' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "enforce_policies": "true", "token_dialect": "TOKEN_DIALECT" }'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/resource-servers/API_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/resource-servers/API_ID"

	payload := strings.NewReader("{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/resource-servers/API_ID")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/resource-servers/API_ID',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {enforce_policies: 'true', token_dialect: 'TOKEN_DIALECT'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"enforce_policies": @"true",
                              @"token_dialect": @"TOKEN_DIALECT" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/resource-servers/API_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/resource-servers/API_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/resource-servers/API_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/resource-servers/API_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "enforce_policies": "true",
  "token_dialect": "TOKEN_DIALECT"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/resource-servers/API_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Remplacez les valeurs `API_ID`, `MGMT_API_ACCESS_TOKEN` et `TOKEN_DIALECT` par leurs valeurs respectives, comme indiqué dans le tableau suivant :

<table class="table"><thead>
<tr>
<th>Paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`API_ID`</td>
<td>ID de l’API pour laquelle vous souhaitez activer RBAC.</td>
</tr>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="https://auth0.com/docs/api/management/v2/tokens">Jeton d’accès pour Management API</a> avec la permission `update:resource_servers`.</td>
</tr>
<tr>
<td>`TOKEN_DIALECT`</td>
<td>Dialecte du jeton d’accès pour l’API indiquée. Pour en savoir plus, consultez <a href="#token-dialect-options">Options du dialecte des jetons</a>.</td>
</tr>
</tbody>
</table>

### Options de dialecte des jetons

Auth0 prend en charge les dialectes des jetons suivants :

<table class="table"><thead>
<tr>
<th>Valeur</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`access_token`</td>
<td>Le jeton Auth0 par défaut génère un jeton d’accès au format <a href="/docs/fr-ca/secure/tokens/json-web-tokens">Jeton Web JSON (JWT)</a>. Une intersection des autorisations demandées et des autorisations attribuées à l’utilisateur est incluse dans la demande « scope » du jeton d’accès. Aucune demande `permissions` n’est transmise. Pour en savoir plus, consultez <a href="/docs/fr-ca/secure/tokens/access-tokens/access-token-profiles">Profils de jeton d’accès</a>.</td>
</tr>
<tr>
<td>`access_token_authz`</td>
<td>Le profil de jeton Auth0 par défaut (`access_token`) avec la demande `scope`. Une intersection des autorisations demandées et des autorisations attribuées à l’utilisateur est incluse dans la demande `scope` du jeton d’accès. Toutes les autorisations attribuées à l’utilisateur sont incluses dans la demande `permissions` du jeton d’accès. Cela vous permet de faire des appels minimaux pour récupérer les autorisations, tout en augmentant la taille du jeton.</td>
</tr>
<tr>
<td>`rfc9068_profile`</td>
<td>Le profil de jeton RFC 9068 génère un jeton d’accès au format JWT suivant la page <a href="https://datatracker.ietf.org/doc/html/rfc9068">Profil JWT IETF pour les jetons d’accès OAuth 2.0 (RFC 9068)</a>. Une intersection des autorisations demandées et des autorisations attribuées à l’utilisateur est incluse dans la demande `scope` du jeton d’accès. Aucune demande `permissions` n’est transmise. Pour en savoir plus, consultez <a href="/docs/fr-ca/secure/tokens/access-tokens/access-token-profiles">Profils de jeton d’accès</a>.</td>
</tr>
<tr>
<td>« rfc9068_profile_authz »</td>
<td>Le profil de jeton RFC 9068 (« rfc9068_profile ») avec la demande `permissions`. Une intersection des autorisations demandées et des autorisations attribuées à l’utilisateur est incluse dans la demande `scope` du jeton d’accès. Toutes les autorisations attribuées à l’utilisateur sont incluess dans la demande `permissions` du jeton d’accès. Cela vous permet de faire des appels minimaux pour récupérer les autorisations, tout en augmentant la taille du jeton.</td>
</tr>
</tbody>
</table>

## En savoir plus

* [Gérer les utilisateurs du contrôle d'accès basé sur les rôles (RBAC)](/docs/fr-ca/manage-users/access-control/configure-core-rbac/rbac-users)
* [Gérer les permissions du contrôle d'accès basé sur les rôles (RBAC)](/docs/fr-ca/manage-users/access-control/configure-core-rbac/manage-permissions)
* [Exemples de cas d’utilisation : Contrôle d'accès basé sur les rôles (RBAC)](/docs/fr-ca/manage-users/access-control/sample-use-cases-role-based-access-control)
* [Dépannage du contrôle d’accès et de l’autorisation basés sur les rôles](/docs/fr-ca/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)