---
title: "PHPÂ : Utiliser lâ€™Authentication API avec Auth0-PHP"
permalink: "using-the-authentication-api-with-auth0-php"
'description': "En utilisant lâ€™Authentication API dâ€™Auth0 dans vos applicationsÂ PHP."
'og:title': "PHPÂ : Utiliser lâ€™Authentication API avec Auth0-PHP"
'og:description': "En utilisant lâ€™Authentication API dâ€™Auth0 dans vos applicationsÂ PHP."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "PHPÂ : Utiliser lâ€™Authentication API avec Auth0-PHP"
'twitter:description': "En utilisant lâ€™Authentication API dâ€™Auth0 dans vos applicationsÂ PHP."
---

La trousse SDK Auth0 pour PHP fournit une classe `Auth0\SDK\API\Authentication`, qui contient les mÃ©thodes que vous pouvez utiliser pour accÃ©der directement Ã  lâ€™[Authentication API](https://auth0.com/docs/api/authentication). Veuillez noter que cette interface est destinÃ©e Ã  des applications plus avancÃ©es et fournit en gÃ©nÃ©ral une faÃ§on de suivre les sessions des utilisateurs. Pour la plupart des cas dâ€™utilisation, vous souhaiterez travailler avec la [classe de base Auth0](/docs/fr-ca/libraries/auth0-php/auth0-php-basic-use).

Dans cet article, vous trouverez des exemples dâ€™opÃ©rations dâ€™authentification communes.

## PrÃ©requis

La documentation ci-dessous part du principe que vous avez suivi les Ã©tapes des [sections sur lâ€™installation et le dÃ©marrage](/docs/fr-ca/libraries/auth0-php), et que vous avez utilisÃ© le code fourni.

## Flux de code dâ€™autorisation

Un [Flux de code dâ€™autorisation](/docs/fr-ca/get-started/authentication-and-authorization-flow/authorization-code-flow) est la faÃ§on de base de donner accÃ¨s aux utilisateurs Ã  votre application. Ce flux est le mÃªme utilisÃ© sur la [Utilisation de base dâ€™Auth0-PHP](/docs/fr-ca/libraries/auth0-php/auth0-php-basic-use). Si vous avez besoin dâ€™un contrÃ´le plus granulaire sur le processus de connexion ou de Callback, cette section explique comment utiliser directement lâ€™Authentication API.

Les utilisateurs doivent sâ€™authentifier avec Auth0 pour gÃ©nÃ©rer le code dâ€™autorisation. Ceci se fait en Ã©tant redirigÃ© vers le point de terminaison `/authorize` pour votre domaine locataire. Le code suivant sâ€™affichera sur une page nÃ©cessitant une authentificationÂ :

```php lines
// ðŸ‘† We're continuing from the "getting started" guide linked in "Prerequisites" above. Append this to the index.php file you created there.

// Setup a PHP session, which we'll use as a custom session store for the authenticated user.
session_start();

// $user will be null if no session is available; otherwise it will contain user data.
$user = $_SESSION['user'] ?? null;

// Has the user authenticated with us yet?
if ($user === null) {
    // Generates cryptographically secure pseudo-random bytes to use as a CSRF mitigating value.
    // Store this for retrieval after authentication.
    $_SESSION['state'] = bin2hex(random_bytes(16));

    // Generate the authorize URL, and redirect the user to it.
    header('Location: ' . $auth0->authentication()->getLoginLink($_SESSION['state']));
    exit;
}

echo '<h1>Sensitive data!</h1>';
```

Le processus ci-dessus rÃ©alise le suivantÂ :

1. Nous vÃ©rifions sâ€™il existe un Ã©tat dâ€™utilisateur authentifiÃ© stockÃ© dans notre gestionnaire de session personnalisÃ©. Votre application peut gÃ©rer les sessions utilisateur diffÃ©remment.
2. Sâ€™il nâ€™y a pas de session, nous devons alors connecter lâ€™utilisateur en le redirigeant vers la page de connexion universelle.
3. Nous dÃ©finissons une valeur dâ€™Ã©tat avec la demande de connexion, puis vÃ©rifions cette valeur lorsque le code est renvoyÃ© sur lâ€™URL de rappel. Nous stockons cela dans notre sessionÂ PHP sous la clÃ© Â«Â stateÂ Â».
4. Lâ€™appel `getLoginLink()` crÃ©e le lien `/authorize` avec le type de rÃ©ponse correct (`code` dans ce cas), lâ€™URI de redirection (dans lequel lâ€™application nous gÃ©rerons la rÃ©ponse, expliquÃ©e ci-dessous) et lâ€™Ã©tat (ci-dessus).
5. Nous redirigeons ensuite vers cette URL et attendons que lâ€™utilisateur soit redirigÃ© vers nous.

AprÃ¨s authentification, lâ€™utilisateur est redirigÃ© vers notre application Ã  lâ€™URL de rappel, qui est gÃ©rÃ©e comme suitÂ :

```php lines
// ðŸ‘† We're continuing from the "getting started" guide linked in "Prerequisites" above. Append this to the index.php file you created there.

// Ensure we have our PHP session open so we can retrieve our stored state for comparison.
session_start();

// Extract `code` and `state` parameters from the request query, if present.
$code = filter_var($_GET['code'] ?? null, FILTER_UNSAFE_RAW, FILTER_NULL_ON_FAILURE);
$state = filter_var($_GET['state'] ?? null, FILTER_UNSAFE_RAW, FILTER_NULL_ON_FAILURE);

// Check if a code is present in the request query.
if ($code === null) {
    die('No authorization code found.');
}

// Check if a state is present, and compare it with the one we generated and stored before redirecting the user.
if ($state === null || $state !== $_SESSION['state']) {
    die('Invalid state.');
}

// We have compared states, we should discard this stored value now.
unset($_SESSION['state']);

// Attempt to get an access_token with the code returned and original redirect URI. (This returns a PSR-7 ResponseInterface.)
$response = $auth0->authentication()->codeExchange($code);

// Does the status code of the response indicate failure?
if ($response->getStatusCode() !== 200) {
    die("Code exchange failed.");
}

// Decode the JSON response into a PHP array:
$response = json_decode(response->getBody()->__toString(), true, 512, JSON_THROW_ON_ERROR);

// Create an array to store our session information in.
$session = [
    'id_token' => $response['id_token'] ?? null,
    'access_token' => $response['access_token'] ?? null,
    'scope' => $response['scope'] ?? null,
    'refresh_token' => $response['refresh_token'] ?? null,
    'expires_in' => $response['expires_in'] ?? null,
    'user' => null
];

// We retrieved an ID token; let's process it!
if ($session['id_token'] !== null) {
    // The Auth0 SDK includes a helpful token processing utility we'll leverage for this:
    $token = new \Auth0\SDK\Token($auth0->configuration(), $session['id_token'], \Auth0\SDK\Token::TYPE_ID_TOKEN);

    // Verify the token, and validate it's claims. These will throw an \Auth0\SDK\Exception\InvalidTokenException if a check fails.
    $token->verify();
    $token->validate();

    $session['user'] => $token->toArray();
}

// Store our authenticated session state.
$_SESSION['user'] = $session;

// Let's echo the user claims/identity as a demo of a successful authentication flow:
print_r($session['user']);
```

Parcourir le processus en dÃ©tailÂ :

1. Nous recherchons un paramÃ¨tre `code` dans une demande. Sâ€™il est manquant, nous abandonnons lâ€™authentification.
2. Nous vÃ©rifions que nous avons une valeur `state` et quâ€™elle coÃ¯ncide Ã  la mÃªme que celle gÃ©nÃ©rÃ©e. [Ceci est important pour Ã©viter les attaquesÂ CSRF.](/docs/fr-ca/secure/attack-protection)
3. Nous tentons un Ã©change de code avec lâ€™appel `codeExchange()`, en sâ€™assurant de transmettre le `code` quâ€™Auth0 a donnÃ© Ã  notre application lorsquâ€™il nous a renvoyÃ© lâ€™utilisateur authentifiant.
4. Si cela rÃ©ussit, nous savons que lâ€™Ã©change a rÃ©ussi et nous disposons dâ€™un jeton dâ€™ID et dâ€™un jeton dâ€™accÃ¨s parmi dâ€™autres valeurs potentielles.
5. Nous validons le jeton dâ€™ID et utilisons les demandes pour lâ€™identitÃ© de lâ€™utilisateur.
6. Si cette derniÃ¨re Ã©tape rÃ©ussit, nous stockons lâ€™utilisateur et le redirigeons vers nos donnÃ©es sensibles.

## Flux des identifiants client

Le [Flux des identifiants client](/docs/fr-ca/get-started/authentication-and-authorization-flow/client-credentials-flow) donne Ã  une application lâ€™accÃ¨s Ã  uneÂ API particuliÃ¨re en fonction des permissions dÃ©finies dans le tableau de bord. Câ€™est ainsi que les applications peuvent, par exemple, appeler ManagementÂ API. Une authentification rÃ©ussie entraÃ®nera lâ€™Ã©mission dâ€™un jeton dâ€™accÃ¨s pour lâ€™API demandÃ©e.

PremiÃ¨rement, activez la mÃ©thode **Identification du client**, puis lâ€™onglet **ParamÃ¨tres avancÃ©s > Types dâ€™autorisation** sur la page ParamÃ¨tres dâ€™application.

Ensuite, autorisez lâ€™application pour lâ€™API a utiliser sous lâ€™onglet **Applications de communication entre machines** sur la page **ParamÃ¨tres** de lâ€™API. Assurez-vous que toutes les permissions nÃ©cessaires sont sÃ©lectionnÃ©es (mais pas plus) et **mettez Ã  jour**. Revenez sous lâ€™onglet **ParamÃ¨tres** et copiez la valeur de **Identifiant**. Ceci doit Ãªtre ajoutÃ© Ã  une clÃ© `AUTH0_MANAGEMENT_AUDIENCE` dans votre fichier `.env`.

Demandez un jeton dâ€™accÃ¨s pour lâ€™API en utilisant lâ€™exemple ci-dessousÂ :

```php lines
// ðŸ‘† We're continuing from the "getting started" guide linked in "Prerequisites" above.

// Begin a client credentials exchange:
$response = $auth0->authentication()->clientCredentials([
    'audience' => $_ENV['AUTH0_MANAGEMENT_AUDIENCE']
]);

// Does the status code of the response indicate failure?
if ($response->getStatusCode() !== 200) {
    die("Code exchange failed.");
}

// Decode the JSON response into a PHP array:
$response = json_decode(response->$getBody()->__toString(), true, 512, JSON_THROW_ON_ERROR);

// Echo the response to the browser
print_r($response, true);
```

Si la mÃ©thode a rÃ©ussi, vous devriez voir ce qui suitÂ :

``` lines
Array
(
    [access_token] => eyJ0eXAi...eyJpc3Mi...QoB2c24w
    [scope] => read:users read:clients ...
    [expires_in] => 86400
    [token_type] => Bearer
)
```

Consultez [Utilisation de Management API avec Auth0-PHP](/docs/fr-ca/libraries/auth0-php/using-the-management-api-with-auth0-php) pour plus dâ€™informations sur la faÃ§on dâ€™utiliser ce jeton dâ€™accÃ¨s.

## DÃ©connexion dâ€™authentification unique (SSO)

Bien que dÃ©truire la session locale avec `session_destroy()` suffirait Ã  dÃ©sauthentifier un utilisateur de votre application, vous devez aussi fermer la session de votre utilisateur final avec Auth0. Cela garantit que la prochaine fois que lâ€™utilisateur verra un formulaire de connexion Auth0, ses informations dâ€™identification lui seront demandÃ©es pour se connecter..
Tout dâ€™abord, dÃ©terminez oÃ¹ lâ€™utilisateur doit se retrouver une fois la dÃ©connexion terminÃ©e. Enregistrez-le dans les paramÃ¨tres de lâ€™application Auth0 dans le champ Â«Â URL de dÃ©connexion autorisÃ©esÂ Â». Aussi, ajoutez une clÃ© `AUTH0_LOGOUT_RETURN_URL` avec cette URL comme valeur dans votre fichier `.env`
Ajoutez ce qui suit au code de dÃ©connexion de votre applicationÂ :

```php lines
// ðŸ‘† We're continuing from the "getting started" guide linked in "Prerequisites" above.

// Deauthenticate the user's local session in your application.
session_destroy();

// Redirect to Auth0's logout URL to end their Auth0 session:
header("Location: " . $auth0->authentication()->getLogoutLink($_ENV['AUTH0_LOGOUT_RETURN_URL']);
```

## En savoir plus

* [PHPÂ : Premiers pas avec Auth0-PHP](/docs/fr-ca/libraries/auth0-php)
* [PHPÂ : Connexion, dÃ©connexion et restitution des profils utilisateurs avec Auth0-PHP](/docs/fr-ca/libraries/auth0-php/auth0-php-basic-use)
* [PHPÂ : Utiliser Management API avec Auth0-PHP](/docs/fr-ca/libraries/auth0-php/using-the-management-api-with-auth0-php)
* [PHPÂ : valider les jetons WebÂ JSON (JWT) avec Auth0-PHP](/docs/fr-ca/libraries/auth0-php/validating-jwts-with-auth0-php)
* [PHPÂ : DÃ©pannage de votre intÃ©gration Auth0-PHP](/docs/fr-ca/libraries/auth0-php/troubleshoot-auth0-php-library)