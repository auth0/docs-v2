---
title: "Connectez votre application aux fournisseurs d’identité SAML"
permalink: "saml"
'description': "Découvrez comment vous connecter aux fournisseurs d’identité SAML à l’aide d’une connexion d’entreprise."
'og:title': "Connectez votre application aux fournisseurs d’identité SAML"
'og:description': "Découvrez comment vous connecter aux fournisseurs d’identité SAML à l’aide d’une connexion d’entreprise."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Connectez votre application aux fournisseurs d’identité SAML"
'twitter:description': "Découvrez comment vous connecter aux fournisseurs d’identité SAML à l’aide d’une connexion d’entreprise."
---

Auth0 vous permet de créer des connexions de fournisseur d’identité <Tooltip href="/docs/fr-ca/glossary?term=security-assertion-markup-language" tip="Security Assertion Markup Language (SAML)
Protocole normalisé permettant à deux parties d’échanger des informations d’authentification sans mot de passe." cta="Voir le glossaire">SAML</Tooltip> (<Tooltip href="/docs/fr-ca/glossary?term=idp" tip="Fournisseur d’identité (IdP)
Service de stockage et de gestion des identités numériques." cta="Voir le glossaire">IdP</Tooltip>).

## Prérequis

Avant de démarrer :

* [Enregistrez votre application avec Auth0](/docs/fr-ca/get-started/auth0-overview/create-applications).

  + Sélectionnez un **type d’application** approprié.
  + Ajoutez une **URL de rappel autorisée** de **`{https://yourApp/callback}`**.
  + Assurez-vous que les [Types d’autorisation](/docs/fr-ca/get-started/applications/update-grant-types) de votre application comprennent les flux appropriés.
* Choisir le nom de cette connexion d’entreprise

  + L’URL de renvoi (également appelée URL du Service consommateur d'assertions) devient : `https://{yourDomain}/login/callback?connection={yourConnectionName}`
  + L’identité de l’entité devient : `urn:auth0:{yourTenant}:{yourConnectionName}`

## Étapes

Pour connecter votre application à un fournisseur d’identité SAML, vous devez :

1. Saisissez l’URL de renvoi et l’identité de l’entité auprès de l’IdP (pour en savoir plus, consultez [Paramètres de configuration du fournisseur d’identités SAML](/docs/fr-ca/authenticate/protocols/saml/saml-identity-provider-configuration-settings)).
2. [Obtenez le certificat de signature du fournisseur d’identité](#get-the-signing-certificate-from-the-idp) et [convertissez-le en Base64](#convert-signing-certificate-to-base64).
3. [Créez une connexion d’entreprise dans Auth0](#create-an-enterprise-connection-in-auth0).
4. [Activez la connexion d’entreprise pour votre application Auth0](#enable-the-enterprise-connection-for-your-auth0-application).
5. [Établissez des mappages](#set-up-mappings) (inutile dans la plupart des cas).
6. [Testez la connexion](#test-the-connection).

## Obtenir le certificat de signature du fournisseur d’identité

Lorsque vous utilisez la connexion SAML, Auth0 joue le rôle de fournisseur de services. Vous devez donc récupérer un certificat de signature X.509 auprès du fournisseur d’identité SAML (au format PEM ou CER), que vous téléverserez par la suite sur Auth0. Il existe différentes méthodes pour récupérer ce certificat. Si vous avez besoin d’aide, reportez-vous à la documentation de votre fournisseur d’identité (IdP).

### Convertir le certificat de signature en Base64

Vous pouvez utiliser <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip> ou le <Tooltip href="/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> pour téléverser le certificat de signature X.509. Si vous utilisez Management API, vous devez convertir le fichier en Base64. Pour y parvenir, utilisez soit un [outil en ligne simple à utiliser](https://www.base64decode.org/) ou exécutez la commande suivante dans Bash : `cat signing-cert.crt | base64`.

## Créer une connexion d’entreprise dans Auth0

Ensuite, vous devrez créer et configurer une connexion SAML Enterprise dans Auth0 et téléverser votre certificat de signature X.509. Cette tâche peut être effectuée à l’aide du Auth0 Dashboard (Tableau de bord Auth0) ou de Management API.

### Créer une connexion entreprise à l’aide du Tableau de bord

1. Naviguez vers [Auth0 Dashboard > Authentification > Entreprise](https://manage.auth0.com/#/connections/enterprise), trouvez **SAML**, et sélectionnez son `+`.

   <Frame>![Dashboard (Tableau de bord) - Connections (Connexions) - Enterprise (Entreprise)](/images/fr-ca/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/4effc408fd5dda9818d307c7b798243c/Enterprise_Connections_-_FR.png)</Frame>

2. Saisissez les détails de votre connexion et sélectionnez **Créer :**

<table class="table"><thead>
<tr>
<th>Champ</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Nom de la connexion</strong></td>
<td>Identifiant logique pour votre connexion; il doit être unique pour votre locataire et le même nom que celui utilisé lors de la définition de l’URL de renvoi et de l’ID de l’entité à l’IdP. Une fois défini, ce nom ne peut être modifié.</td>
</tr>
<tr>
<td><strong>URL de connexion</strong></td>
<td>URL de connexion unique SAML.</td>
</tr>
<tr>
<td><strong>Certificat de signature X.509</strong></td>
<td>Certificat de signature (encodé au format PEM ou CER) que vous avez récupéré de l’IdP plus tôt dans ce processus.</td>
</tr>
<tr>
<td><strong>Activer la déconnexion</strong></td>
<td>Lorsqu’activé, une URLde déconnexion particulière peut être précisée. Autrement, l’URL de connexion par défaut est utilisée.</td>
</tr>
<tr>
<td><strong>URL de déconnexion</strong> (facultatif)</td>
<td>URL de déconnexion unique SAML.</td>
</tr>
<tr>
<td><strong>Attribut de l’ID de l’utilisateur</strong> (facultatif)</td>
<td>Attribut dans le jeton SAML qui sera mappé à la propriété `user_id` dans Auth0.</td>
</tr>
<tr>
<td><strong>Mode de dépannage</strong></td>
<td>Lorsque ce mode est activé, une journalisation plus détaillée sera effectuée au cours du processus d’authentification.</td>
</tr>
<tr>
<td><strong>Requête de signature</strong></td>
<td>Lorsque cette option est activée, la requête d’authentification sera signée. (Assurez-vous de télécharger et de fournir le certificat fourni afin que le fournisseur SAML IdP puisse valider les assertions de la signature.)</td>
</tr>
<tr>
<td><strong>Algorithme de requête de signature</strong></td>
<td>L’algorithme utilisé par Auth0 pour signer les assertions SAML.</td>
</tr>
<tr>
<td><strong>Algorithme de signature du résumé de la requête</strong></td>
<td>L’algorithme qu’Auth0 utilisera pour le résumé de la requête de signature.</td>
</tr>
<tr>
<td><strong>Liaison du protocole</strong></td>
<td>Liaison HTTP prise en charge par l’IdP.</td>
</tr>
<tr>
<td><strong>Modèle de requête</strong> (facultatif)</td>
<td>Modèle qui formatte la requête SAML.</td>
</tr>
</tbody>
</table>

   <Frame>![Configuration des paramètres SAML](/images/fr-ca/cdy7uua7fh8z/7hvlp8kjva9uFzm5nwsBTQ/0be628f2751596ab6e751643d4cc9c9c/2025-02-25_09-41-09.png)</Frame>

3. Dans l’affichage **Provisioning (Fourniture)**, configurez comment les profils utilisateurs sont créés et mis à jour dans Auth0.

<table class="table"><thead>
<tr>
<th>Champ</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Synchroniser les attributs du profil utilisateur à chaque connexion</strong></td>
<td>Lorsqu’il est activé, Auth0 synchronise automatiquement les données du profil utilisateur avec chaque connexion utilisateur, garantissant ainsi que les modifications apportées à la source de connexion sont automatiquement mises à jour dans Auth0.</td>
</tr>
<tr>
<td><strong>Synchroniser les profils utilisateur à l’aide du SCIM</strong></td>
<td>Lorsqu’il est activé, Auth0 permet de synchroniser les données du profil utilisateur à l’aide de SCIM. Pour plus d’informations, veuillez consultez <a href="https://auth0.com/docs/authenticate/protocols/scim/configure-inbound-scim">Configurer le SCIM entrant)</a>.</td>
</tr>
</tbody>
</table>
4. Dans l’affichage **Expérience de connexion**, configurez la façon dont les utilisateurs se connectent avec cette connexion.

<table class="table"><thead>
<tr>
<th><strong>Champ</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Découverte du domaine d’origine</strong></td>
<td>Compare le domaine de l’adresse courriel de l’utilisateur avec les domaines du fournisseur d’identité fourni. Pour plus d’informations, lisez <a href="https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first">Configurer l’authentification Identifier First </a></td>
</tr>
<tr>
<td><strong>Afficher le bouton de connexion</strong></td>
<td>Cette option affiche les choix suivants pour personnaliser le bouton de connexion de votre application.</td>
</tr>
<tr>
<td><strong>Nom d’affichage du bouton</strong> (Facultatif)</td>
<td>Texte utilisé pour personnaliser le bouton de connexion pour la connexion universelle. Lorsque défini, le bouton affiche : Continuer avec \{Nom d’affichage du bouton}.</td>
</tr>
<tr>
<td><strong>Logo du bouton URL</strong> (Facultatif)</td>
<td>URL de l’image utilisée pour personnaliser le bouton de connexion pour la connexion universelle. Lorsque défini, le bouton de connexion de la connexion universelle affiche l’image sous la forme d’un carré de 20 px sur 20 px.</td>
</tr>
</tbody>
</table>

   <Callout icon="file-lines" color="#0EA5E9" iconType="regular">

   Les champs optionnels ne sont disponibles qu’avec connexion universelle. Les clients utilisant la connexion classique ne verront pas le bouton Ajouter, le nom d’affichage du bouton ou l’URL du logo du bouton.

   </Callout>

5. Si vous disposez des autorisations administratives appropriées pour terminer l’intégration, cliquez sur **Continuer** pour en apprendre davantage sur les paramètres personnalisés nécessaires à la configuration de votre fournisseur d’identité. Autrement, fournissez l’URL donnée à votre administrateur pour lui permettre d’ajuster les paramètres requis.

### Créer une connexion d’entreprise à l’aide de Management API

Vous pouvez également utiliser [Management API](/docs/fr-ca/api/management/v2) pour créer votre connexion SAML. Pour ce faire, vous pouvez choisir de spécifier manuellement chaque champ de configuration SAML ou de spécifier un document de métadonnées SAML contenant les valeurs de configuration.

#### Créer une connexion avec les valeurs spécifiées

Faites un appel `POST` au [point de terminaison Créer une connexion](/docs/fr-ca/api/management/v2#!/Connections/patch_connections_by_id). Assurez-vous de remplacer les paramètres fictifs `MGMT_API_ACCESS_TOKEN`, `CONNECTION_NAME`, `SIGN_IN_ENDPOINT_URL`, `SIGN_OUT_ENDPOINT_URL`, et `BASE64_SIGNING_CERT` avec votre jeton d’accès à Management API, nom de connexion, URL de connexion, URL de déconnexion, et le certificat de connexion encodé Base64 (en format PEM ou CER), respectivement.

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/connections' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "strategy": "samlp", "name": "CONNECTION_NAME", "options": { "signInEndpoint": "SIGN_IN_ENDPOINT_URL", "signOutEndpoint": "SIGN_OUT_ENDPOINT_URL", "signatureAlgorithm": "rsa-sha256", "digestAlgorithm": "sha256", "fieldsMap": {}, "signingCert": "BASE64_SIGNING_CERT" } }'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/connections");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/connections"

	payload := strings.NewReader("{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/connections")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }")
  .asString();
```

```javascript Node.JS lines expandable
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/connections',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {
    strategy: 'samlp',
    name: 'CONNECTION_NAME',
    options: {
      signInEndpoint: 'SIGN_IN_ENDPOINT_URL',
      signOutEndpoint: 'SIGN_OUT_ENDPOINT_URL',
      signatureAlgorithm: 'rsa-sha256',
      digestAlgorithm: 'sha256',
      fieldsMap: {},
      signingCert: 'BASE64_SIGNING_CERT'
    }
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"strategy": @"samlp",
                              @"name": @"CONNECTION_NAME",
                              @"options": @{ @"signInEndpoint": @"SIGN_IN_ENDPOINT_URL", @"signOutEndpoint": @"SIGN_OUT_ENDPOINT_URL", @"signatureAlgorithm": @"rsa-sha256", @"digestAlgorithm": @"sha256", @"fieldsMap": @{  }, @"signingCert": @"BASE64_SIGNING_CERT" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/connections",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("POST", "/{yourDomain}/api/v2/connections", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/connections")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "strategy": "samlp",
  "name": "CONNECTION_NAME",
  "options": [
    "signInEndpoint": "SIGN_IN_ENDPOINT_URL",
    "signOutEndpoint": "SIGN_OUT_ENDPOINT_URL",
    "signatureAlgorithm": "rsa-sha256",
    "digestAlgorithm": "sha256",
    "fieldsMap": [],
    "signingCert": "BASE64_SIGNING_CERT"
  ]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

<table class="table"><thead>
<tr>
<th>Valeur</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="/docs/fr-ca/api/management/v2/tokens">Jeton d’accès à Management API</a> avec la permission `create:connections`.</td>
</tr>
<tr>
<td>`CONNECTION_NAME`</td>
<td></td>
</tr>
<tr>
<td>`SIGN_IN_ENDPONT_URL`</td>
<td>SAML single login URL (Connexion à authentifiant unique SAML) pour la connexion à créer.</td>
</tr>
<tr>
<td>`SIGN_OUT_ENDPOINT_URL`</td>
<td>SAML single logout URL (Déconnexion à authentifiant unique SAML) pour la connexion à créer.</td>
</tr>
<tr>
<td>‘BASE64_SIGNING_CERT`</td>
<td>Certificat de signature X.509 (encodé en PEM ou CER) que vous avez obtenue de l’IdP.</td>
</tr>
</tbody>
</table>

Ou, dans JSON :

```json lines
{
	"strategy": "samlp",
  	"name": "CONNECTION_NAME",
  	"options": {
    	"signInEndpoint": "SIGN_IN_ENDPOINT_URL",
    	"signOutEndpoint": "SIGN_OUT_ENDPOINT_URL",
    	"signatureAlgorithm": "rsa-sha256",
    	"digestAlgorithm": "sha256",
    	"fieldsMap": {
     		...
    	},
    	"signingCert": "BASE64_SIGNING_CERT"
  	}
}
```

#### Créer une connexion à l’aide des métadonnées SAML

Au lieu de spécifier chaque champ de configuration SAML, vous pouvez spécifier un document de métadonnées SAML qui contient les valeurs de configuration. Lorsque vous précisez un document de métadonnées SAML, vous pouvez fournir soit le contenu XML du document (`metadataXml`) ou l’URL du document (`metadataUrl`). Lorsque vous fournissez l’URL, le contenu ne sera téléchargé qu’une fois; la connexion ne se reconfigurera pas automatiquement si le contenu de l’URL change à l’avenir.

##### Fournir des métadonnées sur le contenu des documents

Utilisez l’option `metadataXml` pour fournir le contenu du document :

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/connections' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "strategy": "samlp", "name": "CONNECTION_NAME", "options": { "metadataXml": "<EntityDescriptor entityID='\''urn:saml-idp'\'' xmlns='\''urn:oasis:names:tc:SAML:2.0:metadata'\''>...</EntityDescriptor>" } }'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/connections");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/connections"

	payload := strings.NewReader("{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } }")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/connections")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } }")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/connections',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {
    strategy: 'samlp',
    name: 'CONNECTION_NAME',
    options: {
      metadataXml: '<EntityDescriptor entityID=\'urn:saml-idp\' xmlns=\'urn:oasis:names:tc:SAML:2.0:metadata\'>...</EntityDescriptor>'
    }
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"strategy": @"samlp",
                              @"name": @"CONNECTION_NAME",
                              @"options": @{ @"metadataXml": @"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/connections",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
iimport http.client

conn = http.client.HTTPSConnection("")

payload = "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("POST", "/{yourDomain}/api/v2/connections", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/connections")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } }"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "strategy": "samlp",
  "name": "CONNECTION_NAME",
  "options": ["metadataXml": "<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>"]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

##### Fournir l’URL d’un document de métadonnées

Utilisez l’option `metadataUrl` pour fournir l’URL du document :

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/connections' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "strategy": "samlp", "name": "CONNECTION_NAME", "options": { "metadataUrl": "https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX" } }'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/connections");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/connections"

	payload := strings.NewReader("{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/connections")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/connections',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {
    strategy: 'samlp',
    name: 'CONNECTION_NAME',
    options: {
      metadataUrl: 'https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX'
    }
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"strategy": @"samlp",
                              @"name": @"CONNECTION_NAME",
                              @"options": @{ @"metadataUrl": @"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/connections",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("POST", "/{yourDomain}/api/v2/connections", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/connections")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "strategy": "samlp",
  "name": "CONNECTION_NAME",
  "options": ["metadataUrl": "https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX"]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Lorsque vous fournissez l’URL, le contenu ne sera téléchargé qu’une fois; la connexion ne se reconfigurera pas automatiquement si le contenu de l’URL change à l’avenir.

##### Actualiser les informations de connexion existantes avec l’URL des métadonnées

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Ce processus ne fonctionne que si la connexion a été créée manuellement avec `metadataUrl`.

</Callout>

Si vous disposez d’une implémentation B2B et que la fédération vers Auth0 est assurée par votre propre fournisseur d’identité SAML, il vous faudra peut-être actualiser les informations de connexion stockées dans Auth0, par exemple en cas de modification du certificat de signature, de l’URL des points de terminaison ou des nouveaux champs d’assertion. Auth0 le fait automatiquement pour les connexions ADFS, mais pas pour les connexions SAML.

Vous pouvez créer un processus de traitement par lots (tâche cron) pour effectuer une actualisation périodique. Le processus peut s’exécuter chaque quelques semaines et réalisez un appel PATCH au point de terminaison `/api/v2/connections/CONNECTION_ID`, passant un corps contenant `{options: {metadataUrl: ’$URL’}}` où `$URL` est identique à l’URL de métadonnées avec laquelle vous avez créé la connexion. L’URL des métadonnées permet de créer une nouvelle connexion temporaire, puis de comparer les propriétés de l’ancienne et de la nouvelle connexion. Si vous constatez une différence, mettez à jour la nouvelle connexion, puis supprimez la connexion temporaire.

1. Créez une connexion SAML avec `options.metadataURL`. L’objet de connexion sera alimenté par les informations contenues dans les métadonnées.
2. Mettez à jour le contenu des métadonnées dans l’URL.
3. Envoyez PATCH au point de terminaison `/api/v2/connections/CONNECTION_ID` avec `{options: {metadataUrl: ’$URL’}}`. L’objet de connexion est maintenant mis à jour avec le nouveau contenu des métadonnées.

<Warning>

Si vous utilisez le paramètre `options`, vous écrasez l’intégralité de l’objet `options`. Assurez-vous que tous les paramètres sont présents.

</Warning>

## Spécifier un ID d’entité personnalisé

Pour préciser un ID d’entité personnalisé, utilisez Management API pour remplacer l’ID par défaut `urn:auth0:YOUR_TENANT:YOUR_CONNECTION_NAME`. Établissez la propriété `connection.options.entityID` au moment de créer la connexion ou lors de la mise à jour d’une connexion existante.

Vous pouvez utiliser l’exemple JSON ci-dessous pour créer une nouvelle connexion SAML à l’aide de l’URL de métadonnées du fournisseur d’identité SAML, tout en spécifiant un identifiant d’entité personnalisé. L’ID de l’entité reste unique puisqu’il est créé avec le nom de la connexion.

```json lines
{
  "strategy": "samlp", 
  "name": "{yourConnectionName}", 
  "options": { 
    "metadataUrl": "https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX",
    "entityId": "urn:your-custom-sp-name:{yourConnectionName}"
  }
}
```

## Permettre une connexion entreprise pour votre application Auth0

Pour utiliser votre nouvelle connexion d’entreprise SAML, vous devez premièrement [activer la connexion](/docs/fr-ca/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) pour vos applications Auth0.

## Établir des mappages

<Warning>

Si vous configurez une connexion SAML d’entreprise pour un serveur PingFederate non standard, vous **devez** mettre à jour les mappages d’attributs.

</Warning>

Sélectionnez l’affiihage **Mappages**, saisissez les mappages entre `{}`, et sélectionnez **Enregistrer**.

<Frame>![Configuration des mappages SAML](/images/fr-ca/cdy7uua7fh8z/3matGqveShEDX89p8Bcmwr/aa0ab207b7e63b9b28d423f5bb62d826/2025-02-25_09-34-57.png)</Frame>

**Mappages pour les serveurs PingFederate non standard :**

```json lines
{
    "user_id": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier",
    "email": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier"
}
```

**Mappages pour <Tooltip href="/docs/fr-ca/glossary?term=single-sign-on" tip="Authentification unique (SSO)
Service qui, après qu’un utilisateur se soit connecté à une application, le connecte automatiquement à d’autres applications." cta="Voir le glossaire">SSO</Tooltip> Circle**

```json lines
{
  "email": "EmailAddress",
  "given_name": "FirstName",
  "family_name": "LastName"
}
```

**Mettre en correspondance l’une des deux revendications avec un attribut d’utilisateur**

```json lines
{
  "given_name": [
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"
  ]
}
```

**Comment mettre en correspondance un identifiant de nom avec un attribut d’utilisateur?**

```json lines
{
  "user_id": [
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn",
    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"
  ]
}
```

## Tester la connexion

Vous êtes maintenant prêt à [tester votre connexion](/docs/fr-ca/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).

## Configurer la révocation globale des jetons

Ce type de connexion prend en charge un point de terminaison de révocation globale des jetons, qui permet à un fournisseur d’identité conforme de révoquer les sessions utilisateur Auth0, de révoquer les jetons d’actualisation et de déclencher la déconnexion du canal d’appui pour les applications utilisant un canal d’appui sécurisé.

Cette fonctionnalité peut être utilisée avec Universal Logout dans Okta Workforce Identity Cloud.

Pour plus d’informations et d’instructions de configuration, consultez [Universal Logout](/docs/fr-ca/authenticate/login/logout/universal-logout).

## En savoir plus

* [Universal Logout](/docs/fr-ca/authenticate/login/logout/universal-logout)