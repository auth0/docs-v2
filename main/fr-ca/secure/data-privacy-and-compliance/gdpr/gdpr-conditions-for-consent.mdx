---
title: "RGPD : Conditions de consentement"
permalink: "gdpr-conditions-for-consent"
'description': "Décrit les fonctionnalités d’Auth0 qui peuvent vous aider à vous conformer aux conditions de consentement des exigences du RGPD."
'og:title': "RGPD : Conditions de consentement"
'og:description': "Décrit les fonctionnalités d’Auth0 qui peuvent vous aider à vous conformer aux conditions de consentement des exigences du RGPD."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "RGPD : Conditions de consentement"
'twitter:description': "Décrit les fonctionnalités d’Auth0 qui peuvent vous aider à vous conformer aux conditions de consentement des exigences du RGPD."
---

Conformément à l’article 7 du RGPD, vous devez demander aux utilisateurs de consentir au traitement de leurs données personnelles sous une forme claire et facilement accessible. Vous devez également montrer que l’utilisateur a consenti et lui fournir un moyen facile de retirer son consentement à tout moment.

Cet article explique comment utiliser les fonctionnalités d’Auth0 pour mettre en place ces exigences.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Le contenu de ces documents ne constitue pas un avis juridique et ne doit pas être considéré comme un substitut à l’assistance juridique. C’est à vous qu’il incombe en dernier ressort de comprendre et de respecter le RGPD, mais Auth0 vous aidera à satisfaire aux exigences du RGPD dans la mesure du possible.

</Callout>

## Demander le consentement

Lors de l’inscription, vous devez demander le consentement de vos utilisateurs. Avec Auth0, vous pouvez enregistrer ces informations avec les métadonnées utilisateur. Plusieurs options sont disponibles en fonction de la façon dont vous utilisez Auth0 pour authentifier vos utilisateurs. Avant de concevoir votre solution à l’aide de métadonnées, assurez-vous de connaître les restrictions. Auth0 limite la taille totale des `user_metadata` à **16 Mo**. Pour en savoir plus, consultez [Noms des champs de métadonnées et types de données](/docs/fr-ca/manage-users/user-accounts/metadata/metadata-fields-data).

<Warning>

Les métadonnées Auth0 ne sont pas un magasin de données sécurisé et ne doivent pas être utilisées pour stocker des renseignements personnels. Cela inclut les secrets, les renseignements personnels à haut risque comme les numéros de sécurité sociale ou les numéros de carte de crédit, etc. Les clients Auth0 sont fortement encouragés à évaluer les données stockées dans les métadonnées et à ne stocker que celles qui sont nécessaires à des fins de gestion des identités et des accès.

</Warning>

### Utiliser Lock

Vous pouvez personnaliser l’interface utilisateur Lock pour afficher des liens vers vos modalités ou vers vos pages de déclaration de confidentialité, ainsi qu’une case de consentement que l’utilisateur doit cocher pour s’inscrire. Cela peut être fait avec l’option Lock `mustAcceptTerm`. Cette propriété, une fois définie sur `true`, affiche une case à cocher à côté des modalités qui doivent être vérifiées avant de procéder à l’inscription. Les modalités peuvent être précisées à l’aide de l’option languageDictionary. Pour en savoir plus, consultez [Configuration de Lock](/docs/fr-ca/libraries/lock/lock-configuration).

Une fois que l’utilisateur accepte et s’inscrit, enregistrez les informations de consentement dans `user_metadata` à l’aide d’une règle qui s’exécutera lors de la première connexion. Pour en savoir plus sur les Règles, lisez [Règles d'Auth0](/docs/fr-ca/customize/rules).

Si vous utilisez des connexions à des réseaux sociaux, l’ajout de champs personnalisés n’est pas une option, mais vous pouvez rediriger l’utilisateur vers une autre page où vous demandez son consentement et des informations supplémentaires, puis vous le redirigez pour terminer la transaction d’authentification. Cela peut être fait avec des règles de redirection. Pour en savoir plus, veuillez consulter l’article [Redirect Users from Within Rules (Rediriger les utilisateurs à partir des règles)](/docs/fr-ca/customize/rules/redirect-users). Une fois le processus d’inscription terminé, enregistrez les informations de consentement dans `user_metadata` en appelant le [point de terminaison **Mise à jour de l’utilisateur**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id) de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

Si vous utilisez des connexions à des réseaux sociaux, l’ajout de champs personnalisés n’est pas une option, mais vous pouvez rediriger l’utilisateur vers une autre page où vous demandez son consentement et des informations supplémentaires, puis vous le redirigez pour terminer la transaction d’authentification. Cela peut être fait avec des règles de redirection. Pour en savoir plus, veuillez consulter l’article [Rediriger les utilisateurs à partir des règles](/docs/fr-ca/customize/rules/redirect-users). Une fois le processus d’inscription terminé, enregistrez les informations de consentement dans `user_metadata` en appelant le [point de terminaison **Mise à jour de l’utilisateur**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id) de Management API.

Pour savoir comment mettre en place l’un de ces scénarios, consultez [RGPD : Suivre le consentement avec Lock](/docs/fr-ca/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-lock).

### Utiliser l’interface utilisateur personnalisée

Si vous utilisez un formulaire d’inscription personnalisé avec une connexion à une base de données, vous devez ajouter un champ supplémentaire à l’écran d’inscription afin de recueillir le consentement de l’utilisateur. Ensuite, appelez le [point de terminaison **Inscription**](/docs/fr-ca/api/authentication#signup) de l’Authentication API afin de créer l’utilisateur dans Auth0. À ce stade, vous pouvez définir les informations de consentement dans le cadre de `user_metadata`.

Si vous utilisez un formulaire d’inscription personnalisé avec des fournisseurs de réseaux sociaux, vous ne pouvez pas définir les informations de consentement de l’utilisateur lors de l’inscription, mais vous pouvez les mettre à jour dès que l’utilisateur est créé. Enregistrez les informations de consentement dans `user_metadata` en appelant le [point de terminaison **Update User (Mise à jour de l’utilisateur)**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id) de Management API.

Si vous utilisez un formulaire d’inscription personnalisé avec des fournisseurs de réseaux sociaux, vous ne pouvez pas définir les informations de consentement de l’utilisateur lors de l’inscription, mais vous pouvez les mettre à jour dès que l’utilisateur est créé. Une fois le processus d’inscription terminé, enregistrez les informations de consentement dans `user_metadata` en appelant le [point de terminaison **Mise à jour de l’utilisateur**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id) de la Management API.

Pour savoir comment mettre en place l’un de ces scénarios, consultez [RGPD : Suivre le consentement avec l’interface utilisateur personnalisée](/docs/fr-ca/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-custom-ui).

### Renouvellement du consentement et migration des utilisateurs

Si vous devez obtenir le consentement des utilisateurs actuels et que vous décidez de les migrer de votre base de données existante vers Auth0, vous pouvez utiliser notre fonction de [migration automatique des utilisateurs](/docs/fr-ca/manage-users/user-migration/configure-automatic-migration-from-your-database). Cette fonction crée un compte Auth0 pour chaque utilisateur qui se connecte pour la première fois (après l’activation) sans que ce dernier ait besoin de réinitialiser son mot de passe. Voici comment procéder :

* Rédiger l’avis que les utilisateurs verront sur la façon dont les données des utilisateurs sont utilisées, combien de temps les données seront utilisées, les droits des utilisateurs, etc., et personnaliser la boîte d’inscription de l’interface utilisateur.
* Déterminer si un nouveau consentement est requis pour vos utilisateurs, en fonction de vos anciennes modalités et de vos certifications de confidentialité antérieures.

Notez que chaque fois que vos conditions générales sont modifiées, vous **devez** demander à nouveau le consentement des utilisateurs.

## Suivi du consentement

Conformément au RGPD, vous devez être en mesure de prouver que l'utilisateur a consenti au traitement de ses données à caractère personnel.

Management API offre également plusieurs options lorsqu’il s’agit de recherche d’utilisateurs et de points de terminaison pour mettre à jour les métadonnées utilisateur ou l’exportation par lots des utilisateurs.

La Management API offre également plusieurs options lorsqu’il s’agit de recherche d’utilisateurs et de points de terminaison pour mettre à jour les métadonnées utilisateur ou l’exportation par lots des utilisateurs.

Pour rechercher un utilisateur à l’aide de son adresse courriel, utilisez le [point de terminaison](/docs/fr-ca/manage-users/user-search/user-search-best-practices) [**Rechercher un utilisateur par courriel**](/docs/fr-ca/manage-users/user-search/user-search-best-practices).

### Recherche d’utilisateurs par adresse courriel

Pour rechercher un utilisateur à l’aide de son adresse courriel, utilisez le [point de terminaison **Rechercher un utilisateur par courriel**](/docs/fr-ca/manage-users/user-search/user-search-best-practices).

Définissez le paramètre de requête **fields** sur `user_metadata` afin de limiter les champs retournés. De cette façon, seul le user_metadata sera retourné à la place du profil utilisateur complet.

Exemple de demande :

<CodeGroup>
```bash cURL lines
curl --request GET \
  --url 'https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata' \
  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.get("https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata")
  .header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/users-by-email',
  params: {email: 'USER_EMAIL_ADDRESS', fields: 'user_metadata'},
  headers: {authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN" }

conn.request("GET", "/{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Exemple de réponse :

```json lines
[
  {},
  {
    "user_metadata": {
      "consent": {
	    "given": true,
	    "date": "01/23/2018",
	    "text_details": "some-url"
	  }
    }
  }
]
```

### Recherche d’utilisateurs par ID

Pour rechercher un utilisateur à l’aide de son ID, utilisez le [point de terminaison **Obtenir un utilisateur**](/docs/fr-ca/manage-users/user-search/user-search-best-practices).

Définissez le paramètre de requête **fields** sur `user_metadata` afin de limiter les champs retournés. De cette façon, seul le `user_metadata` sera retourné à la place du profil utilisateur complet.

Exemple de demande :

<CodeGroup>
```bash cURL lines
curl --request GET \
  --url 'https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata' \
  --header 'authorization: Bearer {yourMgmtApiAccessToken}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.get("https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata")
  .header("authorization", "Bearer {yourMgmtApiAccessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/users/%7ByourUserID%7D',
  params: {fields: 'user_metadata'},
  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtApiAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtApiAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer {yourMgmtApiAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Exemple de réponse :

```json lines
{
  "user_metadata": {
    "consent": {
	    "given": true,
	    "date": "01/23/2018",
	    "text_details": "some-url"
  	}
  }
}
```

### Mise à jour de l’information de consentement

Pour mettre à jour la valeur des `user_metadata` d’un utilisateur, utilisez le [point de terminaison **Mettre à jour un utilisateur**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id).

La façon dont vous structurez votre demande dépend de la façon dont vous avez structuré vos métadonnées : en tant que racine ou en tant que propriétés internes.

Si vos métadonnées sont stockées en tant que propriétés racines :

```json lines
{
  "consentGiven": true,
  "consentDetails": "some-url"
}
```

Si vos métadonnées sont stockées en tant que propriétés internes :

```json lines
{
  "consent": {
    "given": true,
    "text_details": "some-url"
  }
}
```

#### Mettre à jour la propriété racine

Les mises à jour des propriétés de niveau racine sont fusionnées, il vous suffit donc d’envoyer la valeur du champ que vous souhaitez mettre à jour. Par exemple, supposons que nous voulions ajouter une date de consentement et la définir sur `2018-01-23`.

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/users/USER_ID' \
  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"user_metadata":{"consentDate":"01/24/2018"}}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/USER_ID"

	payload := strings.NewReader("{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.patch("https://{yourDomain}/api/v2/users/USER_ID")
  .header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/users/USER_ID',
  headers: {
    authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',
    'content-type': 'application/json'
  },
  data: {user_metadata: {consentDate: '01/24/2018'}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"user_metadata": @{ @"consentDate": @"01/24/2018" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}"

headers = {
    'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/users/USER_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/USER_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["user_metadata": ["consentDate": "01/24/2018"]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Ceci ajoutera une nouvelle propriété au profil utilisateur, **user_metadata.consentDate**, qui contiendra la date à laquelle le client a donné son consentement. La réponse sera le profil utilisateur complet. Les métadonnées mises à jour se présenteront comme suit :

```json lines
{
  "consentGiven": true,
  "consentDate": "01/23/2018",
  "consentDetails": "some-url"
}
```

#### Mettre à jour la propriété interne

Pour mettre à jour une propriété interne, vous devez envoyer l’ensemble de l'objet de métadonnées, même si vous ne mettez pas à jour plus d'une propriété. Si vous n’envoyez pas l’objet complet, Auth0 supprimera les propriétés existantes.

Ajoutons une propriété interne pour la date de consentement et fixons-la à `2018-01-23`.

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/users/USER_ID' \
  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"user_metadata":{"consent": {"given":true, "date":"01/23/2018", "text_details":"some-url"}}}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/USER_ID"

	payload := strings.NewReader("{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.patch("https://{yourDomain}/api/v2/users/USER_ID")
  .header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/users/USER_ID',
  headers: {
    authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',
    'content-type': 'application/json'
  },
  data: {
    user_metadata: {consent: {given: true, date: '01/23/2018', text_details: 'some-url'}}
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"user_metadata": @{ @"consent": @{ @"given": @YES, @"date": @"01/23/2018", @"text_details": @"some-url" } } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}"

headers = {
    'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/users/USER_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/USER_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["user_metadata": ["consent": [
      "given": true,
      "date": "01/23/2018",
      "text_details": "some-url"
    ]]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Ceci ajoutera une nouvelle propriété au profil utilisateur, **user_metadata.consent.date,**, qui contiendra la date à laquelle le client a donné son consentement. La réponse sera le profil utilisateur complet. Les métadonnées mises à jour se présenteront comme suit :

Pour exporter une liste de vos utilisateurs à l’aide de Management API, utilisez le [point de terminaison](/docs/fr-ca/manage-users/user-search/user-search-best-practices) [**User Export (Exportation d’utilisateurs)**](/docs/fr-ca/manage-users/user-search/user-search-best-practices).

### Exporter l’information sur le consentement

Pour exporter une liste de vos utilisateurs à l’aide de Management API, utilisez le point de terminaison [**User Export**](/docs/fr-ca/manage-users/user-search/user-search-best-practices).

Ce point de terminaison crée une tâche qui exporte tous les utilisateurs associés à une connexion. Vous aurez besoin de l’ID de la connexion. Pour trouver cet ID, utilisez le [point de terminaison **Obtenir les connexions**](/docs/fr-ca/api/management/v2#!/Connections/get_connections). Vous pouvez définir le paramètre **name** sur le nom de la connexion pour récupérer uniquement celle-ci.

Une fois que vous disposez de l’ID de connexion et d’un jeton d’accès pour Management API, vous êtes prêt à commencer à exporter des utilisateurs. Pour voir un exemple de requête et de réponse, veuillez consulter l’article [Importer et exporter des utilisateurs](/docs/fr-ca/manage-users/user-migration). Pour savoir comment obtenir un jeton d’accès pour Management API, veuillez consulter l’article [Jetons d’accès à Management API](/docs/fr-ca/secure/tokens/access-tokens/management-api-access-tokens).

Vous devez également :

* Déterminer la façon dont vous souhaitez suivre le consentement. Nous vous recommandons d’inclure des informations non seulement sur la date à laquelle l’utilisateur a donné son consentement, mais aussi sur la version des modalités à laquelle l’utilisateur a donné son consentement. Nous recommandons également d’inclure un tableau pour conserver des informations sur les utilisateurs qui retirent leur autorisation (rappelez-vous que l’utilisateur peut donner son consentement et le retirer à plusieurs reprise).
* Choisissez où vous voulez stocker le consentement : dans la base de données Auth0 ou ailleurs.

## Retirer son consentement

L’utilisateur doit avoir la possibilité de retirer son consentement en utilisant votre application. Cette option doit être facilement accessible et clairement indiquée. Lorsque l’utilisateur décide de retirer son consentement, vous devez prendre des mesures.

Tout d’abord, vous devez décider comment vous allez gérer le retrait du consentement : allez-vous supprimer les utilisateurs ou les marquer comme supprimés?

### Supprimer un utilisateur

Pour supprimer un utilisateur, utilisez le [point de terminaison **Supprimer un utilisateur**](/docs/fr-ca/api/management/v2#!/Users/delete_users_by_id).

<CodeGroup>
```bash cURL lines
curl --request DELETE \
  --url 'https://{yourDomain}/api/v2/users/USER_ID' \
  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.DELETE);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
IRestResponse response = client.Execute(request);
```

```go Go lines
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/USER_ID"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.delete("https://{yourDomain}/api/v2/users/USER_ID")
  .header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'DELETE',
  url: 'https://{yourDomain}/api/v2/users/USER_ID',
  headers: {authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"DELETE"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "DELETE",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN" }

conn.request("DELETE", "/{yourDomain}/api/v2/users/USER_ID", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/USER_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Delete.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = ["authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Le corps de la réponse de ce point de terminaison est vide. Ainsi, si vous souhaitez confirmer que l’utilisateur a été supprimé, essayez de récupérer l’utilisateur à l’aide de son adresse courriel. Si le point de terminaison renvoie une erreur, votre appel de suppression de l’utilisateur a réussi.

### Marquer l’utilisateur comme supprimé

Si vous ne souhaitez pas supprimer l’utilisateur, marquez son profil comme supprimé à l’aide du [point de terminaison **app_metadata**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id). Ajoutez ensuite du code qui fera échouer le processus d’authentification pour tout utilisateur dont le profil est marqué comme supprimé.

Cela vous permet de conserver un enregistrement des utilisateurs supprimés pour une utilisation ultérieure.

#### Marquer le profil

Pour marquer un utilisateur comme supprimé, utilisez app_metadata. Dans l’exemple suivant, nous allons vous montrer comment ajouter une propriété appelée **supprimée** au champ **app_metadata**. Cela vous permet de configurer le processus d’authentification pour traiter toutes les utilisations avec la propriété supprimée définie sur true.

Pour mettre à jour les métadonnées d’un utilisateur, utilisez le [point de terminaison **Mettre à jour un utilisateur**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id).

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/users/USER_ID' \
  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"app_metadata":{"deleted":true}}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/USER_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"app_metadata\":{\"deleted\":true}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/USER_ID"

	payload := strings.NewReader("{\"app_metadata\":{\"deleted\":true}}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.patch("https://{yourDomain}/api/v2/users/USER_ID")
  .header("authorization", "Bearer YOUR_MGMT_API_ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{\"app_metadata\":{\"deleted\":true}}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/users/USER_ID',
  headers: {
    authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',
    'content-type': 'application/json'
  },
  data: {app_metadata: {deleted: true}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_MGMT_API_ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"app_metadata": @{ @"deleted": @YES } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/USER_ID"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/USER_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{\"app_metadata\":{\"deleted\":true}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\"app_metadata\":{\"deleted\":true}}"

headers = {
    'authorization': "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/users/USER_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/USER_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{\"app_metadata\":{\"deleted\":true}}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer YOUR_MGMT_API_ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["app_metadata": ["deleted": true]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/USER_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

#### Désactiver la connexion pour les utilisateurs marqués

Ensuite, vous devez désactiver la connexion pour les utilisateurs marqués comme supprimés. Pour ce faire, vous allez ajouter une règle (un extrait de code en JavaScript qui s’exécute dans le cadre du pipeline d’authentification).

1. Accédez à [Auth0 Dashboard > Auth Pipeline Règles](https://manage.auth0.com/#/rules) et créez une règle,
2. Copiez le script ci-dessous :

   ```javascript lines
   function (user, context, callback) {
     user.app_metadata = user.app_metadata || {};
     if (user.app_metadata.deleted){
     	return callback(new UnauthorizedError('Access denied (deleted user)'));
     }
     callback(null, user, context);
   }
   ```

   

   

   Le script effectue les opérations suivantes :
   1. Vérifie la valeur de la propriété de métadonnées **supprimée** (`user.app_metadata.deleted`).
   2. Renvoie une erreur `Access denied (deleted user)` à votre application si `user.app_metadata.deleted = true`.
3. Donnez un nom à votre règle et enregistrez vos modifications.

Vous devez également :

* Vous assurer que la pièce de retrait du consentement est suffisamment granulaire.
* Configurer au sein de l’application la zone où les clients retireront leur consentement.

## En savoir plus

* [RGPD : Minimisation des données](/docs/fr-ca/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)
* [RGPD : Portabilité des données](/docs/fr-ca/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)
* [RGPD : Protéger et sécuriser les données des utilisateurs](/docs/fr-ca/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)
* [RGPD : Droit d’accès, de rectification et d’effacement des données](/docs/fr-ca/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)