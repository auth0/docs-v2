---
title: "Ajouter des attributs d’utilisateur à la liste rouge"
permalink: "denylist"
'description': "Décrit comment identifier les attributs utilisateur que vous ne souhaitez pas enregistrer dans les bases de données Auth0."
'og:title': "Ajouter des attributs d’utilisateur à la liste rouge"
'og:description': "Décrit comment identifier les attributs utilisateur que vous ne souhaitez pas enregistrer dans les bases de données Auth0."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Ajouter des attributs d’utilisateur à la liste rouge"
'twitter:description': "Décrit comment identifier les attributs utilisateur que vous ne souhaitez pas enregistrer dans les bases de données Auth0."
---

S’il existe des champs utilisateur qui ne doivent pas être stockés dans les bases de données Auth0 pour des raisons de confidentialité, vous pouvez les ajouter à la liste rouge. Pour ajouter des attributs à la liste rouge, effectuez un appel `PATCH` au point de terminaison de connexion de mise à jour de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

1. Obtenez un jeton d’accès valide pour accéder au [point de terminaison](/docs/fr-ca/api/management/v2#!/Connections/patch_connections_by_id)`/patch_connections_by_id`. Le jeton doit inclure la permission `update:connections`. Pour plus de détails, veuillez consulter [Jetons d’accès à Management API](/docs/fr-ca/secure/tokens/access-tokens/management-api-access-tokens).
2. Avec le jeton d’accès et la liste des attributs à refuser, appelez l’API. Voici un exemple de requête HTTP qui refuse deux attributs : l’origine ethnique et le genre. Gardez à l’esprit que vous devez récupérer l’objet options et envoyer l’objet entier dans votre requête PATCH, car il n’y a pas de « fusion » si vous ne mettez à jour qu’une ou deux valeurs.

   <CodeGroup>
   ```bash cURL lines
    curl --request PATCH \
      --url 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID' \
      --header 'authorization: Bearer YOUR_TOKEN' \
      --header 'content-type: application/json' \
      --data '{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}'
   ```
   ```csharp C# lines
    var client = new RestClient("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID");
    var request = new RestRequest(Method.PATCH);
    request.AddHeader("authorization", "Bearer YOUR_TOKEN");
    request.AddHeader("content-type", "application/json");
    request.AddParameter("application/json", "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}", ParameterType.RequestBody);
    IRestResponse response = client.Execute(request);
   ```

   ```go Go lines expandable
    package main

    import (
      "fmt"
      "strings"
      "net/http"
      "io/ioutil"
    )

    func main() {

      url := "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID"

      payload := strings.NewReader("{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}")

      req, _ := http.NewRequest("PATCH", url, payload)

      req.Header.Add("authorization", "Bearer YOUR_TOKEN")
      req.Header.Add("content-type", "application/json")

      res, _ := http.DefaultClient.Do(req)

      defer res.Body.Close()
      body, _ := ioutil.ReadAll(res.Body)

      fmt.Println(res)
      fmt.Println(string(body))

    }
   ```
   ```java Java lines
    HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")
      .header("authorization", "Bearer YOUR_TOKEN")
      .header("content-type", "application/json")
      .body("{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}")
      .asString();
   ```

   ```javascript Node.JS lines
    var axios = require("axios").default;

    var options = {
      method: 'PATCH',
      url: 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID',
      headers: {authorization: 'Bearer YOUR_TOKEN', 'content-type': 'application/json'},
      data: {options: {non_persistent_attrs: ['ethnicity', 'gender']}}
    };

    axios.request(options).then(function (response) {
      console.log(response.data);
    }).catch(function (error) {
      console.error(error);
    });
   ```
   ```obj-c Obj-C lines expandable
    #import <Foundation/Foundation.h>

    NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_TOKEN",
                              @"content-type": @"application/json" };
    NSDictionary *parameters = @{ @"options": @{ @"non_persistent_attrs": @[ @"ethnicity", @"gender" ] } };

    NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID"]
                                                          cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                      timeoutInterval:10.0];
    [request setHTTPMethod:@"PATCH"];
    [request setAllHTTPHeaderFields:headers];
    [request setHTTPBody:postData];

    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                    if (error) {
                                                        NSLog(@"%@", error);
                                                    } else {
                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                        NSLog(@"%@", httpResponse);
                                                    }
                                                }];
    [dataTask resume];
   ```

   ```php PHP lines expandable
    $curl = curl_init();

    curl_setopt_array($curl, [
      CURLOPT_URL => "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID",
      CURLOPT_RETURNTRANSFER => true,
      CURLOPT_ENCODING => "",
      CURLOPT_MAXREDIRS => 10,
      CURLOPT_TIMEOUT => 30,
      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
      CURLOPT_CUSTOMREQUEST => "PATCH",
      CURLOPT_POSTFIELDS => "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}",
      CURLOPT_HTTPHEADER => [
        "authorization: Bearer YOUR_TOKEN",
        "content-type: application/json"
      ],
    ]);

    $response = curl_exec($curl);
    $err = curl_error($curl);

    curl_close($curl);

    if ($err) {
      echo "cURL Error #:" . $err;
    } else {
      echo $response;
    }
   ```
   ```python Python lines
    import http.client

    conn = http.client.HTTPSConnection("")

    payload = "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}"

    headers = {
        'authorization': "Bearer YOUR_TOKEN",
        'content-type': "application/json"
        }

    conn.request("PATCH", "/{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID", payload, headers)

    res = conn.getresponse()
    data = res.read()

    print(data.decode("utf-8"))
   ```

   ```ruby Ruby lines
    require 'uri'
    require 'net/http'
    require 'openssl'

    url = URI("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")

    http = Net::HTTP.new(url.host, url.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Patch.new(url)
    request["authorization"] = 'Bearer YOUR_TOKEN'
    request["content-type"] = 'application/json'
    request.body = "{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}"

    response = http.request(request)
    puts response.read_body
   ```
   ```swift Swift lines expandable
    import Foundation

    let headers = [
      "authorization": "Bearer YOUR_TOKEN",
      "content-type": "application/json"
    ]
    let parameters = ["options": ["non_persistent_attrs": ["ethnicity", "gender"]]] as [String : Any]

    let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

    let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,
                                        timeoutInterval: 10.0)
    request.httpMethod = "PATCH"
    request.allHTTPHeaderFields = headers
    request.httpBody = postData as Data

    let session = URLSession.shared
    let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
      if (error != nil) {
        print(error)
      } else {
        let httpResponse = response as? HTTPURLResponse
        print(httpResponse)
      }
    })

    dataTask.resume()
   ```
   </CodeGroup>

   Où :
   1. `{yourConnectionId}` est [l’ID de connexion](/docs/fr-ca/authenticate/identity-providers/locate-the-connection-id) pour lequel ces attributs seront refusés.
   2. `{yourToken}` est le jeton d’accès que vous avez reçu à l’étape précédente.
   3. L’objet `options.non_persistent_attrs` contient un tableau des attributs qui seront refusés. Si la demande que vous souhaitez refuser est envoyée par un fournisseur d’identité (IdP) en amont, vous devez définir la demande exactement comme elle a été envoyée par l’IdP en amont. Par exemple, pour une demande reçue comme `https://acme.com/temporary_idtoken`, l’objet de l’exemple ci-dessus `non_persistent_attrs` serait :

      ```
      {"non_persistent_attrs": ["ethnicity", "gender", "https://acme.com/temporary_idtoken"]}
      ```

      

      

## Limites

* Seuls les [champs racine](/docs/fr-ca/manage-users/user-accounts/user-profiles/user-profile-structure) (comme `user.name` ou `user.phone_number`) peuvent être refusés.

  + Si `user.name` ou `user.nickname` est refusé, il ne sera pas inclus dans les jetons.
  + Si `user.email` est refusé, la valeur ne peut pas être mappée à une demande personnalisée. Par exemple, dans une règle, `context.idToken[namespace + ’work_email’] = user.email` ne fonctionnerait pas.
* Lorsque vous refusez des attributs, ils seront toujours disponibles via des règles et des jetons sortants. Cependant, si l’une des conditions suivantes s’applique, les attributs de la liste rouge ne seront **pas** inclus dans les jetons :

  + Vous avez activé l’authentification multifacteur (MFA)
  + Vous avez effectué une redirection à l’aide de règles
  + Votre application utilise la délégation (et vous n’avez pas défini `permission = passthrough`)
  + Votre application utilise l’usurpation d’identité
  + Vous avez activé le paramètre **Utiliser Auth0 au lieu de l’IdP pour effectuer une authentification unique** (anciens locataires uniquement)
* Pour les connexions SAMLP, si vous activez le mode Debug, vos journaux contiendront des informations sur les attributs de la liste rouge

Si l’une de ces limitations est inacceptable, vous pouvez créer une [règle](/docs/fr-ca/customize/rules) pour chiffrer les données et faire en sorte que les données persistent dans l’objet `user.app_metadata`.

## En savoir plus

* [Adresses IP Auth0 pour listes d’autorisations](/docs/fr-ca/secure/security-guidance/data-security/allowlist)