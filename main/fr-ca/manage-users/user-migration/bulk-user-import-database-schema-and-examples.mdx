---
title: "Schéma de base données pour importation d’utilisateurs en lots et exemples"
permalink: "bulk-user-import-database-schema-and-examples"
'description': "Apprenez comment performer importations d’utilisateurs en masse avec Management API."
'og:title': "Schéma de base données pour importation d’utilisateurs en lots et exemples"
'og:description': "Apprenez comment performer importations d’utilisateurs en masse avec Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Schéma de base données pour importation d’utilisateurs en lots et exemples"
'twitter:description': "Apprenez comment performer importations d’utilisateurs en masse avec Management API."
---

Le fichier des utilisateurs doit contenir un tableau avec les informations des utilisateurs au format JSON.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

La limite de la taille des fichiers pour une importation en bloc est de 500 Ko. Vous devrez effectuer l'importation en plusieurs fois (plusieurs fichiers) si vos données dépassent cette taille.

</Callout>

## Schéma JSON des utilisateurs

Le schéma JSON suivant décrit les utilisateurs valides :

```json lines expandable
{
  "type": "object",
	"properties": {
		"email": {
			"type": "string",
			"description": "The user's email address.",
			"format": "email"
		},
		"email_verified": {
			"type": "boolean",
			"default": false,
			"description": "Indicates whether the user has verified their email address."
		},
		"user_id": {
			"type": "string",
			"description": "The user's unique identifier. This will be prepended by the connection strategy."
		},
		"username": {
			"type": "string",
			"description": "The user's username."
		},
		"given_name": {
			"type": "string",
			"description": "The user's given name."
		},
		"family_name": {
			"type": "string",
			"description": "The user's family name."
		},
		"name": {
			"type": "string",
			"description": "The user's full name."
		},
		"nickname": {
			"type": "string",
			"description": "The user's nickname."
		},
		"picture": {
			"type": "string",
			"description": "URL pointing to the user's profile picture."
		},
		"blocked": {
			"type": "boolean",
			"description": "Indicates whether the user has been blocked."
		},
		"password_hash": {
			"type": "string",
			"description": "Hashed password for the user. Passwords should be hashed using bcrypt $2a$ or $2b$ and have 10 saltRounds."
		},
		"custom_password_hash": {
			"type": "object",
			"description": "A more generic way to provide the users password hash. This can be used in lieu of the password_hash field when the users password hash was created with an alternate algorithm. Note that this field and password_hash are mutually exclusive.",
			"properties": {
				"algorithm": {
					"type": "string",
					"enum": [
						"argon2",
						"bcrypt",
						"hmac",
						"ldap",
						"md4",
						"md5",
						"sha1",
						"sha256",
						"sha512",
						"pbkdf2",
						"scrypt"
					],
					"description": "The algorithm that was used to hash the password."
				},
				"hash": {
					"type": "object",
					"properties": {
						"value": {
							"type": "string",
							"description": "The password hash."
						},
						"encoding": {
							"type": "string",
							"enum": [
								"base64",
								"hex",
								"utf8"
							],
							"description": "The encoding of the provided hash. Note that both upper and lower case hex variants are supported, as well as url-encoded base64."
						},
						"digest": {
							"type": "string",
							"description": "The algorithm that was used to generate the HMAC hash",
							"enum": [
								"md4",
								"md5",
								"ripemd160",
								"sha1",
								"sha224",
								"sha256",
								"sha384",
								"sha512",
								"whirlpool"
							]
						},
						"key": {
							"type": "object",
							"description": "The key that was used to generate the HMAC hash",
							"required": [
								"value"
							],
							"properties": {
								"value": {
									"type": "string",
									"description": "The key value"
								},
								"encoding": {
									"type": "string",
									"enum": [
										"base64",
										"hex",
										"utf8"
									],
									"default": "utf8",
									"description": "The key encoding"
								}
							}
						}
					}
				},
				"salt": {
					"type": "object",
					"properties": {
						"value": {
							"type": "string",
							"description": "The salt value used to generate the hash."
						},
						"encoding": {
							"type": "string",
							"enum": [
								"base64",
								"hex",
								"utf8"
							],
							"default": "utf8",
							"description": "The encoding of the provided salt. Note that both upper and lower case hex variants are supported, as well as url-encoded base64."
						},
						"position": {
							"type": "string",
							"enum": [
								"prefix",
								"suffix"
							],
							"default": "prefix",
							"description": "The position of the salt when the hash was calculated. For example; MD5('salt' + 'password') = '67A1E09BB1F83F5007DC119C14D663AA' would have \"position\":\"prefix\"."
						}
					},
					"required": [
						"value"
					]
				},
				"password": {
					"type": "object",
					"properties": {
						"encoding": {
							"type": "string",
							"enum": [
								"ascii",
								"utf8",
								"utf16le",
								"ucs2",
								"latin1",
								"binary"
							],
							"default": "utf8",
							"description": "The encoding of the password used to generate the hash. On login, the user-provided password will be transcoded from utf8 before being checked against the provided hash. For example; if your hash was generated from a ucs2 encoded string, then you would supply \"encoding\":\"ucs2\"."
						}
					}
				},
				"keylen" : {
					"type": "integer",
					"description": "Desired key length in bytes for the scrypt hash. Must be an integer greater than zero. Required when algorithm is set to scrypt."
				},
				"cost" : {
					"type": "integer",
					"default": 16384,
					"description": "CPU/memory cost parameter used for the scrypt hash. Must be a power of two greater than one. Only used when algorithm is set to scrypt."
				},
				"blockSize" : {
					"type": "integer",
					"default": 8,
					"description": "Block size parameter used for the scrypt hash. Must be a positive integer. Only used when algorithm is set to scrypt."
				},
				"parallelization" : {
					"type": "integer",
					"default": 1,
					"description": "Parallelization parameter used for the scrypt hash. Must be a positive integer. Only used when algorithm is set to scrypt."
				}
			},
			"required": [
				"algorithm",
				"hash"
			],
			"additionalProperties": false
		},
		"app_metadata": {
			"type": "object",
			"description": "Data related to the user that does affect the application's core functionality."
		},
		"user_metadata": {
			"type": "object",
			"description": "Data related to the user that does not affect the application's core functionality."
		},
		"mfa_factors": {
			"type": "array",
			"items": {
				"type": "object",
				"properties": {
					"totp": {
						"type": "object",
						"properties": {
							"secret": {
								"type": "string",
								"pattern": "^[A-Z2-7]+$",
								"description": "The OTP secret is used with authenticator apps (Google Authenticator, Microsoft Authenticator, Authy, 1Password, LastPass). It must be supplied in un-padded Base32 encoding, such as: JBTWY3DPEHPK3PNP"
							}
						},
						"additionalProperties": false,
						"required": [
							"secret"
						]
					},
					"phone": {
						"type": "object",
						"properties": {
							"value": {
								"type": "string",
								"pattern": "^\\+[0-9]{1,15}$",
								"description": "The phone number for SMS MFA. The phone number should include a country code and begin with +, such as: +12125550001"
							}
						},
						"additionalProperties": false,
						"required": [
							"value"
						]
					},
					"email": {
						"type": "object",
						"properties": {
							"value": {
								"type": "string",
								"format": "email",
								"description": "The email address for MFA"
							}
						},
						"additionalProperties": false,
						"required": [
							"value"
						]
					}
				},
				"maxProperties": 1,
				"additionalProperties": false
			},
			"minItems": 1,
			"maxItems": 10
		}
	},
	"required": [
		"email"
	],
	"additionalProperties": false
}
```

Pour en savoir plus sur le schéma JSON, consultez l’adresse URL [jsonschema.org](http://json-schema.org).

## Propriétés

Vous pouvez importer des utilisateurs ayant les propriétés suivantes :

<table class="table"><thead>
<tr>
<th><strong>Propriété</strong></th>
<th><strong>Type</strong></th>
<th><strong>Description</strong></th>
<th><strong>Insertion ou mise à jour pendant l’importation?</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`app_metadata`</td>
<td>objet</td>
<td>Données qui peuvent avoir une incidence sur les principales fonctionnalités de l’application ou sur ce à quoi l’utilisateur peut accéder. Les données stockées dans `app_metadata` ne peuvent pas être modifiées par les utilisateurs. Cela peut inclure des éléments tels que les plans d’assistance, les rôles ou les groupes d’accès.</td>
<td>Oui</td>
</tr>
<tr>
<td>`blocked`</td>
<td>booléen</td>
<td>Indique si l’utilisateur a été bloqué.</td>
<td>Non</td>
</tr>
<tr>
<td>`email`</td>
<td>chaîne</td>
<td>L’adresse courriel de l’utilisateur.</td>
<td>Non</td>
</tr>
<tr>
<td>`email_verified`</td>
<td>booléen</td>
<td>Indique si l’utilisateur a vérifié son adresse courriel. Défini sur `false` par défaut si `email` est mis à jour par upsert, mais pas par `email_verified`.</td>
<td>Oui</td>
</tr>
<tr>
<td>`family_name`</td>
<td>chaîne</td>
<td>Le nom de famille de l’utilisateur.</td>
<td>Oui</td>
</tr>
<tr>
<td>`given_name`</td>
<td>chaîne</td>
<td>Le nom de l’utilisateur.</td>
<td>Oui</td>
</tr>
<tr>
<td>`name`</td>
<td>chaîne</td>
<td>Le nom complet de l’utilisateur.</td>
<td>Oui</td>
</tr>
<tr>
<td>`nickname`</td>
<td>chaîne</td>
<td>Le pseudo de l’utilisateur.</td>
<td>Oui</td>
</tr>
<tr>
<td>`picture`</td>
<td>chaîne</td>
<td>URL pointant sur l’image du profil de l’utilisateur.</td>
<td>Oui</td>
</tr>
<tr>
<td>`user_id`</td>
<td>chaîne</td>
<td>L’identifiant unique de l’utilisateur. Cela sera précédé par la stratégie de connexion.</td>
<td>Non</td>
</tr>
<tr>
<td>`user_metadata`</td>
<td>objet</td>
<td>Données qui n’ont pas d’incidence sur ce que les utilisateurs peuvent ou ne peuvent pas consulter, comme l’adresse professionnelle, l’adresse personnelle ou les préférences de l’utilisateur.</td>
<td>Oui</td>
</tr>
<tr>
<td>`username`</td>
<td>chaîne</td>
<td>Le nom d’utilisateur de l’utilisateur.</td>
<td>Non</td>
</tr>
<tr>
<td>`password_hash`</td>
<td>chaîne</td>
<td>Mot de passe haché pour la connexion de l’utilisateur. Lorsque des utilisateurs sont créés, Auth0 utilise <a href="https://auth0.com/blog/hashing-in-action-understanding-bcrypt/">bcrypt</a> pour sécuriser le mot de passe. L’importation de mots de passe hachés permet aux utilisateurs de conserver leurs mots de passe pour une expérience plus fluide. Les mots de passe compatibles doivent être hachés à l’aide de bcrypt $2a$ ou $2b$ et comporter 10 saltRounds. Cette propriété ne peut être fournie que lorsque l’utilisateur est importé pour la première fois et ne peut pas être mise à jour ultérieurement.</td>
<td>Non</td>
</tr>
<tr>
<td>`custom_password_hash`</td>
<td>objet</td>
<td>Une façon plus générique de fournir le mot de passe haché de l’utilisateur. Cette valeur peut être utilisée à la place du champ `password_hash` lorsque le mot de passe a été créé avec un algorithme alternatif. Pendant le processus d’importation en bloc, vous pouvez mettre à jour le `custom_password_hash` si l’utilisateur ne s’est pas connecté en utilisant le `custom_password_hash` initialement importé.</td>
<td>Oui</td>
</tr>
<tr>
<td>`mfa_factors`</td>
<td>tableau</td>
<td>Les facteurs MFA qui peuvent être utilisés pour authentifier cet utilisateur</td>
<td>Non</td>
</tr>
</tbody>
</table>

Pour en savoir plus sur `app_metadata` et `user_metadata`, consultez [Comprendre le fonctionnement des métadonnées dans les profils utilisateurs](/docs/fr-ca/manage-users/user-accounts/metadata).

## Métadonnées d’application

L’objet `user.app_metadata` ne doit contenir **aucune** de ces propriétés suivantes :

* `__tenant`
* `_id`
* `blocked`
* `clientID`
* `created_at`
* `email_verified`
* `email`
* `globalClientID`
* `global_client_id`
* `identities`
* `lastIP`
* `lastLogin`
* `loginsCount`
* `metadata`
* `multifactor_last_modified`
* `multifacteur`
* `updated_at`
* `user_id`

## Hachage de mot de passe personnalisé

L’objet `user.custom_password_hash` peut être utilisé à la place de la propriété `user.password_hash` lorsque le mot de passe a été créé avec un algorithme alternatif. Notez que ce champ et `password_hash` s’excluent mutuellement.

L’objet `user.custom_password_hash` possède les propriétés suivantes :

<table class="table"><thead>
<tr>
<th>Propriété</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`algorithm`</td>
<td>chaîne</td>
<td>L’algorithme utilisé pour hacher le mot de passe. Doit être l’un des suivants : <ul><li>`argon2`</li><li>`bcrypt`</li><li>`hmac`</li><li>`ldap`</li><li>`md4`</li><li>`md5`</li><li>`sha1`</li><li>`sha256`</li><li>`sha512`</li><li>`pbkdf2`</li><li>`scrypt`</li></ul></td>
</tr>
<tr>
<td>`hash`</td>
<td>objet</td>
<td></td>
</tr>
<tr>
<td>`hash.value`</td>
<td>chaîne</td>
<td>Le hachage du mot de passe.</td>
</tr>
<tr>
<td>`hash.encoding`</td>
<td>chaîne</td>
<td>Le codage du hachage fourni. Doit être l’un des suivants : <ul><li>`base64`</li><li>`hex`</li><li>`utf8`</li></ul>Les variantes hexagonales majuscules et minuscules sont prises en charge, ainsi que la base64 encodé pour URL.</td>
</tr>
<tr>
<td>`hash.digest`</td>
<td>chaîne</td>
<td>L’algorithme utilisé pour générer le hachage HMAC. Doit être l’un des suivants : <ul><li>`md4`</li><li>`md5`</li><li>`ripemd160`</li><li>`sha1`</li><li>`sha224`</li><li>`sha256`</li><li>`sha384`</li><li>`sha512`</li><li>`whirlpool`</li></ul></td>
</tr>
<tr>
<td>`hash.key`</td>
<td>objet</td>
<td>La clé utilisée pour générer le hachage HMAC.</td>
</tr>
<tr>
<td>`hash.key.value`</td>
<td>chaîne</td>
<td>La valeur de la clé.</td>
</tr>
<tr>
<td>`hash.key.encoding`</td>
<td>chaîne</td>
<td>L’encodage de la clé. Doit être l’un des suivants : <ul><li>`base64`</li><li>`hex`</li><li>`utf8`</li></ul>Par défaut, `hash.key.encoding` est `utf8`.</td>
</tr>
<tr>
<td>`salt`</td>
<td>objet</td>
<td></td>
</tr>
<tr>
<td>`salt.value`</td>
<td>chaîne</td>
<td>La valeur de salage utilisée pour générer le hachage.</td>
</tr>
<tr>
<td>`salt.encoding`</td>
<td>chaîne</td>
<td>Le codage de la valeur de salage fournie. Doit être l’un des suivants : <ul><li>`base64`</li><li>`hex`</li><li>`utf8`</li></ul> Les variantes hexagonales majuscules et minuscules sont prises en charge, ainsi que la base64 encodé pour URL. Par défaut, `salt.encoding` est `utf8`.</td>
</tr>
<tr>
<td>`salt.position`</td>
<td>chaîne</td>
<td>La position de la valeur de salage lors du calcul du hachage. Par défaut, `salt.position` est `prefix`.</td>
</tr>
<tr>
<td>`password.encoding`</td>
<td>chaîne</td>
<td>Le codage du mot de passe utilisé pour générer le hachage. Doit être l’un des suivants : <ul><li>`ascii`</li><li>`utf8`</li><li>`utf16le`</li><li>`ucs2`</li><li>`latin1`</li><li>`binary`</li></ul> Lors de la connexion, le mot de passe fourni par l’utilisateur sera transcodé à partir de `password.encoding` avant d’être vérifié par rapport au hachage fourni. Par exemple, si votre hachage a été généré à partir d’une chaîne encodée `ucs2`, alors vous devriez définir : ` "encoding": "ucs2"`</td>
</tr>
<tr>
<td>`keylen`</td>
<td>entier</td>
<td>Longueur de clé souhaitée en octets pour le hachage scrypt. Doit être un nombre entier supérieur à zéro. <br/>Ce paramètre est requis lorsque `algorithm` est fixé à `scrypt`.</td>
</tr>
<tr>
<td>`cost`</td>
<td>entier</td>
<td>Paramètre de coût processeur/mémoire utilisé pour le hachage scrypt. Doit être une puissance de deux supérieure à un. Par défaut, `cost` est 16384.<br/>Ce paramètre n’est utilisé que lorsque `algorithm` est fixé à `scrypt`.</td>
</tr>
<tr>
<td>`blockSize`</td>
<td>entier</td>
<td>Paramètre de taille de bloc utilisé pour le hachage scrypt. Doit être un nombre entier positif. Par défaut, `blockSize` est 8.<br/>Ce paramètre n’est utilisé que lorsque `algorithm` est fixé à `scrypt`.</td>
</tr>
<tr>
<td>`parallelization`</td>
<td>entier</td>
<td>Paramètre de parallélisation utilisé pour le hachage scrypt. Doit être un nombre entier positif. Par défaut, `parallelization` est 1.<br/>Ce paramètre n’est utilisé que lorsque `algorithm` est fixé à `scrypt`.</td>
</tr>
</tbody>
</table>

### Mise à jour du hachage de mot de passe personnalisé

Pendant le processus d’importation en bloc, vous pouvez mettre à jour le `Mot de passe haché personnalisé` si l’utilisateur ne s’est pas connecté en utilisant le `custom_password_hash.` initialement importé. Vous pouvez, par exemple, envoyer deux fois le fichier JSON ci-dessous au point de terminaison[`/api/v2/jobs/users-imports`](https://auth0.com/docs/api/management/v2?_ga=2.169020323.346193905.1601302257-746691936.1587131255#!/Jobs/post_users_imports) avec des valeurs différentes pour `custom_password_hash`. Au deuxième envoi, attribuez la valeur `upsert` à l’indicateur `true`.

```json lines
[
    {
    	"user_id": "2000",
        "email": "examplecouser20@gmail.com",
        "given_name": "ExampleCo User",
        "name" : "ExampleCoUser20",
        "custom_password_hash": {
            "algorithm": "bcrypt",
            "hash": {
                "value": "$2a$10$aHF7mbpWT6tZ7PJVtwtjNelaKbszikcYBCB2jibvbFcGFmOsu/s4K"
            }
        }
    }
]
```

Vous pouvez utiliser le [générateur de mots de passe Bcrypt](https://www.browserling.com/tools/bcrypt) disponible à l’adresse URL browserling.com pour générer des hachages de mots de passe Bcrypt.

### Algorithmes de hachage pris en charge

Auth0 prend actuellement en charge les importations de mots de passe d’utilisateurs hachés par :

* [Argon2](https://github.com/p-h-c/phc-winner-argon2)
* [bcrypt](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)
* [LDAP](https://tools.ietf.org/html/rfc2307#section-5.3) (`RFC-2307 "userPassword"`)
* [HMAC](https://tools.ietf.org/html/rfc2104)
* [MD4](https://tools.ietf.org/html/rfc1320)
* [MD5](https://tools.ietf.org/html/rfc1321)
* [SHA1](https://tools.ietf.org/html/rfc3174)
* [SHA256 and SHA512](https://tools.ietf.org/html/rfc4634)
* [PBKDF2](https://tools.ietf.org/html/rfc2898#section-5.2)
* [scrypt](https://datatracker.ietf.org/doc/rfc7914/)

Veuillez tenir compte des sections suivantes lorsque vous fournissez un `custom_password_hash`.

#### Argon2

Lorsque l’`algorithme` est défini sur `argon2` :

* `hash.encoding` doit être au format `utf8`.
* `hash.salt` n’est pas autorisé.
* `hash.value` doit être au format de chaîne PHC, spécifié dans [P-H-C / phc-string-format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md) sur GitHub. Il doit également être conforme aux exigences spécifiées dans [Auth0 / magic](https://github.com/auth0/magic#magicpasswordhash--magicverifypassword) sur GitHub.
* `hash.value` doit inclure le sel encodé en base64 (comme spécifié dans la documentation `PHC`).

#### bcrypt

Lorsque l’`algorithm` est défini sur `bcrypt` :

* `hash.encoding` doit être au format `utf8`.
* `hash.salt` n’est pas autorisé.
* `hash.value` doit inclure l’un des préfixes suivants :

  + `$2a$`
  + `$2b$`
  + `$2y$`

  Certains préfixes, comme `$2$`, `$sha1$`, et `$2x$`, ne sont pas pris en charge pour le moment.

Voici, par exemple, ce qui a été généré à partir de la chaîne `hello` en utilisant un paramètre de coût de 10 :

`$2b$10$nFguVi9LsCAcvTZFKQlRKeLVydo8ETv483lkNsSFI/Wl1Rz1Ypo1K`

L’algorithme `bcrypt` peut traiter un maximum de 72 octets d’entrée lorsqu’il calcule des hachages de mots de passe ou effectue des comparaisons, et la longueur de `salt.value` compte dans la limite des 72 octets d’entrée. Toute entrée dépassant la limite de 72 octets est tronquée; par exemple, si le salage consomme 10 octets, la longueur maximale du mot de passe pour le hachage ou la comparaison est de 62 octets.

Les mots de passe trop longs sont tronqués, ce qui peut affaiblir leur force ou introduire des collisions de hachage. Il est donc important de vérifier la longueur des mots de passe avant de les hacher.

#### HMAC

Lorsque l’`algorithm` est défini sur `hmac` :

* `hash.encoding` doit être au format `hex` ou `base64`.
* `hash.digest` est obligatoire et doit correspondre à l’un des formats suivants :

  + `md4`
  + `md5`
  + `ripemd160`
  + `sha1`
  + `sha224`
  + `sha256`
  + `sha384`
  + `sha512`
  + `whirlpool`
* `hash.key.value` est obligatoire.
* `hash.key.encoding` doit être au format `base64`, `hex` ou `utf8`.

#### LDAP

Lorsque l’`algorithm` est défini sur `ldap` :

* `hash.encoding` doit être au format `utf8`.
* `salt` n’est pas autorisé.
* `hash.value` doit respecter le format décrit dans [RFC-2307 section-5.3](https://tools.ietf.org/html/rfc2307#section-5.3)  sur IETF Datatracker.
* Le schéma doit être parmi les suivants : `md5|smd5|sha*|ssha*`. Voir [ici](https://www.openldap.org/faq/data/cache/347.html) pour plus d’informations.
* Notez que le schéma [crypt](https://www.openldap.org/faq/data/cache/344.html) n’est **pas pris en charge** en raison d’un comportement dépendant du système ou de l’implémentation. Pour en savoir plus, lisez le [Guide d’administration d’Open LDAP - 14.4.2. Schéma de stockage des mots de passe CRYPT](https://www.openldap.org/doc/admin24/guide.html#CRYPT%20password%20storage%20scheme).

#### MD ou SHA

Lorsque l’`algorithm` est défini sur `md4`, `md5`, `sha1`, `sha256` ou `sha512` :

* `hash.encoding` doit être au format `hex` ou `base64`.

#### PBKDF2

Lorsque l’`algorithm` est défini sur `pbkdf2` :

* `hash.encoding` doit être au format `utf8`.
* `hash.salt` n’est pas autorisé.
* `hash.value` doit être au format de chaîne PHC, spécifié dans [P-H-C / phc-string-format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md) sur GitHub.
* `hash.value` doit inclure le sel encodé en B64 (base64 omettant les caractères de remplissage `=`, comme spécifié dans la documentation `PHC`).
* `hash.value` doit inclure les paramètres `i` (itérations) et `l` (keylen). Si ces paramètres sont omis, ils sont définis par défaut à `i=100000` et `l=64`.
* La valeur `id` doit être au format `pbkdf2-<digest>`(`pbkdf2-sha512`, `pbkdf2-md5`, etc). Les synthèses prises en charge sont les suivantes :

  + `RSA-MD4`
  + `RSA-MD5`
  + `RSA-MDC2`
  + `RSA-RIPEMD160`
  + `RSA-SHA1`
  + `RSA-SHA1-2`
  + `RSA-SHA224`
  + `RSA-SHA256`
  + `RSA-SHA384`
  + `RSA-SHA512`
  + `md4`
  + `md4WithRSAEncryption`
  + `md5`
  + `md5WithRSAEncryption`
  + `mdc2`
  + `mdc2WithRSA`
  + `ripemd`
  + `ripemd160`
  + `ripemd160WithRSA`
  + `rmd160`
  + `sha1`
  + `sha1WithRSAEncryption`
  + `sha224`
  + `sha224WithRSAEncryption`
  + `sha256`
  + `sha256WithRSAEncryption`
  + `sha384`
  + `sha384WithRSAEncryption`
  + `sha512`
  + `sha512WithRSAEncryption`
  + `ssl3-md5`
  + `ssl3-sha1`
  + `whirlpool`

#### scrypt

Lorsque l’`algorithm` est défini sur `scrypt`:

* `hash.encoding` doit être au format `hex` ou `base64`.
* Le paramètre `keylen` est obligatoire.
* Le paramètre `cost` peut être spécifié; dans le cas contraire, la valeur par défaut est 16384.
* Le paramètre `blockSize` peut être spécifié; dans le cas contraire, la valeur par défaut est 8.
* Le paramètre `parallelization` peut être spécifié; dans le cas contraire, la valeur par défaut est 1.

### Facteurs MFA

Le tableau `user.mfa_factors` contient les inscriptions à <Tooltip href="/docs/fr-ca/glossary?term=multifactor-authentication" tip="Authentification multifacteur (MFA)
Processus d’authentification de l’utilisateur qui utilise un facteur en plus du nom d’utilisateur et du mot de passe, tel qu’un code par SMS." cta="Voir le glossaire">MFA</Tooltip> pour l’utilisateur. Pour en savoir plus, consultez [Authentification multifacteur (MFA) dans Auth0](/docs/fr-ca/secure/multi-factor-authentication). L’importation des inscriptions évite aux utilisateurs de devoir s’inscrire à nouveau à l'authentification multifacteur (MFA) une fois l’importation effectuée. Les types d’inscription pris en charge sont :

<table class="table"><thead>
<tr>
<th>Propriété</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`email`</td>
<td>objet</td>
<td></td>
</tr>
<tr>
<td>`email.value`</td>
<td>chaîne de caractères</td>
<td>L’adresse courriel pour l’authentificaton MFA.</td>
</tr>
<tr>
<td>`phone`</td>
<td>objet</td>
<td></td>
</tr>
<tr>
<td>`phone.value`</td>
<td>chaîne de caractères</td>
<td>Le numéro de téléphone pour l’authentification MFA par SMS. Il doit comporter un code pays et commencer par `+`, comme par exemple : `"+12125550001"`</td>
</tr>
<tr>
<td>`totp`</td>
<td>objet</td>
<td></td>
</tr>
<tr>
<td>`totp.secret`</td>
<td>chaîne de caractères</td>
<td>Le secret OTP pour l’authentification MFA avec les applications d’authentification (Google Authenticator, Microsoft Authenticator, Authy, 1Password, LastPass). Doit être encodé en Base32 sans remplissage, par exemple : `"JBTWY3DPEHPK3PNP"`</td>
</tr>
</tbody>
</table>

## Exemples

### Exemple de base

Un fichier dont le contenu est le suivant est valide :

```json lines
[
  {
    "email": "john.doe@contoso.com",
    "email_verified": false,
    "app_metadata": {
        "roles": ["admin"],
        "plan": "premium"
    },
    "user_metadata": {
        "theme": "light"
    }
  }
]
```

### Exemples de hachage de mot de passe personnalisé

Quelques exemples d’utilisateurs avec des hachages fournis :

```json lines expandable
[
    {
        "email": "antoinette@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "md4",
            "hash": {
                "value": "AbuUujgF0pPPkJPSFRTpmA==",
                "encoding": "base64"
            }
        }
    },
    {
        "email": "mary@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "sha256",
            "hash": {
                "value": "d24e794fce503c3ddb1cd1ba1dd5d9b250cf9917336a0316fefd87fecf79200f",
                "encoding": "hex"
            },
            "salt": {
                "value": "abc123",
                "position": "prefix"
            }
        }
    },
    {
        "email": "velma@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "bcrypt",
            "hash": {
                "value": "$2b$10$C9hB01.YxRSTcn/ZOOo4j.TW7xCKKFKBSF.C7E0xiUwumqIDqWUXG"
            }
        }
    },
    {
        "email": "edward@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "argon2",
            "hash": {
                "value": "$argon2id$v=19$m=65536,t=2,p=1$J6Q/82PCyaNpYKRELJyTZg$m04qUAB8rexWDR4+/0f+SFB+4XMFxt7YAvAq2UycYos"
            }
        }
    },
    {
        "email": "terrell@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "pbkdf2",
            "hash": {
                "value": "$pbkdf2-md4$i=100000,l=64$+N375B8q0Fw$fp2R9KAM4hK/votGHC5Fu+jhqbxUD8+Nic/EMSGvNC3UP/k7wSHI0uXluHRSkZfl/BOheYqNOemayG90ZaSSQw",
                "encoding": "utf8"
            }
        }
    },
    {
        "email": "cecil@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "pbkdf2",
            "hash": {
                "value": "$pbkdf2-sha512$i=100000,l=64$KNyFsA2rWoE$I2CQGI9H0JxdDf3kERRI97kPCGxh0KWBIV3MxyaS191gDGfzVBGyS4BibhgqWQ0/ails8mHuU9ckASxHOOq58w"
            }
        }
    },
    {
        "email": "sean@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "ldap",
            "hash": {
                "value": "{SSHA384}/cgEjdoZh85DhurDeOQEMO1rMlAur93SVPbYe5XSD4lF7nNuvrBju5hUeg9A6agRemgSXGl5YuE=",
                "encoding": "utf8"
            }
        }
    },
    {
        "email": "peter@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "hmac",
            "hash": {
                "value": "cg7f42jH39/2EaAU4wNd4s2lKIk=",
                "encoding": "base64",
                "digest": "sha1",
                "key": {
                    "value": "736868",
                    "encoding": "hex"
                }
            }
        }
    },
    {
        "email": "carmella@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "scrypt",
            "hash": {
                "value": "097f6197e1b41538f723e32aa7a68e8d76227d8e432ce5faa4882a913032db29",
                "encoding": "hex"
            },
            "salt": {
                "value": "abc123",
                "encoding": "utf8"
            },
            "keylen": 32,
            "cost": 4096
        }
    }
]
```

### Exemples de facteurs MFA

Comme vous vous en doutez, le tableau `user.mfa_factors` vous permet de fournir les inscriptions à MFA de l’utilisateur. Les types d’inscription pris en charge sont :

* Téléphone : sert à la vérification par SMS.
* TOTP : secret OTP à utiliser avec les applications de type MFA (Google Authenticator, Microsoft Authenticator, Authy, 1Password, LastPass).
* Courriel : utilisé pour la vérification par courriel.

Quelques exemples d’utilisateurs utilisant des facteurs MFA :

```json lines expandable
[
    {
        "email": "antoinette@contoso.com",
        "mfa_factors": [
            {
                "totp": {
                    "secret": "2PRXZWZAYYDAWCD"
                }
            },
            {
                "phone": {
                    "value": "+15551112233"
                }
            },
            {
                "email": {
                    "value": "antoinette@antoinette.biz"
                }
            }
        ]
    },
    {
        "email": "mary@contoso.com",
        "mfa_factors": [
            {
                "totp": {
                    "secret": "JBTWY3DPEHPK3PNP"
                }
            }
        ]
    },
    {
        "email": "velma@contoso.com",
        "mfa_factors": [
            {
                "phone": {
                    "value": "+15551234567"
                }
            },
        ]
    },
    {
        "email": "edward@contoso.com",
        "mfa_factors": [
            {
                "email": {
                    "value": "edward@edward.biz"
                }
            }
        ]
    }
]
```

## En savoir plus

* [Importation d’utilisateurs par lot](/docs/fr-ca/manage-users/user-migration/bulk-user-imports)
* [Exportations d’utilisateurs en masse](/docs/fr-ca/manage-users/user-migration/bulk-user-exports)
* [Configurer la migration automatique à partir de votre base de données](/docs/fr-ca/manage-users/user-migration/configure-automatic-migration-from-your-database)