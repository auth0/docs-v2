---
title: "ASP.NET Core Web APIアプリケーションに認可を追加する"
permalink: "interactive"
'description': "このチュートリアルは、標準のJWTミドルウェアを使ってASP.NET Core Web APIアプリケーションに認可を追加する方法を説明します。"
'og:title': "ASP.NET Core Web APIアプリケーションに認可を追加する"
'og:description': "このチュートリアルは、標準のJWTミドルウェアを使ってASP.NET Core Web APIアプリケーションに認可を追加する方法を説明します。"
'og:image': "/docs/media/platforms/asp.png"
'twitter:title': "ASP.NET Core Web APIアプリケーションに認可を追加する"
'twitter:description': "このチュートリアルは、標準のJWTミドルウェアを使ってASP.NET Core Web APIアプリケーションに認可を追加する方法を説明します。"
sidebarTitle: ASP.NET Core Web API
---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/recipe.jsx";
import { LoggedInForm } from "/snippets/Login.jsx";
import Appsettings from "/snippets/quickstart/backend/aspnet-core-webapi/appsettings.json.mdx";
import Program from "/snippets/quickstart/backend/aspnet-core-webapi/Program.cs.mdx";
import Hasscopehandler from "/snippets/quickstart/backend/aspnet-core-webapi/HasScopeHandler.cs.mdx";
import Hasscoperequirement from "/snippets/quickstart/backend/aspnet-core-webapi/HasScopeRequirement.cs.mdx";
import Apicontroller from "/snippets/quickstart/backend/aspnet-core-webapi/ApiController.cs.mdx";

export const sections = [
  { id: "アクセス許可を定義する", title: "アクセス許可を定義する" },
  { id: "依存関係をインストールする", title: "依存関係をインストールする" },
  { id: "ミドルウェアを構成する", title: "ミドルウェアを構成する" },
  { id: "スコープを検証する", title: "スコープを検証する" },
  { id: "apiエンドポイントを保護する", title: "APIエンドポイントを保護する" },
  { id: "apiを呼び出す", title: "APIを呼び出す" }
]

<Recipe>
  <Content>
    Auth0を使用すると、アプリケーションに認証を追加して、アプリケーションの種類にかかわらず、ユーザープロファイル情報に手軽にアクセスすることができます。このガイドは、新規または既存のASP.NET Web APIアプリケーションに`Microsoft.AspNetCore.Authentication.JwtBearer`パッケージを使ってAuth0を統合する方法を説明します。

    Auth0 DashboardでAPIをまだ作成していない場合は、対話型のセレクターを使ってAuth0 APIを新規作成します。そうでない場合は、統合したいプロジェクトを表す既存のAPIを選択することができます。

    または、Auth0 Dashboardを使って初めてAPIをセットアップする方法を使用の開始ガイドで確認することもできます。

    Auth0にあるAPIはそれぞれAPI識別子を使って構成され、アプリケーションのコードはAPI識別子をオーディエンスとしてアクセストークンを検証します。

    <Info>
    **Auth0を初めてご利用ですか？** Auth0の仕組みと、OAuth 2.0フレームワークを用いたAPI認証と認可の実装について説明します。
    </Info>

      <Section id={sections[0].id} title={sections[0].title} stepNumber="1">
      アクセス許可は、ユーザーの代わりに、提供されたアクセストークンを使ってどのようにしてリソースにアクセスできるのかを定義できるようにします。たとえば、ユーザーがマネージャーアクセスレベルを持つ場合には、`messages`リソースに対して読み取りアクセスを付与し、管理者アクセスレベルを持つ場合には、書き込みアクセスを付与することができます。

      Auth0 Dashboardの[［API］](https://manage.auth0.com/#/apis)セクションにある**［Permissions（権限）］** ビューで使用可能なアクセス許可を定義することができます。以下の例では`read:messages`スコープを使用します。

      <Frame>![［Auth0 Dashboard］>［Applications（アプリケーション）］>［APIs］>［Specific API（特定のAPI］>［Permissions（権限）］タブ](/images/ja-jp/cdy7uua7fh8z/1s3Yp5zqJiKiSWqbPSezNO/acef814282795bef6921535f044f96e9/Quickstarts_API.png)</Frame>
      </Section>

      <Section id={sections[1].id} title={sections[1].title} stepNumber="2">
      アプリケーションがアクセストークンを検証できるようにするには、`Microsoft.AspNetCore.Authentication.JwtBearer` NuGetパッケージへの参照を追加します。

      ```
      Install-Package Microsoft.AspNetCore.Authentication.JwtBearer
      ```
      </Section>

      <Section id={sections[2].id} title={sections[2].title} stepNumber="3">
      アプリケーションの`Program.cs`ファイルを構成して、認証ミドルウェアをセットアップします：

      1. `AddAuthentication`メソッドを呼び出して、認証サービスを登録します。`JwtBearerDefaults.AuthenticationScheme`をデフォルトのスキームとして構成します。
      2. `AddJwtBearer`メソッドを呼び出して、JWTベアラー認証スキームを登録します。Auth0ドメインをオーソリティ、Auth0 API識別子をオーディエンスとして構成し、Auth0ドメインとAPI識別子がアプリケーションの**appsettings.json** ファイル内で設定されていることを確認します。

         OPEN|INFO
         場合によっては、アクセストークンに`sub`クレームが含まれないことがあります。この場合には、`User.Identity.Name`が`null`になります。別のクレームを`User.Identity.Name`にマッピングしたい場合には、それを`AddJwtBearer()`への呼び出しの中で`options.TokenValidationParameters`に追加します。
         CLOSE|INFO
      3. `UseAuthentication`メソッドと`UseAuthorization`メソッドの呼び出しを`var app = builder.Build();`メソッドの下に追加して、ミドルウェアパイプラインに認証ミドルウェアと認可ミドルウェアを追加します。
      </Section>

      <Section id={sections[3].id} title={sections[3].title} stepNumber="4">
      アクセストークンに正しいスコープが含まれていることを確認するには、ASP.NET Coreの[ポリシーベースの認可](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies)を使用します。

      1. `HasScopeRequirement`という名前の新しい認可要求を作成します。これは、Auth0テナント発行の`scope`クレームが存在するかを確認し、存在する場合には、要求されたスコープがそのクレームに含まれているかを確認します。
      2. `Program.cs`ファイルにある`var builder = WebApplication.CreateBuilder(args);`メソッドの下に、`app.AddAuthorization`メソッドへの呼び出しを追加します。
      3. スコープのポリシーを追加するには、各スコープに`AddPolicy`を呼び出します。
      4. `HasScopeHandler`クラスのシングルトンを登録します。
      </Section>

      <Section id={sections[4].id} title={sections[4].title} stepNumber="5">
      JWTミドルウェアは、ASP.NET Coreの標準の[認証](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/)および[認可](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/)メカニズムと統合します。

      エンドポイントのセキュリティを保護するには、`[Authorize]`属性をコントローラーのアクション（すべてのアクションのセキュリティを保護するには、コントローラー）に追加します。

      特定のスコープが必要なエンドポイントのセキュリティを保護するには、正しいスコープが`access_token`に存在することを確認します。そのためには、`Authorize`属性を`Scoped`アクションに追加し、`read:messages`を`policy`パラメーターとして渡します。
      </Section>

      <Section id={sections[5].id} title={sections[5].title} stepNumber="6">
      APIの呼び出し方は、開発しているアプリケーションの種類と使用しているフレームワークに依存します。詳細については、該当するアプリケーションのクイックスタートをお読みください。

      - [シングルページアプリケーション](/ja-jp/quickstart/spa)
      - [モバイル / ネイティブアプリケーション](/ja-jp/quickstart/native)

      ### アクセストークン取得する

      開発しているアプリケーションの種類や使用しているフレームワークが何であったとしても、APIを呼び出すにはアクセストークンが必要です。

      シングルページアプリケーション（SPA）またはネイティブアプリケーションからAPIを呼び出すと、認可フローの完了後にアクセストークンを受け取ります。

      コマンドラインツールや他のサービスなど、ユーザーが資格情報を入力しないものからAPIを呼び出す際には、[OAuthクライアントの資格情報フロー](https://auth0.com/docs/api/authentication#client-credentials)を使用します。そのためには、[マシンツーマシンアプリケーション](https://manage.auth0.com/#/applications)を登録し、要求内で以下の値を渡します。

      - **クライアントID** を`client_id`パラメーターとして渡す。
      - **クライアントシークレット** を`client_secret`パラメーターとして渡す。
      - **API 識別子** （このクイックスタートで以前にミドルウェアの構成に使用したのと同じ値）を`audience`パラメーターとして渡す。

      <Info>
      マシンツーマシンアプリケーションにクライアントIDとクライアントシークレットを取得する詳細については、アプリケーションの設定をお読みください。
      </Info>

      **要求例**

      <CodeGroup>
      ```sh cURL lines
      curl --request post \
      --url 'https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token' \
      --header 'content-type: application/x-www-form-urlencoded'
      ```

      ```cs C# lines
      var client = new RestClient("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token");
      var request = new RestRequest(Method.POST);
      request.AddHeader("content-type", "application/x-www-form-urlencoded");
      IRestResponse response = client.Execute(request);
      ```

      ```go Go lines
      package main
      import (
      "fmt"
      "net/http"
      "io/ioutil"
      )
      func main() {
      url := "https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token"
      req, _ := http.NewRequest("post", url, nil)
      req.Header.Add("content-type", "application/x-www-form-urlencoded")
      res, _ := http.DefaultClient.Do(req)
      defer res.Body.Close()
      body, _ := ioutil.ReadAll(res.Body)
      fmt.Println(res)
      fmt.Println(string(body))
      }
      ```

      ```java Java lines
      HttpResponse<String> response = Unirest.post("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token")
      .header("content-type", "application/x-www-form-urlencoded")
      .asString();
      ```

      ```js Node.JS lines
      var axios = require("axios").default;
      var options = {
      method: 'post',
      url: 'https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token',
      headers: {'content-type': 'application/x-www-form-urlencoded'}
      };
      axios.request(options).then(function (response) {
      console.log(response.data);
      }).catch(function (error) {
      console.error(error);
      });
      ```

      ```obj-c Obj-C lines
      #import <Foundation/Foundation.h>
      NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };
      NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

      [request setHTTPMethod:@"post"];
      [request setAllHTTPHeaderFields:headers];
      NSURLSession *session = [NSURLSession sharedSession];
      NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                  if (error) {

                                                      NSLog(@&quot;%@&quot;, error);

                                                  } else {

                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                      NSLog(@&quot;%@&quot;, httpResponse);

                                                  }

                                              }];

      [dataTask resume];
      ```

      ```php PHP lines
      $curl = curl_init();
      curl_setopt_array($curl, [
      CURLOPT_URL => "https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token",
      CURLOPT_RETURNTRANSFER => true,
      CURLOPT_ENCODING => "",
      CURLOPT_MAXREDIRS => 10,
      CURLOPT_TIMEOUT => 30,
      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
      CURLOPT_CUSTOMREQUEST => "post",
      CURLOPT_HTTPHEADER => [
      &quot;content-type: application/x-www-form-urlencoded&quot;

      ],
      ]);
      $response = curl_exec($curl);
      $err = curl_error($curl);
      curl_close($curl);
      if ($err) {
      echo "cURL Error #:" . $err;
      } else {
      echo $response;
      }
      ```

      ```python Python lines
      import http.client
      conn = http.client.HTTPSConnection("")
      headers = { 'content-type': "application/x-www-form-urlencoded" }
      conn.request("post", "/dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token", headers=headers)
      res = conn.getresponse()
      data = res.read()
      print(data.decode("utf-8"))
      ```

      ```rb Ruby lines
      require 'uri'
      require 'net/http'
      require 'openssl'
      url = URI("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token")
      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      request = Net::HTTP::Post.new(url)
      request["content-type"] = 'application/x-www-form-urlencoded'
      response = http.request(request)
      puts response.read_body
      ```

      ```swift Swift lines
      require 'uri'
      require 'net/http'
      require 'openssl'
      url = URI("https://dev-gja8kxz4ndtex3rq.us.auth0.com/oauth/token")
      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      request = Net::HTTP::Post.new(url)
      request["content-type"] = 'application/x-www-form-urlencoded'
      response = http.request(request)
      puts response.read_body
      ```

      </CodeGroup>
      

      ### セキュリティ保護されたエンドポイントを呼び出す

      取得したアクセストークン使用すると、セキュリティ保護されたAPIエンドポイントを呼び出すことができます。セキュリティ保護されたエンドポイントを呼び出す際には、アクセストークンをベアラートークンとして要求の**認可** ヘッダーに含める必要があります。たとえば、`/api/private`エンドポイントに要求を送信することができます：

      <CodeGroup>
      ```sh cURL lines
      curl --request get \
      --url http://localhost:3010/api/private \
      --header 'authorization: Bearer YOUR_ACCESS_TOKEN'
      ```

      ```cs C# lines
      var client = new RestClient("http://localhost:3010/api/private");
      var request = new RestRequest(Method.GET);
      request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN");
      IRestResponse response = client.Execute(request);
      ```

      ```go Go lines
      package main
      import (
      "fmt"
      "net/http"
      "io/ioutil"
      )
      func main() {
      url := "http://localhost:3010/api/private"
      req, _ := http.NewRequest("get", url, nil)
      req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN")
      res, _ := http.DefaultClient.Do(req)
      defer res.Body.Close()
      body, _ := ioutil.ReadAll(res.Body)
      fmt.Println(res)
      fmt.Println(string(body))
      }
      ```

      ```java Java lines
      HttpResponse<String> response = Unirest.get("http://localhost:3010/api/private")
      .header("authorization", "Bearer YOUR_ACCESS_TOKEN")
      .asString();
      ```

      ```js Node.JS lines
      var axios = require("axios").default;
      var options = {
      method: 'get',
      url: 'http://localhost:3010/api/private',
      headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}
      };
      axios.request(options).then(function (response) {
      console.log(response.data);
      }).catch(function (error) {
      console.error(error);
      });
      ```

      ```obj-c Obj-C lines
      #import <Foundation/Foundation.h>
      NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_ACCESS_TOKEN" };
      NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://localhost:3010/api/private"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

      [request setHTTPMethod:@"get"];
      [request setAllHTTPHeaderFields:headers];
      NSURLSession *session = [NSURLSession sharedSession];
      NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                  if (error) {

                                                      NSLog(@&quot;%@&quot;, error);

                                                  } else {

                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                      NSLog(@&quot;%@&quot;, httpResponse);

                                                  }

                                              }];

      [dataTask resume];
      ```

      ```php PHP lines
      $curl = curl_init();
      curl_setopt_array($curl, [
      CURLOPT_PORT => "3010",
      CURLOPT_URL => "http://localhost:3010/api/private",
      CURLOPT_RETURNTRANSFER => true,
      CURLOPT_ENCODING => "",
      CURLOPT_MAXREDIRS => 10,
      CURLOPT_TIMEOUT => 30,
      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
      CURLOPT_CUSTOMREQUEST => "get",
      CURLOPT_HTTPHEADER => [
      &quot;authorization: Bearer YOUR_ACCESS_TOKEN&quot;

      ],
      ]);
      $response = curl_exec($curl);
      $err = curl_error($curl);
      curl_close($curl);
      if ($err) {
      echo "cURL Error #:" . $err;
      } else {
      echo $response;
      }
      ```

      ```python Python lines
      import http.client
      conn = http.client.HTTPConnection("localhost:3010")
      headers = { 'authorization': "Bearer YOUR_ACCESS_TOKEN" }
      conn.request("get", "/api/private", headers=headers)
      res = conn.getresponse()
      data = res.read()
      print(data.decode("utf-8"))
      ```

      ```rb Ruby lines
      require 'uri'
      require 'net/http'
      url = URI("http://localhost:3010/api/private")
      http = Net::HTTP.new(url.host, url.port)
      request = Net::HTTP::Get.new(url)
      request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN'
      response = http.request(request)
      puts response.read_body
      ```

      ```swift Swift lines
      import Foundation
      let headers = ["authorization": "Bearer YOUR_ACCESS_TOKEN"]
      let request = NSMutableURLRequest(url: NSURL(string: "http://localhost:3010/api/private")! as URL,
                                          cachePolicy: .useProtocolCachePolicy,

                                      timeoutInterval: 10.0)

      request.httpMethod = "get"
      request.allHTTPHeaderFields = headers
      let session = URLSession.shared
      let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
      if (error != nil) {
      print(error)

      } else {
      let httpResponse = response as? HTTPURLResponse

      print(httpResponse)

      }
      })
      dataTask.resume()
      ```
      </CodeGroup>
      

      `/api/private-scoped`エンドポイントも同様の方法で呼び出しますが、APIのアクセス許可が正しく構成され、アクセストークンに`read:messages`スコープがあることを確認してください。

      <Note>
      ##### チェックポイント
      /api/privateと/api/private-scopedエンドポイントを呼び出すことができるはずです。
      アプリケーションを実行して次の点を確認します：
      GET /api/privateが認証された要求に使用できる。
      GET /api/private-scopedがread:messagesスコープが付与されたアクセストークンを含む認証された要求に使用できる。
      </Note>
      </Section>

    ## 次のステップ

    成功です！ここまで来れば、アプリケーションにログイン、ログアウト、ユーザープロファイル情報が備わっているはずです。

    これでクイックスタートチュートリアルは終了ですが、機能はまだまだたくさんあります。Auth0でできることについて詳しくは、以下をご覧ください。

    *   [Auth0 Dashboard](https://manage.auth0.com/#) - Auth0のテナントやアプリケーションを構成して管理する方法について説明します
    *   [Auth0 Marketplace](https://marketplace.auth0.com/) - Auth0の機能性を拡張できる各種の統合を見つけられます
  </Content>

  <SideMenu sections={sections}>
      <SideMenuSectionItem id={sections[0].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[1].id}>
        <SignUpForm />
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[2].id}>
      <CodeGroup>
        <Program />
        <Appsettings/>
        <Hasscopehandler/>
        <Hasscoperequirement/>
        <Apicontroller/>
      </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[3].id}>
        <CodeGroup>
          <Hasscopehandler/>
          <Program />
          <Appsettings/>
          <Hasscoperequirement/>
          <Apicontroller/>
      </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[4].id}>
        <CodeGroup>
          <Apicontroller/>
          <Hasscopehandler/>
          <Program />
          <Appsettings/>
          <Hasscoperequirement/>
      </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[5].id}>
        <SignUpForm />
      </SideMenuSectionItem>

    </SideMenu>
</Recipe>
