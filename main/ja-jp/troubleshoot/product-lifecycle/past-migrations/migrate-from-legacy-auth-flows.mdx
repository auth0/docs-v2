---
title: "レガシー認証フローからの移行"
permalink: "migrate-from-legacy-auth-flows"
'description': "レガシー認証フローからの移行方法について説明します。"
'og:title': "レガシー認証フローからの移行"
'og:description': "レガシー認証フローからの移行方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "レガシー認証フローからの移行"
'twitter:description': "レガシー認証フローからの移行方法について説明します。"
---

バージョン11より前のLock、およびバージョン9より前のAuth0.jsを使用しているときは、廃止されるレガシー認証フローを使用できました。Auth0は、古いバージョンのAuth0.jsおよびLockからコードを新しいOIDC準拠のAPIに移行することをお勧めしています。

## トークンを更新する

レガシーアプリケーションは、期限切れと同時に新しいトークンを取得する方法として、リフレッシュトークンおよび`refreshToken()`関数を使用しました（以下に例を示します）。

auth0.js v9およびLock 11では、[サイレント認証](/ja-jp/authenticate/login/configure-silent-authentication)および`checkSession()`を使用する必要があります（以下に例を示します）

## APIを呼び出す

レガシーアプリケーションは、APIを呼び出すためにIDトークンを使用しました。これはバッドプラクティスであり、アクセストークンのみを使用することをお勧めします。

APIを呼び出すには、auth0.jsまたはLockを初期化するときに、`audience`パラメーターとしてAPI識別子を指定する必要があります。

オーディエンスを指定した場合、OIDCフローがトリガーされ、Auth0からIDトークンで、または`/userinfo`から返されたユーザープロファイルデータは、OIDC準拠になります。アプリケーションがユーザープロファイルの非標準のクレームを使用している場合は、中断されます。

SPAからAPIの呼び出し方法の詳細については、SPA Quickstartsの「**APIを呼び出す** 」のセクションをご覧ください。また、アクセストークンを使用するために、バックエンドAPI実装を移行する必要があります。方法については、API Quickstartsをご覧ください。

## ユーザープロファイル

IDトークンおよび`/userinfo`エンドポイントが完全なユーザープロファイルを含めることを可能にするレガシーアプリケーションフローは、廃止されます。新しいOIDC準拠のAPIへの移行を完了した後、`Legacy User Profile`トグルがオフになっていることを確認してください。

レガシー認証フローを使用する場合、以下に示すように、ユーザープロファイル全体がIDトークンで、または`/userinfo`から返されます。

新しいユーザープロファイルは、OIDC仕様に準拠しているため、応答で特定の[標準クレーム](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)が利用可能です。

コンテンツは、要求されるスコープによって異なります。Auth0.jsまたはLockを構成するときに、要求するスコープを調整する必要があります。そうすることで、必要なクレームすべてがアプリケーションで利用可能になります。カスタムクレームを追加して、必要なデータを返すことができます（例：ユーザーメタデータ）。

完全なユーザープロファイルを取得する別の方法としては、次のセクションで説明するように、（認証フローを通してプロファイルを取得する代わりに）<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=management-api" tip="Management API: 顧客が管理タスクを実行できるようにするための製品。" cta="用語集の表示">Management API</Tooltip>を使用するやり方があります。

## Management APIを使用したユーザープロファイル

レガシーフローで、Management APIは、IDトークンでの認証をサポートしていました。この方法は廃止されているため、アクセストークンで呼び出す必要があります。

アクセストークンを取得するには、`https://{yourDomain}/api/v2/`オーディエンスを使用しているアクセストークンをAuth0に要求する必要があります。Auth0は現在、認証時に2つのオーディエンスを指定することをサポートしていないため、Lockまたはauth0.jsを初期化するときに、アプリケーションのAPIオーディエンスを使用する必要があります。ユーザーが認証されたら、`checkSession`を使用して、Management API `access_token`を取得し、その後`getUser()`エンドポイントを呼び出すことができます。

以下のスコープを要求することができます。

* `read:current_user`
* `update:current_user_identities`
* `create:current_user_metadata`
* `update:current_user_metadata`
* `delete:current_user_metadata`
* `create:current_user_device_credentials`
* `delete:current_user_device_credentials`

`checkSession()`を呼び出したときに、`consent_required`エラーになるときがあります。その場合は、Management APIの **［Allow Skipping User Consent（ユーザー同意のスキップを許可）］** が有効になっていること、およびlocalhostから実行していないことを確認してください。