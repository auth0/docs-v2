---
title: "エラー処理のベストプラクティス"
permalink: "error-handling-best-practices"
'description': "エラー処理のベストプラクティスについて学びます。"
'og:title': "エラー処理のベストプラクティス"
'og:description': "エラー処理のベストプラクティスについて学びます。"
'og:image': "https://cdn2.auth0.com/docs/1.14576.0/img/share-image.png"
'twitter:title': "エラー処理のベストプラクティス"
'twitter:description': "エラー処理のベストプラクティスについて学びます。"
---

API呼び出しから返されるエラー条件は、適切な方法で処理する必要があります。これを怠ると例外が処理されない状況につながり、パイプラインの実行が途中で終了し、最終的に認証エラーが返される可能性があります。

## エラーログを外部サービスに送信する

異常な操作の可視性と診断を向上させるために、エラーイベントログを外部サービスに送信することをお勧めします。サブスクリプションプランで提供されるログ保持期間を超えてログイベントを保持および分析するには、[Auth0ログストリーミング](/ja-jp/customize/log-streams)を使用します。DataDogやAWS EventBridgeなどのサービスを使用できます。Auth0 Marketplaceの[ログストリーミング](https://marketplace.auth0.com/features/log-streaming)セクションでは、ログを外部サービスに送信する機能も提供しています。

## ルールでエラーオブジェクトを使用する

ルールの実行時間には時間制限があります。詳細については、[カスタムデータベースアクションスクリプト実行のベストプラクティス](/ja-jp/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)をお読みください。この期間内にエラー状態から回復できない場合（または回復する可能性がない場合）、エラー状態を明示的に返す必要があります。これは、次のように、Node `Error`オブジェクトのインスタンスを返すことでルール実行を完了するのと同じくらい簡単です。

`return callback(new Error('some description'));`

詳細については、[クラス: nodejs.orgにエラー](https://nodejs.org/api/errors.html#errors_class_error)をお読みください。

または、Auth0固有の`UnauthorizedError`のインスタンスを返すこともできます。これにより、認証を開始したアプリケーション（つまり、`/authorize`エンドポイントへのリダイレクトを開始したアプリケーション）に、指定されたエラーの説明を含む`不正な`エラー状態が返されます。これにより、アプリケーションは条件付き再試行機能を提供でき、特定の条件に基づいてアクセスを拒否するルールを実装できます。

`return callback(new UnauthorizedError('some description'), user, context);`

## 意味のあるエラーコードの説明を使用する

`UnauthorizedError`オブジェクトは、指定された説明のみを返します。不正なエラー条件に対して特定の処理を使用するには、説明をフォーマットして、簡単にアクセスできるエラーコード情報を含めることをお勧めします。例:

`'[00043] - my specific error description'`）

## 例外処理

キャッチされないJavaScript例外などの予期しないエラー条件により、パイプラインの実行が途中で終了し、最終的に認証エラーが返される可能性があります。

非同期操作を伴う状況では、`Promise`オブジェクト処理を使用するときに`catch`ハンドラーを使用する必要があります。`Promise`オブジェクト処理は、非同期操作中のエラー処理にも効果的です。以下に示すように、`Promise`オブジェクトを使用して、たとえば同期関数呼び出しをラップすると、Promiseチェーンなどを使用してカスケード エラー処理を簡単に実装できます。Promiseオブジェクトの詳細については、[MDN Web DocsのPromise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)を参照してください。Promiseチェーンの詳細については、[Error Handling with Promises on javascript.infoのPromiseによるエラー処理](https://javascript.info/promise-error-handling)をお読みください。

```javascript lines
return new Promise(function(resolve, reject) {
    jwt.verify(
      token,
      secret,{
      clockTolerance: 5},
      function(err, decoded) {
        if (err) {
          reject(err);
        } else {
          resolve(decoded);
      }
    });
  });
```

または、同期操作中に発生するJavaScript例外を処理するために`try...catch`処理を使用することもできます。詳細については、[MDN Web Docsの`try...catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)をお読みください。このタイプの例外処理を設定するとパフォーマンスコストが発生する場合が多いため、多用しないようにして。ルールのパフォーマンスは可能な限り最適化する必要があります。より実用的なアプローチは、例外が発生した後に処理するのではなく、例外が発生しないようにする処理を実装することです。ベストプラクティスの詳細については、[パフォーマンスのベストプラクティス](/ja-jp/troubleshoot/performance-best-practices)を参照してください。

## ルールで初期化されていないオブジェクトを避ける

初期化されていないオブジェクトを使用すると、例外が発生する可能性があります。オブジェクトの存在が疑われる場合は、宣言の一部として初期化を含めることをお勧めします。例：

`user.user_metadata = user.user_metadata || {}`)

ルールでは、例外が発生しないようにするための手順を実行することがベストプラクティスであり、通常、例外処理を実装するよりもパフォーマンスとリソースの使用の点でコストが低くなります。

## もっと詳しく

* [デバッグのベストプラクティス](/ja-jp/troubleshoot/debugging-best-practices)
* [ルールのベストプラクティス](/ja-jp/rules-best-practices)