---
title: "セッション"
permalink: "sessions"
'description': "セッションとは何か、Auth0でどのように使用されるかについて説明します。"
'og:title': "セッション"
'og:description': "セッションとは何か、Auth0でどのように使用されるかについて説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "セッション"
'twitter:description': "セッションとは何か、Auth0でどのように使用されるかについて説明します。"
---

セッションとは、特定の期間におけるユーザーおよびアプリケーション間の一連のインタラクションです。1つのセッションは複数のアクティビティ（ページビュー、イベント、ソーシャル インタラクション、eコマーストランザクションなど）で構成され、ユーザーが接続している間、この情報は一時的に保存できます。

標準のSet-Cookieヘッダー実装では、ユーザーがWebサイトを離れるかブラウザーを閉じるとセッションが終了します。ユーザーが毎回ログインしなくても済むように、アプリケーションはセッションCookieの最大有効期間を設定することでセッションを延長できます。ユーザーがログアウトするか、セッション有効期間の制限に達すると、セッションは終了します。

詳細については、[Auth0のプライバシーおよびCookieポリシー](https://auth0.com/privacy)を確認してください。

## セッションのユースケース

Auth0は、アプリケーションを通じて認証するすべてのユーザーのログインセッションを維持します。ユーザーが新しい標準ログインを実行すると、Auth0はログインセッションをリセットします。パスワード、メール、電話番号を更新すると、ユーザーのAuth0セッションも期限切れになります。

認証を要求するアプリケーションの構築では、要求が発生するたびにユーザーが認証されているかどうかを判断するために、セッションを使用することができます。アプリの構築方法に応じて、さまざまな認証フローが推奨されユーザーにとってより安全なエクスペリエンスをサポートします。

たとえば、storezero.ioというOIDC準拠（<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=openid" tip="OpenID: アプリケーションがログイン情報を収集および保存することなくにユーザーのIDを検証できるようにする認証用のオープン標準。" cta="用語集の表示">OpenID</Tooltip> Connect）のWebサイトを考えてみましょう。

<Frame>![Example e-commerce website Storezero.io](/images/ja-jp/cdy7uua7fh8z/5XXxdX4fuApQtAapQfZU1b/2fd9161af60962e3de3fc951d95b83d1/use-case-storezero.png)</Frame>

Storezero.ioでは、購入を完了するためにユーザーがログインする必要はありません。ただし、サイトの［My Account（マイアカウント）］セクションを表示するには、ユーザーがログインする必要があります。

以下にリストされているユースケースでは、ユーザーがチェックアウトする前に以前の注文を確認したいシナリオを考えてみましょう。そのためには、［My Account（マイアカウント）］セクションの［All Orders（すべての注文）］ページに移動し、ログインするように求められます。

### ログインフロー

大部分のアプリケーションタイプ（Webアプリ、シングルページアプリ、ネイティブアプリなど）では、[PKCEを使用した認可コードフロー](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)を使用してログイン認証を容易にする必要があります。このフローでは、認可コードをトークンと交換します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

PKCEを使った認可コードフローは、以前にバックエンドのないシングルページアプリで使用していた暗黙フローに取って代わるものです。新しい開発では、最適なセキュリティを確保するために、このフローを使用しなければなりません。暗黙フローを使用している既存のアプリは、PKCEで強化された認可コードフローに移行することを強くお勧めします。

</Callout>

#### ユーザーはユーザー名とパスワードを使用してログインします

この例では、ユーザーはユーザー名とパスワードを使用して手動でログインします。

1. Auth0のSDKはローカル セッションを作成し、ユーザーをAuth0認可サーバー（`/authorize`エンドポイント）にリダイレクトします。
2. 認可サーバーはセッションを作成し、ユーザーをログインおよび認可プロンプトにリダイレクトします。
3. ユーザーはユーザー名とパスワードを使用して認証します。
4. Auth0認可サーバーは、ユーザーが以前に作成したセッションを更新して、ログインしていることを示します。
5. 使用されるフローに応じて、認可サーバーはIDトークンまたは認可コードのいずれかとともにユーザーをアプリケーションに返します。
6. アプリケーションはトークンまたは認可コードをアクセストークンと交換し、フローを完了します。

このフローでは、次の2つのセッションが作成されます。

* 1つ目は、**ローカルセッション** （storezero.io）で、ユーザーが認証されているかどうかをアプリケーションに示します。
* 2つ目は**認可サーバーセッション** （storezero.auth0.com）で、ユーザーが認証されているかどうかをサーバーに示します。サーバーセッションは、オプションで認証の詳細を追跡することもできます。

  + たとえば認可サーバーは、ユーザーが[多要素認証（MFA）](/ja-jp/secure/multi-factor-authentication)を活用したかどうかを追跡できます。この情報を使用して、ユーザーが次に認可サーバーにアクセスしたときに、ログインまたはMFAの使用を求めるかどうかを判断できます。

#### ユーザーがIDプロバイダーを使用してログインする

この例では、ユーザーはユーザー名とパスワードの代わりにFacebookでログインすることを選択します。

1. Auth0のSDKはローカル セッションを作成し、ユーザーをAuth0認可サーバー（`/authorize`エンドポイント）にリダイレクトします。
2. 認可サーバーはセッションを作成し、ユーザーをログインおよび認可プロンプトにリダイレクトします。
3. Facebookでログインすることを選択すると、認可サーバーはユーザーをFacebookにリダイレクトします。
4. Facebookはセッションを作成し、ユーザーを認証します。次に、 Facebookはセッションを更新して、ユーザーがログインしていることを示します。
5. FacebookはユーザーをAuth0認可サーバーに返します。認可サーバーはセッションを更新して、ユーザーがログインしていることを示します。
6. 使用されるフローに応じて、認可サーバーはIDトークンまたは認可コードのいずれかとともにユーザーをアプリケーションに返します。
7. アプリケーションはトークンまたは認可コードをアクセストークンと交換し、フローを完了します。

このシナリオでは、**ローカルセッション** （storezero.io）、**認可サーバーセッション** （storezero.auth0.com）、および**IDプロバイダー（<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-2" href="/ja-jp/glossary?term=idp" tip="IDプロバイダー（IdP）: デジタルIDを保存および管理するサービス。" cta="用語集の表示">IdP</Tooltip>）セッション** （facebook.com）の3つのセッションが作成されます。

Facebookのサーバー上のIdPセッションはユーザーを認証し、シームレスな<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=single-sign-on" tip="シングルサインオン（SSO）: ユーザーが1つのアプリケーションにログインした後、そのユーザーを他のアプリケーションに自動的にログインさせるサービス。" cta="用語集の表示">SSO</Tooltip>エクスペリエンスを提供します。ユーザーはすでにFacebookにログインしている可能性が高いため、多くの場合、ユーザーは手動でFacebook認証情報を提供しなくても認証されます。

### SPAのセッション管理

前の例では、ユーザーがいずれかのログインフローを開始すると、ローカルセッションが作成されます。このローカルセッションは、ユーザーのログイン状態を維持し、再認証が必要になるタイミングを決定できます。

ただし、シングルページアプリ（SPA）などのバックエンドのないアプリケーションでは、ローカルセッションは使用できません。代わりにこれらのアプリケーションは、[サイレント認証](/ja-jp/authenticate/login/configure-silent-authentication)と呼ばれるアプローチを使用して、ユーザーのログイン状態を維持します。

サイレント認証では、認可サーバー上のセッションを使用して、ユーザーが再認証する必要があるタイミングを判断します。非表示のiframeは、`prompt=none`パラメーターとともに認証要求を認可サーバーにリダイレクトします。このパラメータにより、サーバーはユーザーに入力を求めなくなります。

* 認可サーバー上のセッションが期限切れになっていない場合は、トランザクションはシームレスに続行されます。サーバーは、`postMessage`を活用するWMRM（Webメッセージ応答モード）を介してアクセストークンを送信します。
* 認可のセッションが期限切れになっているか、ユーザーがログアウトした場合、iframe内のリダイレクトはエラーを返します。その後、アプリケーションはユーザーを認可サーバーに誘導して再認証を行う必要があります。

## もっと詳しく

* [セッションレイヤー](/ja-jp/manage-users/sessions/session-layers)
* [セッションライフタイムの制限](/ja-jp/manage-users/sessions/session-lifetime-limits)
* [セッションライフタイムの設定を構成する](/ja-jp/manage-users/sessions/configure-session-lifetime-settings)
* [クッキー](/ja-jp/manage-users/cookies)
* [sameSiteクッキー属性の変更](/ja-jp/manage-users/cookies/samesite-cookie-attribute-changes)
* [Cookieを使用してシングルページアプリを認証する](/ja-jp/manage-users/cookies/spa-authenticate-with-cookies)