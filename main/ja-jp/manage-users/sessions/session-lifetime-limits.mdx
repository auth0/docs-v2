---
title: "セッションライフタイムの制限"
permalink: "session-lifetime-limits"
'description': "システムが許可するセッション終了までの継続期間を説明します。"
'og:title': "セッションライフタイムの制限"
'og:description': "システムが許可するセッション終了までの継続期間を説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "セッションライフタイムの制限"
'twitter:description': "システムが許可するセッション終了までの継続期間を説明します。"
---

セッションライフタイムの制限は、システムがセッションをどのくらい長く維持するのかを決定します。Auth0には、セッションライフタイムに関して以下の2つの設定があります。

* **Inactivity timeout（非アクティブタイムアウト）** ：セッションクッキーが認可サーバーと対話しなくなってから、ユーザーのセッションが失効するまでの時間です。セルフサービスプランでは3日、エンタープライズプランでは100日を超えると、システム制限によって置き換えられます。
* **Require log in after（ログインを要求する経過時間）** ：アクティビティにかかわらず、ユーザーに再ログインを求めるまでの時間です。セルフサービスプランでは30日、エンタープライズプランでは365日を超えると、システム制限によって置き換えられます。

これらの設定はテナントについて、[Auth0 Dashboard](/ja-jp/manage-users/sessions/configure-session-lifetime-settings)または<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=management-api" tip="Management API: 顧客が管理タスクを実行できるようにするための製品。" cta="用語集の表示">Management API</Tooltip>を使って構成することができます。

ユーザーが標準のログインを新たに実行すると、ログインセッションがリセットされます。たとえば、以下のようになります。

1. **［Inactivity timeout（非アクティブタイムアウト）］** の制限を3日、**［Require log in after（経過時間後ログインを要求）］** の制限を30日に設定します。
2. ユーザーがログインすると、入力済みの値がセッションに設定されます。

   1. ユーザーが **［Inactivity timeout（非アクティブタイムアウト）］** に設定された3日の制限内にアクティブになると、セッションライフタイムがさらに3日延長されます。その後はユーザーが3日の間にアクティブになるたびにセッションライフタイムが3日延長され続け、**［Require log in after（経過時間後ログインを要求）］** で設定した期限に達すると、セッションが終了します。そして、ユーザーに再度ログインすることが求められます。
   2. ユーザーの非アクティブ状態が3日間続いた場合には、自動的にログアウトします。
3. ユーザーがログインしている間に、既存のセッションのライフタイムを長く設定したとします。新しい設定は、既存のセッションが終了して、ユーザーが再度ログインするまで適用されません。
4. ユーザーがログインしている間に、既存のセッションのライフタイムを短く設定したとします。新しい設定は、ユーザーが次に操作を行うと即座に適用されます。これにより、セキュリティ上の目的でセッションライフタイムが短縮できるようになります。

### アプリケーション特有のログアウトURL

アプリケーション特有のログアウトURLを使用する際には、以下の2点を考慮することが重要です。

* `/oidc/logout`エンドポイントを呼び出すには、`client_id`をクエリパラメーターとして送信する**必要があります** 。また、アプリケーションの［Allowed Logout URLs（許可されているログアウトURL）］のリストに`id_token_hint`のURLが含まれていなければなりません。
* これにより、テナントの全体でAuth0セッションが終了します。つまり、指定された`client_id`に一致するアプリケーションだけでなく、定義されたすべてのアプリケーションで終了することになります。`client_id`を渡すと、どこでログアウトURLのホワイトリストを探せばいいのかが/`logout`エンドポイントに分かるようになります。

ユーザーがログアウトすると、Auth0はこのリストで定義されたURLにのみリダイレクトします。

ログアウト後、アプリケーションにユーザーをリダイレクトで戻し、アプリケーションがIDプロバイダーにリダイレクトしたときに、そのユーザーの認証済みセッションが残っていると、ユーザーがアプリケーションに暗黙で再度ログインされるため、ログアウトが機能していないかのように見えるかもしれません。このような場合には、アプリケーション内に特定のログアウトランディングページを用意することをお勧めします。そうすることで、ユーザーにログアウトが成功したことを伝え、必要があれば、IDプロバイダーにまだログインしている状態だということも警告できます。

Auth0のセッション更新に繋がるような操作をユーザーが行わなかった場合には、ユーザーがセッションの継続を明示的に選択できる警告の表示をお勧めします。そうすることで、ユーザーが不在の場合にセッションを非アクティブにできるだけでなく、暗黙でのトークン更新をトリガーして、資格情報を再度求めずにセッションを継続できます。

* **Inactivity Timer（非アクティブタイマー）** ：React SDKラッパーに回転式のタイマーを追加します。このタイマーのタイムリミットはAuth0セッションの非アクティブライフタイムの上限と一致します。トークンがアプリケーションに返されるたびに、タイマーがリセットされます。
* **Timeout Modal（タイムアウトモーダル）** ：タイマーで期限切れから60秒が経過すると、ユーザーにログアウトまたはセッションの継続を求めるタイムアウトモーダルを表示します。

  + **Continue the session（セッションを継続）**：ユーザーがセッションの継続を選択した場合には、`getTokenSilently()`メソッドを使用して、ユーザーを現在表示中のページからリダイレクトすることなく、新しいトークンを要求します。
  + **Logging out（ログアウト）**：ユーザーがログアウトを選択した場合には、`logout()`メソッドを呼び出して、Auth0セッションも確実に終了させます。
  + **Idle Timeout（アイドルタイムアウト）**：アイドルタイムアウトの期限に達した場合、即座に対処する必要はありません。ユーザーが別のタブでまだアクティブである可能性に対処するために、ユーザーをログアウトさせる動作にしては **いけません**。
  + ログインボタンのあるモーダルを更新したり、window.onfocusイベントで`getTokenSilently()`をトリガーしたり、ユーザーをランディングページにリダイレクトしたりなどの方法を採用してください。

## もっと詳しく

* [セッションライフタイムの設定を構成する](/ja-jp/manage-users/sessions/configure-session-lifetime-settings)
* [アクセストークンのライフタイムを更新する](/ja-jp/secure/tokens/access-tokens/update-access-token-lifetime)
* [IDトークンのライフタイムを更新する](/ja-jp/secure/tokens/id-tokens/update-id-token-lifetime)
* [ログインとログアウトの問題を確認する](/ja-jp/troubleshoot/authentication-issues/check-login-and-logout-issues)
* [無効なトークンエラーのトラブルシューティング](/ja-jp/troubleshoot/basic-issues/invalid-token-errors)