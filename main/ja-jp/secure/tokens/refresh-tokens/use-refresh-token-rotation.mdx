---
title: "リフレッシュトークンのローテーションを使用する"
permalink: "use-refresh-token-rotation"
'description': "認可中に受け取ったリフレッシュトークンのローテーションを使用する方法について説明します。"
'og:title': "リフレッシュトークンのローテーションを使用する"
'og:description': "認可中に受け取ったリフレッシュトークンのローテーションを使用する方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "リフレッシュトークンのローテーションを使用する"
'twitter:description': "認可中に受け取ったリフレッシュトークンのローテーションを使用する方法について説明します。"
---

リフレッシュトークンのローテーションを使用するには、Auth0 Single-Page App SDKが必要です。Auth0 SPA SDKは、トークン保管、セッション管理、その他の詳細を処理します。

## 前提条件

[リフレッシュトークンのローテーションを構成](/ja-jp/secure/tokens/refresh-tokens/configure-refresh-token-rotation)してオフラインアクセスを有効にし、クライアントSDKでオフラインアクセスのスコープを要求します。

## useRefreshTokensを有効にする

OAuth2の仕様に従い、ブラウザーが/tokenエンドポイントからリフレッシュトークンを要求した場合、Auth0はそのクライアントに対してリフレッシュトークンローテーションが有効になっている場合にのみ、リフレッシュトークンを返します。

`createAuth0Client`の`useRefreshTokens​`を使用します。デフォルトは`false`です。このオプションを`false`に設定すると、`getTokenSilently()`が呼び出されて新しいアクセストークンが必要になったときに、SDKは非表示のiframeと`prompt=none`を使用して新しいアクセストークンを取得しようとします。

このオプションを`true`に設定すると、`loginWithRedirect(), loginWithPopup()`、および`getTokenSilently()`を使用した際に`offline_access`スコープが自動的に要求されます。`getTokenSilently()`が呼び出されたときにアクセストークンの有効期限が切れていた場合、SDKはキャッシュからのリフレッシュトークンと`refresh_token`付与タイプを一緒に使用して`/token`エンドポイントを呼び出すことにより、IDおよびアクセストークンの更新を試みます。

サイレント再認証は、認証要求があったときに`prompt=none`パラメーターを送信し、非表示のiframeを使用することで行うことができます。ただしこれは、認可サーバー上にアクティブなユーザーセッションが存在する場合に限ります。`useRefreshTokens`が`true`に設定されていても、キャッシュ内に使用できるリフレッシュトークンがない場合、SDKはiframeを使用します。こうすることで、ユーザーは再度ログインしなくても、サイレントにリフレッシュトークンを使用するように移行することができます。

`useRefreshTokens`が`true`でもキャッシュにリフレッシュトークンがないために交換が失敗した場合、SDKはiframeの方法にフォールバックします（ただし、サードパーティーのクッキーがブロックされている場合、iframeも失敗することがあります）。

## トークンの保管

SPAでは、IDトークンとアクセストークンは認可サーバーから取得され、通常はメモリ内にキャッシュとして保存されます。ブラウザーの更新、メモリキャッシュの退避予算、期限切れなどによるトークンの更新は、SDKによって処理されます。

## 例

SDKをローカルストレージとリフレッシュトークンの両方を使用するように構成する方法を以下の例に示します。

```javascript lines
const auth0 = await createAuth0Client({
    domain: '<your Auth0 domain>',
    client_id: '<your Auth0 client ID>',
    cacheLocation: 'localstorage',
    useRefreshTokens: true
    });
    
    // Logging-in will automatically request the offline_access scope
    // and store the resulting refresh token
    auth0.loginWithRedirect();
    
    // Silently refreshing the access token will use the /token endpoint
    // with ‘refresh_token’ grant and the refresh token from the cache
    await auth0.getTokenSilently();
```

## もっと詳しく

* [リフレッシュトークンのローテーションを構成する](/ja-jp/secure/tokens/refresh-tokens/configure-refresh-token-rotation)
* [リフレッシュトークンのローテーションを無効にする](/ja-jp/secure/tokens/refresh-tokens/disable-refresh-token-rotation)
* [トークンのベストプラクティス](/ja-jp/secure/tokens/token-best-practices)