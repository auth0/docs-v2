---
title: "独自のユーザーストアを使用して認証する"
permalink: "overview-custom-db-connections"
'description': "IDプロバイダーに独自のデータベースを使用した認証について説明します。"
'og:title': "独自のユーザーストアを使用して認証する"
'og:description': "IDプロバイダーに独自のデータベースを使用した認証について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "独自のユーザーストアを使用して認証する"
'twitter:description': "IDプロバイダーに独自のデータベースを使用した認証について説明します。"
---

<Card title="利用可能性はAuth0プランによって異なる">

この機能が利用できるかどうかは、ご利用のAuth0プラン（または契約）によります。詳細については、「[価格設定](https://auth0.com/pricing)」をお読みください。

</Card>

<Warning>

Webtask.ioとWebtask CLIには、2018年7月17日より前に作成されたテナントしかアクセスできません。それより新しいテナントをご利用のエンタープライズのお客様は、アカウント担当者にアクセス権をリクエストしてください。その他のリクエストには、[Auth0お問い合わせフォーム](https://auth0.com/get-started?place=documentation%20post&type=link&text=auth0%20contact%20form)をご利用いただければ、個別に対応いたします。

</Warning>

以下のような目的で、独自の（レガシー）IDデータストアにアクセスを提供したい場合には、カスタムデータベース接続を使用します。

* **認証** ：ユーザーを認証するのに、データベースをAuth0でのIDプロバイダーとして使用する（レガシー認証と呼ばれます）
* **ユーザーのインポート** ：自動移行（トリクルダウン移行またはレイジー移行）を使用する
* **Auth0テナントへのプロキシアクセス** ：Auth0のマルチテナントアーキテクチャを使用する

カスタムデータベース接続を作成して構成するには、以下のタスクを実行します。

1. [接続作成](/ja-jp/api/management/v2#!/Connections/post_connections)エンドポイントに`auth0`ストラテジーを使用します。
2. [［Auth0 Dashboard］>［Authentication（認証）］>［Database（データベース）］](https://manage.auth0.com/#/connections/database)に移動し、**［Use my own database（独自のデータベースを使用する）］** を有効にして、データベースのアクションスクリプトを編集できるようにします。

   <Frame>![カスタムデータベースを有効にする 独自データベース使用オプション](/images/ja-jp/cdy7uua7fh8z/3kgHDpBFdVWNq9XOfhsTXI/2b7bba3e6105a0f2ded44afe78e19ac7/2025-02-25_10-23-29.png)</Frame>

## 仕組み

下の図が示すように、ユニバーサルログインワークフローにカスタムデータベース接続を使用して、ユーザーのID情報が独自のレガシーIDストアから取得できるようにします。

<Frame>![カスタムデータベース接続の構造](/images/ja-jp/cdy7uua7fh8z/2lHqvZKFiEbAXURU2gmchc/4450e0d9ae3073545e112a3287b30f6e/custom-database-connections.png)</Frame>

すべての[データベース接続](/ja-jp/authenticate/database-connections)タイプに共通なアーティファクトに加えて、カスタムデータベース接続を使用すると、アクションスクリプトを構成できるようになります。アクションスクリプトとは、レガシーIDストアとのやり取りに使用されるカスタムコードのことです。Auth0は、構成に[カスタムデータベースのアクションスクリプト用テンプレート](/ja-jp/authenticate/database-connections/custom-db/templates)を各種提供しています。どれを使用するかは、作成するカスタムデータベース接続の用途がレガシー認証なのか、それとも自動移行なのかに依存します。

<Card title="ベストプラクティス">

アクションスクリプトは無名関数として実装できますが、無名関数にすると、デバッグを行う際に、生成されたコールスタックを例外的なエラー条件の結果として解釈するのが難しくなります。利便性を考慮して、アクションスクリプトには関数名を付けることをお勧めします。

</Card>

### レガシー認証のシナリオ

レガシー認証のシナリオでは、ユーザーが初めてログインすると、新しいレコードがAuth0内に作成されますが、ユーザーのパスワードのハッシュはAuth0に保管されません。Auth0がユーザーを認証する際には必ず、レガシーIDストアとそれに含まれているIDが使用されます。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

カスタムのデータベース接続は、ユニバーサルログインワークフローの外部でも使用されます。たとえば、レガシーのIDストアにいるユーザーに対してパスワード変更操作が行われると、接続の`changePassword`アクションスクリプトが呼び出されます。

</Callout>

### 自動移行のシナリオ

自動移行やトリクルダウン移行では、Auth0は新しいユーザーをAuth0管理のIDストア（データベース）内に作成します。その後、Auth0がユーザーを認証する際には必ず、Auth0管理のIDストアにあるIDが使用されます。これを行うために、Auth0は、レガシーIDストアに対照してユーザーが認証されることを要求します。この認証に成功した場合にのみ、Auth0は新しいユーザーを作成します。新しいユーザーの作成には、認証中に提供されたのと同じIDとパスワードが使用されます。

<Card title="ベストプラクティス">

自動移行のシナリオでは、ユーザーの作成は通常、`login`アクションスクリプトが完了した後で実行されます。そのため、レガシーのidentity storeからのユーザー削除をインライン操作として（つまり`login`スクリプト内で）行うのではなく、独立処理として行うことをお勧めします。そうすれば、移行中にエラー条件が発生し、ユーザーが誤って削除されてしまう事態を防ぐことができます。

</Card>

自動移行のシナリオでは、ユーザーは引き続きレガシーIDストアで管理され、必要に応じて削除やアーカイブを行うことができます。これに関する弊害は、ユーザーがAuth0から削除されても、レガシーIDストアに存在したままになることです。このときに、削除されたユーザーがログインしようとすると、`login`または/そして`getUser`スクリプトが実行され、そのユーザーがレガシーIDストアから再度移行されます。

<Card title="ベストプラクティス">

最終的なレガシーストアの削除に先立って、`login`や`getUser`が完了する前に、レガシーユーザーIDを移行しておくことをお勧めします。

</Card>

## サイズ

アクションスクリプトの実装では、総サイズが100 KBを上回ってはいけません。Auth0のサーバーレスWebtaskプラットフォームでパッケージングと転送が処理されるため、サイズが大きいほど遅延が長くなります。そして、これはシステムの性能にも影響を与えます。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

100 kBの制限には、requireステートメントの一部として参照された可能性のある`npm`モジュールは含まれません。

</Callout>

## 環境

アクションスクリプトは、サーバーレスWebtaskコンテナーのインスタンスでJavaScript関数を呼び出すことにより実行されます。これに関して、WebtaskコンテナーとAuth0認証サーバー（ご利用のAuth0テナント）による各種のアーティファクトと共に、特定の環境が提供されます。

### npmモジュール

Auth0のサーバーレスWebtaskコンテナーでは、[さまざまなnpmモジュール](https://auth0-extensions.github.io/canirequire/)を利用することができます。`npm`モジュールはアクションスクリプトのコード実装で総サイズを低減するだけでなく、予め構築された幅広い機能を活用できるようにします。

公開されている多くの`npm`モジュールが、変更することなくそのままで使用できます。このリストは、潜在的なセキュリティ関連の懸念を調査した上でまとめられています。必要な`npm`モジュールがそのまま使える形で提供されていない場合には、[Auth0のサポートポータル](https://support.auth0.com)またはAuth0の担当者までリクエストを提出してください。Auth0がリクエストを検討して、適合性を判断します。プライベートリポジトリで提供されている`npm`モジュールについては、その使用に関して、Auth0は現在サポートを提供していません。

### 変数

Auth0のアクションスクリプトは環境変数に対応しており、グローバルに使用可能な`configuration`オブジェクトと呼ばれるものを介して使うことができます。詳細については、「[カスタムデータベース接続を作成する](/ja-jp/authenticate/database-connections/custom-db/create-db-connection)」の「構成パラメーターを追加する」セクションをお読みください。

<Card title="ベストプラクティス">

`configuration`オブジェクトは、読み取り専用として扱い、資格情報やAPIキーなど、外部identity storeへのアクセスに使う機密性の高い情報を保管するために使用します。そうすれば、アクションスクリプトで機密性の高い値をハードコード化しなくてすみます。

</Card>

構成オブジェクトを使用すると、変数にテナント特定の値が定義できるようなるため、あらゆる[ソフトウェア開発ライフサイクル（SDLC）](/ja-jp/get-started/auth0-overview/create-tenants/set-up-multiple-environments)の戦略に対応させることができます。これにより、アクションスクリプトの実行テナントに依存して変わる値を、コードの中に埋め込む必要性が軽減されます。

### globalオブジェクト

Auth0のサーバーレスWebtaskコンテナーは、各Auth0テナントに関連付けられているプールからプロビジョニングされます。コンテナーインスタンスはそれぞれ`global`オブジェクトを使用可能にして、コンテナーインスタンス内で実行されるすべてのアクションスクリプトからアクセスできるようにします。`global`オブジェクトは、コンテナーに一意のグローバル変数として動作し、コンテナーインスタンス内で実行されるすべてのアクションスクリプトが使用する情報や機能の定義に使うことができます。

つまり、ユーザー特定のリソースを除く、あらゆるリソースをキャッシュするために、`global`オブジェクトを使用することができます。たとえば、ユーザー非特定の機能性を提供するサードパーティー（ログ）APIのアクセストークンを保管するのに使用します。または、独自のユーザー非特定のAPIに対する、Auth0で定義され、[クライアント資格情報フロー](/ja-jp/get-started/authentication-and-authorization-flow/client-credentials-flow)によって取得されたアクセストークンを保管するのに使用します。

<Warning>

アクションスクリプトは、すでに実行中のコンテナインスタンスだけでなく、新規作成され、続いてプールに追加される可能性のあるコンテナインスタンスでも実行できます。Auth0でのアクションスクリプトの実行には、コンテナアフィニティはありません。そのため、ユーザー固有の情報を`global`オブジェクトに保存することは避け、`global`オブジェクト内で行う宣言を、必ず初期化にも対応したものにしてください。

</Warning>

Webtaskコンテナーが再利用されるたびに、または、Webtaskコンテナーの新しいインスタンスでは、定義されている`global`オブジェクトがリセットされます。そのため、コンテナーに関連付けられた`global`オブジェクト内のすべての代入宣言には、初期化のプロビジョニングも含まれる必要があります。

<Card title="ベストプラクティス">

柔軟なパフォーマンスを確保するために、Auth0はサーバーレスWebtaskコンテナを随時提供し、それらのコンテナは各種の再利用ポリシーの対象となります。一般的に、`global`オブジェクトの寿命は20分より短いと想定することをお勧めします。

</Card>

## セキュリティ

### カスタムAPIを使ってレガシーIDストレージにアクセスする

レガシーIDストレージを一般のアクセスから保護することは、ベストプラクティスとして推奨されています。たとえば、インターネットにデータベースを公開することは、SQLなどのデータベースインターフェイスが機能性の面で極めて開放的になるため、最小特権の原則（PoLP：Principle of Least Privilege）に違反することになります。

<Card title="ベストプラクティス">

APIを実装してレガシーのidentity store（データベース）への最小権限を与えることをお勧めします。インターネットを介して全般にアクセスできるようにはしないでください。

</Card>

別の方法としては、アクセストークンを使って保護できるように、簡単な（カスタムの）APIを作成して、それぞれのアクションスクリプトが呼び出せるようにします。これは、レガシーIDストアへのインターフェイスとして機能します。そして、スクリプト内からアクセストークンを取得するには、クライアント資格情報付与フローを使うことができます。性能を向上させるために、これはその後`global`オブジェクト内で再利用のためにキャッシュされます。APIは個別の保護されたエンドポイントを提供して、必要なレガシー管理の機能性（`read user`、`change password`など）だけを専用に処理します。

<Card title="ベストプラクティス">

認証に成功し、適切なオーディエンスが含まれている場合、Auth0はデフォルトで任意のAPIのトークンを提供します。ルールを使ってアクセストークンの割り当てを制限し、レガシーのidentity store APIへのアクセスを制限すれば、`/authorize`へのリダイレクトが傍受されてAPIにオーディエンスが追加されるなど、不正使用を防止できるだけでなく、さまざまな攻撃ベクトルのシナリオを軽減できます。

</Card>

### レガシーIDストレージにAllowListでアクセスする

レガシーIDストアへのアクセスに、カスタムのAPIと提供しているネイティブインターフェイスのどちらを使う場合でも、Auth0テナントに関連付けられているIPアドレスのリストを使って、アクセスを制限することが推奨されます。AllowListはレガシーIDストアへのアクセスを制限し、Auth0で定義されているカスタムデータベースのアクションスクリプトのみが許可されることを確実にします。

<Warning>

Auth0 IPアドレスAllowListは、1つのリージョンに定義されたすべてのAuth0テナント間で共有されます。許可リストを、レガシーのIDストアへのアクセスを保護するための唯一の方法として使用することは、絶対にしないでください。認可されていないアクセスをユーザーに許してしまい、潜在的なセキュリティの脆弱性を発生させる恐れがあります。

</Warning>

## もっと詳しく

* [カスタムデータベース接続を作成する](/ja-jp/authenticate/database-connections/custom-db/create-db-connection)
* [カスタムデータベースのアクションスクリプト用テンプレート](/ja-jp/authenticate/database-connections/custom-db/templates)
* [カスタムデータベースのトラブルシューティング](/ja-jp/authenticate/database-connections/custom-db/error-handling)
* [ユーザーのインポートとエクスポート](/ja-jp/manage-users/user-migration)