---
title: "Auth0.swift：トークンを保存および更新する"
permalink: "auth0-swift-save-and-renew-tokens"
'description': "Auth0.swiftでユーザーをログインした状態にする"
'og:title': "Auth0.swift：トークンを保存および更新する"
'og:description': "Auth0.swiftでユーザーをログインした状態にする"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Auth0.swift：トークンを保存および更新する"
'twitter:description': "Auth0.swiftでユーザーをログインした状態にする"
---

`offline_access`スコープを含んだまま認証を行う場合、ユーザーに再び資格情報を求めることなく新しいトークンの要求に使用できるリフレッシュトークンが返されます。

## 資格情報マネージャー

[Auth0.swift](https://github.com/auth0/Auth0.swift)には、資格情報の保存と更新プロセスを合理化するためのユーティリティクラスが用意されています。`accessToken`または`idToken`プロパティには、[［Credentials（資格情報）］](https://github.com/auth0/Auth0.swift/blob/master/Auth0/Credentials.swift)インスタンスからアクセスすることができます。これは、ユーザー資格情報を管理する上で推奨される方法です。

まず、`Auth0`モジュールをインポートします。

`import Auth0`

次に、ユニバーサルログインページを表示します。

```swift lines
let credentialsManager = CredentialsManager(authentication: Auth0.authentication())

Auth0
    .webAuth()
    .scope("openid profile offline_access")
    .start { result in
        switch result {
        case .success(let credentials):
            // Pass the credentials over to the Credentials Manager
            credentialsManager.store(credentials: credentials)
        case .failure(let error):
            // Handle error
        }
}
```

<Warning>

キーチェーン項目は、アプリをアンインストールしても削除されません。アプリの初回起動時に必ずすべてのキーチェーン項目を消去するようにしてください。

</Warning>

### 資格情報の確認

アプリの起動時にクイックチェックを実行して、マネージャーに更新可能な資格情報が保存されていることを確認すると便利です。保存されていない場合は、ユーザーを認証画面に移動できます。

```swift lines
guard credentialsManager.canRenew() else {
    // Present login page
}
```

### ユーザーの資格情報の取得

ユーザーの資格情報は以下のようにして取得できます。

```swift lines
credentialsManager.credentials { result in 
    switch result {
    case .success(let credentials):
        // Valid credentials; you can access token properties such as
        // `idToken`, `accessToken`
    case .failure(let error):
        // Handle error, present login page
    }
}
```

ユーザーの資格情報の更新は、トークンが期限切れになったときとまったく同じように行われます。資格情報マネージャーが資格情報を自動的に更新し、更新された資格情報をキーチェーンに保存して、資格情報かエラーのいずれかを含む`Result`を返します。

## 代替の方法 - SimpleKeychain

このセクションは、資格情報マネージャーを使用したくない開発者向けです。システムキーチェーンより軽いラッパーであるSimpleKeychainユーティリティが含まれており、トークンを安全に保存するために使用できます。

まず、`SimpleKeychain`モジュールをインポートします。

`import SimpleKeychain`

次に、インスタンスを作成して、必要なトークンを保存します。この場合、認証に成功した後、キーチェーンに`access_token`と`refresh_token`を保存します。

```swift lines
let keychain = SimpleKeychain(service: "Auth0")

Auth0
    .webAuth()
    .scope("openid profile offline_access")
    .start { result in
        switch result {
        case .success(let credentials):
            guard let refreshToken = credentials.refreshToken else { 
                // Handle error 
                return
            }
            // Store the tokens
            do {
                try keychain.set(credentials.accessToken, forKey: "access_token")
                try keychain.set(refreshToken, forKey: "refresh_token")
            } catch {
                // Handle error
            }
            // You might want to route to your app's main flow at this point
        case .failure(let error):
            // Handle error
        }
}
```

これらを保存したら、いつでも新しい[Credentials](https://github.com/auth0/Auth0.swift/blob/master/Auth0/Credentials.swift)インスタンスを要求できます。

### ユーザーの資格情報の更新

```swift lines
let keychain = SimpleKeychain(service: "Auth0")

Auth0
    .authentication()
    .renew(withRefreshToken: refreshToken)
    .start { result in
        switch(result) {
        case .success(let credentials):
            // If you have Refresh Token Rotation enabled, you get a 
            // new refresh token
            // Otherwise you only get a new access token
            guard let refreshToken = credentials.refreshToken else { 
                // Handle error 
                return
            }
            // Store the new tokens
            do {
                try keychain.set(credentials.accessToken, forKey: "access_token")
                try keychain.set(refreshToken, forKey: "refresh_token")
            } catch {
                // Handle error
            }
        case .failure(let error):
            // Handle error
        }
}
```

