---
title: "どちらのOAuth 2.0フローを使用するべきですか？"
permalink: "which-oauth-2-0-flow-should-i-use"
'description': "ユースケースに合わせて適切なOAuth 2.0フローを判断する方法について説明します。"
'og:title': "どちらのOAuth 2.0フローを使用するべきですか？"
'og:description': "ユースケースに合わせて適切なOAuth 2.0フローを判断する方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "どちらのOAuth 2.0フローを使用するべきですか？"
'twitter:description': "ユースケースに合わせて適切なOAuth 2.0フローを判断する方法について説明します。"
---

[OAuth 2.0の認可フレームワーク](/ja-jp/authenticate/protocols/oauth)は、複数の異なるフロー（または付与）をサポートしています。 <Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=flow" tip="フロー: アクションを使用して拡張できるプロセス。各フローはそれぞれ1つ以上のトリガーで構成され、Auth0手順の単一ポイント中に情報が移動する論理パイプラインを表します。" cta="用語集の表示">フロー</Tooltip>はアクセストークンを取得する方法です。ユースケースに合ったものがどれかを判断する場合、主に[アプリケーションタイプ](/ja-jp/get-started/applications)に左右されますが、クライアントへの信頼度やユーザーに届けたいエクスペリエンスといった、他の要因も重要になります。

## OAuth 2.0の用語

* **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" href="/ja-jp/glossary?term=resource-owner" tip="リソース所有者: 保護されたリソースへのアクセスを許可できるエンティティ（ユーザーやアプリケーションなど）。" cta="用語集の表示">Resource Owner</Tooltip>（リソース所有者）** ：保護されたリソースへのアクセス権を付与できるエンティティ。大抵の場合、エンドユーザーです。
* **Client （クライアント）** ：リソース所有者の代わりに保護されたリソースへのアクセス権を要求するアプリケーション。
* **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-2" href="/ja-jp/glossary?term=resource-server" tip="リソースサーバー: 保護されたリソースをホストするサーバー。リソースサーバーは保護されたリソースの要求を受け入れ、応答します。" cta="用語集の表示">Resource Server</Tooltip>（リソースサーバー）** ：保護されたリソースをホストするサーバー。アクセスしたいAPIのことです。
* **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-3" href="/ja-jp/glossary?term=authorization-server" tip="認可サーバー: ユーザーによるアクセスの限界を定義するために使用される集中管理型サーバー。たとえば、認可サーバーは、ユーザーが利用できるデータ、タスク、機能を制御できます。" cta="用語集の表示">Authorization Server</Tooltip>（認可サーバー）** ：リソース所有者を認証し、適切な認可を得た後にアクセストークンを発行するサーバー。この例では、Auth0です。
* **User Agent（ユーザーエージェント）** ：リソース所有者がクライアント（ブラウザーやネイティブアプリケーションなど）を操作するのに使用するエージェント。

## クライアントはリソース所有者ですか？

最初の判断のポイントは、リソースにアクセスが必要な関係者がマシンかどうかです。マシンツーマシンの認可の場合、クライアントもリソース所有者であるため、エンドユーザーの認可は必要ありません。たとえば、APIを使用して情報をデータベースにインポートするcronジョブです。この例では、cronジョブはクライアントであり、リソース所有者です。その理由は、クライアントがクライアントIDとクライアントシークレットを持っていて、認可サーバーからアクセストークンを取得するのにそれらを使用しているからです。

これに該当するのであれば、このフローの仕組みと実装方法については、「[クライアントの資格情報フロー](/ja-jp/get-started/authentication-and-authorization-flow/client-credentials-flow)」を参照してください。

## クライアントは、サーバー上で実行されているWebアプリですか？

クライアントがサーバー上で実行されている一般的なWebアプリであれば、認可コードフローが適しています。このフローを使用すれば、クライアントはアクセストークンを取得できる上に、リフレッシュトークンも任意で取得できます。アクセストークンはクライアントをホストしているWebサーバーへ直接渡されるため、最も安全な選択だと考えられています。ユーザーのWebブラウザーが関わることはなく、暴露のリスクもありません。

これに該当するのであれば、このフローの仕組みと実装方法については、「[認可コードフロー](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow)」を参照してください。

## クライアントはユーザーの資格情報で絶対的に信頼できるものですか？

決定のポイントは、リソース所有者のパスワード資格情報付与の処理結果になります。このフローでは、エンドユーザーは資格情報（識別子とパスワード）を、通常は対話型フォームを使用して提供するように要求されます。この情報はバックエンドに送信され、そこからAuth0へ送信されます。このため、この情報を扱うのにクライアントが絶対的に信頼できることが不可欠です。

この付与の使用は、（[認可コードフロー](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow)のような）リダイレクトベースのフローが使用できない場合にのみ限定すべきです。これに該当するのであれば、このフローの仕組みと実装方法については、「[リソース所有者のパスワードフロー](/ja-jp/get-started/authentication-and-authorization-flow/resource-owner-password-flow)」を参照してください。

## クライアントはシングルページアプリですか？

クライアントがシングルページアプリ（SPA）であれば、JavaScriptなどのスクリプト言語を使用してブラウザーで実行されているアプリケーションであることになり、付与には2つのオプションがあります。Proof Key for Code Exchange（PKCE）を使った認可コードフロー、そして、フォームPOSTを使った暗黙フローです。ほとんどの場合、PKCEを使った認可コードフローの使用をお勧めします。アクセストークンがクライアント側で暴露されることがない上に、このフローが[リフレッシュトークン](/ja-jp/secure/tokens/refresh-tokens)を返すことができます。

このフローの仕組みと実装方法については、「[Proof Key for Code Exchange（PKCE）を使った認可コードフロー](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)」を参照してください。[Auth0のシングルページアプリSDK](/ja-jp/libraries/auth0-single-page-app-sdk)は、シングルページアプリでPKCEを使った認可コードフローを実装するのに、高水準のAPIを提供します。

SPAにアクセストークンが必要ないのであれば、フォームPOSTを使った暗黙フローを使用することができます。このフローの仕組みと実装方法については、「[フォームPOSTを使った暗黙フロー](/ja-jp/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)」を参照してください。

## クライアントはネイティブ/モバイルのアプリですか？

アプリケーションがネイティブアプリの場合は、**Proof Key for Code Exchange（PKCE）を使った認可コードフロー** を使用してください。

このフローの仕組みと実装方法については、「[Proof Key for Code Exchange（PKCE）を使った認可コードフロー](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)」を参照してください。

## アプリケーションが複数の異なるリソースサーバーと通信する必要があります。

1つのアプリケーションが異なるリソースサーバーのアクセストークンを必要とする場合は、`/authorize`を複数回呼び出す（つまり、同じまたは異なる認可フローの複数回実行）必要があります。それぞれの認可では異なる`audience`値が使用されるため、フローの最後に生成されるアクセストークンも異なります。詳細については、「[OAuth 2.0:Audience Information](https://tools.ietf.org/html/draft-tschofenig-oauth-audience-00#section-3)」の仕様を参照してください。

## アプリケーションを実装する前に、エンドポイントを試してみることができますか？

もちろんです！[Authentication APIのデバッグ拡張機能](/ja-jp/customize/extensions/authentication-api-debugger-extension)を使用することができます。`/grant`エンドポイントについての詳しい指示は、「[Authentication APIリファレンス](/ja-jp/api/authentication)」に記載されています。

* 認可エンドポイントについては、「[アプリケーションを認可する](/ja-jp/api/authentication#authorize-application)」に記載の「このエンドポイントをテストする」段落をお読みください。
* トークンエンドポイントについては、「[トークンを取得する](/ja-jp/api/authentication#get-token)」に記載の「このエンドポイントをテストする」段落をお読みください。

## クライアントアプリケーションはブラウザーとの対話なしでユーザーをチャレンジして認証する必要がありますか？

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

現在、クライアントが開始するバックチャネル認証は早期アクセスで利用できます。CIBAを有効化するには、テクニカルアカウントマネージャーまでお問い合わせください。

</Callout>

クライアントが開始するバックチャネル認証フロー（CIBA）は、[OpenID Connect](https://openid.net/developers/how-connect-works/)に対する代替の認証フローを実装する<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=openid" tip="OpenID: アプリケーションがログイン情報を収集および保存することなくにユーザーのIDを検証できるようにする認証用のオープン標準。" cta="用語集の表示">OpenID</Tooltip> Foundationの標準です。CIBAは次の点で標準のOpenID Connectフローと異なります。

* クライアントアプリケーションがエンドユーザーに代わって認証プロセスを開始する。
* ブラウザーにユーザーインタラクションが不要である。
* クライアントアプリケーションとOpenIDプロバイダーが直接通信する。

CIBAは、ユーザーがクライアントアプリケーションを信頼できない、クライアントアプリケーションにブラウザーがない、またはユーザーが認証を必要とするアプリケーションの前にいない際に役立ちます。以下でCIBAフローが使用できる例をご紹介します。

* **販売端末でのユーザーのチェックイン：** クリック＆コレクトのシナリオで、ユーザーは公共のキオスクで認証し、存在を確認できます。
* **コールセンターまたは担当者デスクでの認証：** コールセンターののオペレーターは認証フローを開始し、 発信者を認証できます。通常、スマートフォンのカスタムモバイルアプリを使用します。
* **入力なしでデバイスでの認証：** たとえば、スマートスピーカー（または接続された別のデバイス）はバックエンドサービスを利用して、ユーザーにコンタクトし認証できます。通常、スマートフォンのカスタムモバイルアプリを使用します。

CIBAにより2つのデバイスが定義されます。

* **消費デバイス** ：ユーザーがサービスを使用できるようにするデバイス。
* **認証デバイス** ：ユーザーが認証、同意の付与を行うデバイス。

詳細については、「[クライアントが開始するバックチャネル認証フロー](/ja-jp/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow)」をお読みください。