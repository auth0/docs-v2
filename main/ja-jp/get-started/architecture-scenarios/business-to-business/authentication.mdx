---
title: "認証（B2B）"
permalink: "authentication"
'description': "B2BのIAM実装で認証が行われる仕組みについて説明します。"
'og:title': "認証（B2B）"
'og:description': "B2BのIAM実装で認証が行われる仕組みについて説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "認証（B2B）"
'twitter:description': "B2BのIAM実装で認証が行われる仕組みについて説明します。"
---

ユーザーにサービスを提供するためには、ユーザーが誰なのかを識別する必要があります。この処理はユーザー認証と呼ばれます。ソーシャルメディアのアカウント、ユーザー名とパスワード、パスワードレスなど、ユーザー認証にはいくつかの方法があります。また、多要素認証（<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=multifactor-authentication" tip="多要素認証（MFA）: ユーザー名とパスワードに加えて、SMS経由のコードなどの要素を使用するユーザー認証プロセス。" cta="用語集の表示">MFA</Tooltip>）を有効にして、ユーザーを認証する際に第一要素のみに依存しないことが推奨されています。

<Info>
  ### ベストプラクティス

ユーザーの認証方法を設計する際にセキュリティとユーザーエクスペリエンスの両方を考慮することは重要です。複数のプライマリ要素を提供し、および/または認証中に複数の要素を強制することで、両方を提供できます。

</Info>

機能性とワークフローを検討する際には、以下のように、考慮するべき事柄がいくつかあります。

* ユーザーがどこで資格情報を入力するのか
* ユーザーに関する資格情報の安全性をどのようにして確保するのか
* 認証システムをどのようにして維持するのか
* ユーザーにパスワード認証をどのようにして提供できるのか
* ハッカーがユーザーと偽ってログインすることをどのようにして防ぐのか
* 異なる種類のアプリケーションで、どのようにして認証を実装するのか
* 異なる言語を使用するユーザーのために、どのようにしてログインしやすくできるのか
* レガシーの認証システムから移行する際に、どのようにして良好なユーザーエクスペリエンスを提供するのか
* アプリケーションをAuth0と統合する際に、どのようなことを考慮するべきなのか
* 多要素認証（MFA）を提供する必要があるのか
* ユーザーが事前にログインする方法をサービスが提供できない場合にはどうするのか
* ユーザーについて、同じアクセストークンを1つのAPIから別のAPIへ渡すことができるのか
* 組織ごとにユーザーの分離が必要な場合にはどうするのか
* ユーザーが所属する組織の識別をどのようにして処理するのか
* 組織にエンタープライズ接続を提供することに、どのような利点があるのか

Auth0の[ユニバーサルログイン](#universal-login)は、サインインにユーザーIDとパスワードの資格情報を提供するのか、いわゆるBring Your Own Identity（BYOI：個人IDの持ち込み）のシナリオで[ソーシャルログイン](https://auth0.com/learn/social-login/)を許可するのかといった方法にかかわらず、安全でセキュリティー保護されたユーザーエクスペリエンスを提供します。また、製品固有の[ブランディング](/ja-jp/get-started/architecture-scenarios/business-to-consumer/branding)要件がある場合でも、ユニバーサルログインでログインエクスペリエンスを中央集中化すると、ブランドの認知度を高める効果もあります。ユニバーサルログインで通常使用されるAuth0のUIウィジェットには、そのままで便利に使える対応として、異なる言語が要求されるユーザー向けの[国際化](/ja-jp/customize/internationalization-and-localization/universal-login-internationalization)、ユーザーアカウントにアクセスしようとするハッカーからの保護障壁となる[MFA](#multi-factor-authentication-mfa-)や[攻撃防御](#anomaly-detection)も備わっています。

ユーザーIDとパスワードの資格情報を使ってサインインできるようにすることは、サードパーティーIDプロバイダーのステータスに依存することなく、ユーザーによるシステムへのアクセスを許可することになります。また、会社の方針に合致した資格情報を要求する手段にもなります。これが実現できるように、Auth0には、ユーザーIDとパスワードのログインに対応する複数のオプションがあります。また、[提供しているガイダンス](#username-and-password-authentication)には、それらのオプションを活用する方法が説明されています。追加の主要な認証要素として、何らかのステージで[ソーシャル](#social-authentication)対応を追加すると、柔軟性が高まり、各種のソーシャルログイン[プロバイダー](/ja-jp/connections/identity-providers-social)がすでに保管している情報を活用して、ユーザーに質問することなく、ユーザーについての理解を深めることができます。

既存のレガシーIDストアがある場合には、「[ユーザーの移行](/ja-jp/get-started/architecture-scenarios/business-to-consumer/provisioning)」も併せて参照してください。そのセクションには、安全性とセキュリティー保護の面で、Auth0が管理するIDストレージへ移行することの利点が説明されています。

顧客向けのアプリケーションでは、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=openid" tip="OpenID: アプリケーションがログイン情報を収集および保存することなくにユーザーのIDを検証できるようにする認証用のオープン標準。" cta="用語集の表示">OpenID</Tooltip> Connect（[OIDC](/ja-jp/authenticate/protocols/openid-connect-protocol)）が最も広く使われている業界標準プロトコルであり、Auth0でも第一級オブジェクトの対応を提供しています。Auth0は、さまざまなアプリケーションを統合できるように、さまざまな方法に対応しています。[アプリケーションの統合](#application-integration)に関するセクションで必要な情報を確認し、よく理解したうえで選ぶことをお勧めします。

1つ以上のcronジョブ、レポートの生成機能、CI/CD（継続的インテグレーション/継続的デリバリー）システムなど、認証済みのユーザーが存在しないあらゆる状況で1つのAPIから別のAPIを呼び出す際には、ユーザーではなく、アプリケーションを認証する方法が必要になります。これは、1つの呼び出しでアプリケーションが認証（クライアントIDとシークレットを使用）されて認可されるという、1ステップのプロセスです。詳細については、「[マシンツーマシン（M2M）認可](/ja-jp/get-started/architecture-scenarios/business-to-business/authorization)」に記載の認可処理ストリームを参照してください。

会社で組織ごとにユーザーを分離させる必要があったり、あるいは1人のユーザーが複数の組織にアクセスできたりすることがあります。自社がどちらのシナリオに該当するのかが分かると、ユーザーが存在する接続、実行の必要性、必要なタイミング、達成方法をどのようにして判断するのか決めやすくなります。該当するかどうかの判断には、「[ホームレルムディスカバリー（HRD）](#home-realm-discovery)」を参照してください。

## ユニバーサルログイン

システムにアプリケーションが複数存在するか、複数作成する予定の場合には、サインインエクスペリエンスを中央に集中させることが得策です。複数のアプリケーション間でシングルサインオン（<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=single-sign-on" tip="シングルサインオン（SSO）: ユーザーが1つのアプリケーションにログインした後、そのユーザーを他のアプリケーションに自動的にログインさせるサービス。" cta="用語集の表示">SSO</Tooltip>）エクスペリエンスをシームレスするには、認証に一本化したユーザーのリダイレクト先を設けることが重要です。そうすることで、今後ソーシャル認証を追加したり、システムにサードパーティーのアプリケーションを追加したり、ユーザーに対するオプション（または要件）として多要素認証を追加したりする場合でも、ユーザーエクスペリエンスの一貫性が保たれます。また、ユーザーエクスペリエンスを向上させるために、開発をほとんど行うことなく新しい機能を活用できようになります。

<Info>
  ### ベストプラクティス

1つ以上のアプリケーションがある場合、ベストプラクティスは、[「一元化された場所」](/ja-jp/universal-login)にリダイレクトし、ユーザーを認証することです。Auth0を使用する場合、これは[ユニバーサルログイン](/ja-jp/universal-login)を活用することを意味します。[SSO](/ja-jp/sso/current)を含む多くのセキュリティとユーザーエクスペリエンスの利点が、すぐに利用できます。

</Info>

Auth0のユニバーサルログインでは、ユーザーの認証が以下の手軽な3ステップで完成し、プロセスが短く簡単になります（Quickstartsに実践的な説明があります。また、SDKを使うと複雑な手間を省くことができます）。

1. [アプリケーションからのリダイレクト](#application-integration)がいつどのようにして行われるかを決めます。
2. Auth0の構成で、適切な[ブランディング](/ja-jp/get-started/architecture-scenarios/business-to-consumer/branding)やHTMLのカスタマイズをセットアップします。
3. 認可サーバーから[応答を受け取って処理](#application-integration)するように、アプリケーションをセットアップします。

## ホームレルムディスカバリー（HRD）

ホームレルムディスカバリー（HRD）は、認証に先だって、ユーザーがどのIDプロバイダー（またはAuth0の接続）に属しているのかを識別するプロセスです。HRDの実行には以下の2通りがあります。

* アプリケーションで決定する方法を提供する
* ユニバーサルログインページでHRDを処理する

システムにいずれかまたは両方の手段が必要かもしれないため、アプリケーションに最適なものを実装できるように、HRDのどちらの方法も理解することが大切です。

### アプリケーション主導のHRD

ユーザーが属するレルムを判断する方法として最も一般的なのは、それぞれの組織について、アプリケーションにブランドがある場合です。ブランディングの一環として、組織には通常独自のアプリケーションインスタンスがあり、異なるURLを使ってアクセスされます。このコピーやインスタンスは物理的に分離（別のサーバーセット上で実行）、または仮想的に分離（共有のサーバー上で実行）され、通常はカスタムのホスト名（`companyA.application1.yourcompany.com`）またはパス（`application1.yourcompany.com/companyA`）で示されます。

<Info>
  ### ベストプラクティス

アプリケーションが既に必要な特定の接続（IdP）を把握している場合、ユーザーを`/authorize`にリダイレクトする際に`connection`クエリパラメータを使用して渡すこともできます。

</Info>

アプリケーションにこれが該当する場合、HRDの処理は単に`org_id`をアプリケーション特定の構成と共に保管し、ユーザーをユニバーサルログインにリダイレクトする際にそれを組織のパラメーターとして送信するだけになります。そうすることで、ユーザーが特定の組織とその構成にある接続のみに制約されます。

<Info>
  ### ベストプラクティス

Organizationが2つ以上のIdPを必要とする場合、2巡目のHome Realm Discovery（ホーム領域検出）を行う必要があるでしょう（そのOrganizationが識別された場合）。［Organization機能］を使用している場合には、Auth0がこのタスクを管理することが一般的です。

</Info>

ユーザーが1つのIDを使って複数の組織で共有されている場合には、[ユニバーサルログインページをHRD](#hrd-through-universal-login)に対応させる必要があります。ユニバーサルログインはユーザーを識別してから、そのユーザーに適したレルムを表示するため、ユーザーエクスペリエンスの向上に繋がります。

組織や接続のパラメーターは、ユーザーを`/authorize`エンドポイントにリダイレクトする際にクエリパラメーターとして追加することにより送信できます。詳細については、[Authentication APIのドキュメント](/ja-jp/api/authentication#authorization-code-flow)を参照してください。一般的に、アプリケーションの作成に使った言語が何であっても、これにはSDKを活用することができます。

### ユニバーサルログインを使ったHRD

HRDには主に以下の3つの方法があります。

* ユーザーのメールのサブドメインを使ってレルムを特定する
* 識別子とレルムがマッピングされた何らかのマップでユーザーの識別子を探してレルムを特定する
* ユーザーが自分のレルム（または組織）を選んで入れるようにする

最初の2つの方法では、「Identifier Firstログイン」の実行を検討することができます。つまり、先に識別子を入力できるような機能性のみを提供します。その後、ユーザーの識別子を収集し、識別子に応じてユーザーを自動的にリダイレクトするか、リダイレクトが不要な場合にはユーザーがパスワードを入力できるようにします。Auth0には、これをすべて行うのに、変更することなくそのまま使える実装があり、[ユニバーサルログイン](/ja-jp/authenticate/login/auth0-universal-login/identifier-first)を使用します。

<Warning>

識別子先行ログインを実装すること、つまり、ユニバーサルログインページではなくアプリケーションでユーザーに自分の組織を選択してもらうことは可能ですが、それをするとシングルサインオンが複雑になるだけでなく、同じ動作をすべてのアプリケーションで複製することが複雑になります。そのためAuth0では、代わりにユニバーサルログインを通じて何らかの形式のHRDを実装することを推奨しています。

</Warning>

#### ユニバーサルログインを使ったHRDにメールのサブドメインを使用する

ユニバーサルログインページにHRDを実装する最も簡単な方法は、ユーザーの識別子にあるメールのサブドメインを利用して、それをページのIDプロバイダーにマッピングすることです。もちろん、これはメールのサブドメインと組織、または少なくともIDプロバイダーが1対1でマッピングされる状況でのみ有効になります。

エンタープライズ接続にドメインのマップがある場合、Auth0の[Lock](/ja-jp/libraries/lock)ウィジェットや[ユニバーサルログイン](/ja-jp/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience)はこれを処理できますが、独自に構築したいのであれば手動で処理することもできます。ただし、その場合には、メールのサブドメインと接続のマッピングを構築する必要があります。

また、ユニバーサルログインエクスペリエンスを使う際には、[Organizations機能](/ja-jp/manage-users/organizations/organizations-overview)が以下の2つの点で役立ちます。

1. ログイン要求を始める際にorg_idが`/authorize`エンドポイントに渡されなかった場合、Auth0はユーザーが属する組織の入力をユーザーに求めます。
2. Organizationに複数のIdPが関連付けられている場合、Auth0は組織を選択するボタンか、ユーザー名とパスワードを入力するフォームをユーザーに提供します。

#### ユニバーサルログインを使ったHRDに識別子とレルムのマッピングを使用する

2つ目の、より複雑な方法としては、識別子と<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-2" href="/ja-jp/glossary?term=idp" tip="IDプロバイダー（IdP）: デジタルIDを保存および管理するサービス。" cta="用語集の表示">IdP</Tooltip>のマッピングを保管して、パブリックエンドポイントにその情報へのアクセスを提供するというものがあります。そして、ユニバーサルログインページでは、接続を見つけてから、その接続を使って/authorizeエンドポイントにリダイレクトで戻します。この方法の主な欠点は遅延があること、そして、より重大な欠点は、識別子の発見に伴うセキュリティ保護です。メールアドレスを使っている場合は、この方法で、特定のメールアドレスと所属するユーザーとの関連性が発見しやすくなります。

<Info>
  ### ベストプラクティス

ハッカーが情報を発見するために使用するのを防いだり、サービス拒否攻撃を防止するには、いかなる公開エンドポイントにもレート制限を適用すべきです。

</Info>

#### ユニバーサルログインを使ったHRDにユーザー選択を使用する

上記の他に、プロダクトを使用している組織のリストが公開されたり、ユーザーが自分の組織名を明示的に入力できたりしても構わないのであれば、ユーザーがリストから選択できるようにするというオプションもあります。これは通常、ユーザーをユニバーサルログインにリダイレクトする前に行われます。ユーザーが所属する組織を選択すると、その組織の接続でAuth0にリダイレクトすることができます。データベース接続の場合には、Auth0にユーザーのユーザー名とパスワードを要求させることができます。

## ユーザー名とパスワードの認証

ほとんどすべてのB2Cアプリケーションは、顧客が新しい資格情報セットを作成できる機能性を提供しています。すべてのユーザーに慣れ親しまれている、一般的な認証形式です。

Auth0には、さまざまなユーザー名とパスワードの認証があります。アプリケーションが生まれたばかりで、既存のユーザーベースがない場合には、Auth0提供のそのままで使える簡素な[データベース接続](/ja-jp/connections/database)が、ユーザーを認証し始めるのに必要なすべてを備えており便利です。しかし、レガシーのユーザーストア（独自のユーザーデータベースや既存のLDAPシステムなど）がある場合、「[ユーザーの移行](/ja-jp/get-started/architecture-scenarios/business-to-business/provisioning)」のガイダンスにもあるように、ユーザーを移行する2つの方法があります。

データベース接続のためにユーザーをどのようにプロビジョニングしたとしても、ユーザー認証は非常に似通っています。ユーザー名とパスワードの入力フォームをユーザーに提供する必要があります。[ユニバーサルログイン](#universal-login)のガイダンスでも説明したように、ユーザー名とパスワードを使ったユーザー認証で最もシンプルかつ安全な方法は、中央管理のログインページにリダイレクトして、そこでユーザー名とパスワードを収集することです。そうすると、Auth0がすでに認証済みかを判断し、必要でない場合にはログインフォームを完全にスキップできるようになります。

<Info>
  ### ベストプラクティス

一元化されたログインページでのみ資格情報を収集することで、ユーザーの機密情報が漏洩する可能性を減らすことができます。不要に資格情報を収集する必要性を減らすこともできます。詳細は[「ユニバーサルログイン」](#universal-login)をご覧ください。

</Info>

## アプリケーションの統合

ユーザーをどのようにして認証したいかが決まったら、次のステップとして、認証をどのように始めるのかを決定します。一般的に、アプリケーションにはそれぞれ独自の始点があります。

<Warning>

ネイティブモバイルアプリケーション（とデスクトップアプリケーション）は、認証にシステムブラウザーを使用しなければなりません。そうしないと、セキュリティリスクが高まります。詳しくは、[モバイルでのネイティブとブラウザーのログインの比較](https://auth0.com/docs/design/browser-based-vs-native-experience-on-mobile)を参照してください。

</Warning>

上でも述べたように、顧客向けのアプリケーションでは、ほとんどの顧客が[OpenID Connect（OIDC）](/ja-jp/authenticate/protocols/openid-connect-protocol)を業界標準プロトコルとして使用しています。どのOIDCフローを使うのか見当をつけるためには、まず、[付与のマッピング](/ja-jp/get-started/applications/application-grant-types)に関するガイダンスを確認してください。

アプリケーションのどこか一部を匿名のユーザーにも使えるようにしたい場合には、即座にリダイレクトするのか、必要なときにだけユーザーにリダイレクトを促すのか（またはその2つを何らかの形で組み合わせたものにするのか）を決める必要があります（詳細は「[ログイン後にユーザーをリダイレクトする](/ja-jp/authenticate/login/redirect-users-after-login)」を参照）。ユーザーがサイトの保護されたバージョン（または領域）に[ディープリンク](#deep-linking-to-protected-endpoints)できる場合には、結果的にAuth0に自動リダイレクトされる、アプリケーションへのリンクを行うかどうか決める必要があります。

### 匿名アクセス

アプリケーションを初めて使うユーザーのユーザーエクスペリエンスを考慮することは重要です。アプリケーションが匿名ユーザーに対応している場合（Eコマースのアプリケーションでは一般的）には、以下のように、考慮するべきシナリオがいくつかあります。

* すでにログインしたことがあり、アプリケーションに戻って来ている
* アプリケーションに初めてアクセスしている

  + 同じAuth0テナントを使用した別のアプリケーションにすでにアクセスしたことがあるか
  + これまでに（または最近）そのデバイスまたはブラウザーを使って認証したことがあるか

匿名ユーザーがアプリケーションにアクセスする際には、ユーザーがすでに同じ系列の別のアプリケーションにログイン済みかをアプリケーションが発見できる、または、アプリケーションが状態のない[SPA](/ja-jp/quickstart/spa)だとしても、ユーザーを覚えていることができる方が望ましいことがよくあります。たとえば、ユーザーがすでにログイン済みだと分かれば、アプリケーションのUIヘッダーにログインボタンを表示しないで、代わりにユーザーのアカウントやプロファイルのメニューを表示することができます。これを行うには、「[サイレント認証](/ja-jp/authenticate/login/configure-silent-authentication)」を活用することになります。サイレント認証を使用すると、ユーザーにログインを促すことなく、ユーザーがログイン済みかを確認できます。ログインしていない場合、アプリケーションは必要に応じてログインボタンを表示することができます。ユーザーがすでにログイン済みの場合には、トークンを受け取るため、ログインボタンを再度ユーザーに表示する必要はありません。

<Warning>

Auth0にリダイレクトしてログインセッションを確認することはアプリケーションにとって役立ちますが、これによって大量の要求が発生する場合は、遅延やレート制限を回避するためにスロットリングメカニズムを採用する必要があります。

Management APIへの呼び出しには[Auth0レート制限ポリシー](https://auth0.com/docs/policies/rate-limits)が適用されることを考慮してください。Auth0は、通常、APIを直接呼び出す代わりに、開発環境に適した[Auth0 SDK](https://auth0.com/docs/libraries)を使用することを推奨しています。

</Warning>

### 保護されたエンドポイントにディープリンクする

認証されたユーザーにのみアクセス可能なアプリケーションについて、人はさまざまな理由から、特定のページに直接リンクしたいと考えます。これがアプリケーションで可能な場合、認証されていないユーザーは必ず自動的にAuth0にリダイレクトする必要があります。認証が終わると、認可サーバーはユーザーをアプリケーションに戻します。その際には、元々目的としていた場所に[ユーザーをリダイレクト](/ja-jp/authenticate/login/redirect-users-after-login)することができます。

<Info>
  ### ベストプラクティス

  ほとんどの新しい認証フレームワークは、Auth0などの認可サーバーにリダイレクトするためのミドルウェアをサポートしています。選択する際には、以下の点を考慮してください。

  * 機密クライアント、非機密クライアント、またはその両方のサポート
  * [検出エンドポイント](https://auth0.com/docs/ja-jp/get-started/applications/configure-applications-with-oidc-discovery 「OIDC Discoveryでアプリケーションを構成する」）または明示的なインラインを使った構成のサポート
  * 有効期限、署名、クレーム、およびスコープを含むトークン検証のサポート
  * 必要であれば、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" href="/ja-jp/glossary?term=refresh-token" tip="リフレッシュトークン: ユーザーに再度ログインを強いることなく、更新されたアクセストークンを取得するために使用されるトークン。" cta="用語集の表示">リフレッシュトークン</Tooltip>のサポート

</Info>

### ユーザーを認証する

認証とは、ユーザーの身元を特定するプロセスのことです。認証の結果は、OIDCではIDトークンになります。このトークンにはユーザーについての情報が含まれているため、認可サーバーに定義された1つ以上の要素（最も一般的なのは[ユーザーIDとパスワード](#username-and-password-authentication)）を使ってユーザーが認証するときにのみ取得可能でなければなりません。IDトークンの取得以外に、以下も併せて考慮する必要があるかもしれません。

* 共有のAPIを呼び出すのに[アクセストークン](/ja-jp/secure/tokens/access-tokens)も必要なのか
* アプリケーションがシングルページアプリケーション（SPA）で、[IDトークン](/ja-jp/secure/tokens/id-tokens)のみが必要なのか。詳細については、「[PKCEを使った認可コード付与](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce)」を参照してください。
* アプリケーションがネイティブアプリケーション（モバイルまたはデスクトップ）か、そして/または[リフレッシュトークン](/ja-jp/secure/tokens/refresh-tokens)が必要なのか。詳細については、「[PKCEを使った認可コード付与](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce)」を参照してください。

<Warning>

公開する前に、各アプリケーションで使用している付与**のみ** が[アプリケーションの構成](/ja-jp/get-started/applications/update-grant-types)で有効になっていることを確認してください。

</Warning>

### 認可コード付与（PKCEを使用または不使用）

SDKが認可コード付与のみに対応しているか、アクセストークンまたはリフレッシュトークンが必要な場合には、認可コード付与（[PKCE](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)を使用または不使用）を使ってIDトークンを取得することもできます。認可コード付与には、トークンのコードをやり取りする追加のAPI呼び出しが含まれているため、IDトークンだけが必要な場合には不要な遅延が発生するかもしれません。多くの場合、アクセストークンとリフレッシュトークンの安全な取得に認可コード付与のワークフローを活用しながら、IDトークンへのアクセスを最適化するために[ハイブリッドフロー](/ja-jp/get-started/authentication-and-authorization-flow/hybrid-flow)が実装されます。

<Warning>

Auth0では、IDトークンのみを必要とするブラウザーベースのアプリケーションに対して暗黙の付与を使用することが可能ですが、[PKCE](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)を使った認可コード付与を推奨しています。詳細については、Auth0ブログの「[OAuth2の暗黙の付与とSPA](https://auth0.com/blog/oauth2-implicit-grant-and-spa/)」を参照してください。

ユーザーを再認証することなく新しいアクセストークンやIDトークンを取得できるように[フレッシュトークン](/ja-jp/secure/tokens/refresh-tokens)が必要な場合は、[認可コード付与](/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow)を使用する必要があります。

</Warning>

## 攻撃の防御

認証システムが重要な理由は、悪意のある行為者が権限のないアプリケーションやユーザーデータにアクセスすることを防ぐためです。我々は、悪意のある行為者とシステムへのアクセスの間に、できる限り多くの障壁を配備したいと考えます。最も簡単な方法は、Auth0で[攻撃防御](/ja-jp/secure/attack-protection)を確実に正しく構成することです。そのためにも、このトピックに関するガイダンスを注意して読み、正しく動作していることを確認してください。

<Info>
  ### ベストプラクティス

Auth0では異常の検出を水面下で行っており、お客様の製品に優れた安全機能を提供しています。この機能を活用するには、ユーザーへのメール配信を開始する前に、[メールプロバイダー](/ja-jp/architecture-scenarios/b2b/operations#email-provider-setup)のセットアップと、[メールテンプレート](/ja-jp/architecture-scenarios/b2b/branding#email-template-customization)の構成を行ってください。

</Info>

## レガシーシステムを使ったSSO

大規模な再編成では、すべてのアプリケーションを一度に更新することが常に可能（または現実的）だとは限りません。実際に、Auth0との統合に関して推奨されるベストプラクティスは、繰り返し（反復的に）更新する方法で計画することです。アプリケーションがすでにシングルサインオン（SSO）を利用し、レガシーシステムがOIDCや<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" href="/ja-jp/glossary?term=security-assertion-markup-language" tip="Security Assertion Markup Language（SAML）: パスワードなしに二者間で認証情報を交換できる標準化プロトコル。" cta="用語集の表示">SAML</Tooltip>などのプロトコルに対応していて、Auth0と統合しながらもSSOを引き続き提供したい場合には、以下の2つのオプションがあります。

* レガシーのSSOシステムに既存のIDプロバイダーを更新して、ログイン（[SAML](/ja-jp/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)を使うなど）はAuth0にリダイレクトする
* ログインでは、Auth0がレガシーのSSOシステムにリダイレクトする。これには、レガシーシステムをAuth0でIdPとして構成（[SAML](/ja-jp/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)または[OIDC](/ja-jp/connections/identity-providers-social)を使用）する必要があります。

<Info>
  ### ベストプラクティス

旧来のシステムでSSOエクスペリエンスに対応するのは、複雑になる場合がありますが、Auth0と統合する際によりシームレスなユーザーエクスペリエンスを創り出すという点において行う価値があるでしょう。この方向に進む予定でしたら、早めに計画を立てることで達成が可能になります。まだ一元化されたサービスにSSOを導入されていない場合は、追加に伴う複雑さが利益に見合わない可能性が高いです。

</Info>

これは、現在使用しているレガシーアーキテクチャに合わせて追加で調査が要求される複雑な内容となるため、レガシーシステムで現在SSOに対応している場合にのみ検討することをお勧めします。注意：現在、アプリケーションから中央管理システムにリダイレクトしてユーザーを認証し、中央管理システムとのセッションがないときにのみ、そのシステムが資格情報を求める場合には、レガシーのSSOが実装されています。

## エンタープライズログイン

Bring Your Own Identity（BYOI：個人IDの持ち込み）のシナリオは、ほとんどすべてのB2Bアプリケーションに必須となりつつあります。ほとんどの大企業は、社員が別の資格情報セットを保管しなくてもいいように、独自のIdPをアプリケーションに統合することを期待しています。これは、セキュリティを危険にさらすことなく、ユーザー認証エクスペリエンスを簡素化できる貴重な方法です。[ユニバーサルログイン](#universal-login)を使用すると、変更に伴う影響を最小限に抑えつつ[エンタープライズ接続](/ja-jp/connections/identity-providers-enterprise)への対応を追加しやすくなります。

<Info>
  ### ベストプラクティス

ユーザーに対してエンタープライズ接続をサポートし始めたら、認証のためにユーザーを送る接続を決定できるように、[「Home Realm Discovey（ホーム領域検出）」](#home-realm-discovery)を行う必要があります。

</Info>

エンタープライズ接続に対応していると、ユーザーの身元や資格情報は顧客の組織のIDプロバイダーによって管理されます。特定のIDクレームも同様ですが、これはAuth0がユーザーの[プロファイル](/ja-jp/get-started/architecture-scenarios/business-to-business/profile-management)を入力する際に利用されます。

<Info>
  ### ベストプラクティス

「独自IDの使用」は提供する価値のある素晴らしい機能ですが、これを最初からサポートしていない場合、また場合によってはサポートしていても、長期間アプリケーションを使用してきた後では独自のIdPに切り替えたいOrganizationがあるかもしれません。旧来のデータベースIDに新しいIDを関連付ける効果的な方法を提供するためには、[ユーザーアカウントをリンクする](/ja-jp/users/concepts/overview-user-account-linking)方法が必要になるでしょう。

</Info>

## 多要素認証（MFA）

ユーザー資格情報の不正利用が史上最高を記録している現在、ハッカーによる身元情報の窃盗は頻発しており、システムを保護することは未だかつて無く困難になっています。最も効果的な方法は、アカウントを保護するために、ユーザーが第二要素を構成できるようにすることです。この方法は一般的に[多要素認証（MFA）](/ja-jp/secure/multi-factor-authentication)と呼ばれています。別のアプリケーションから漏洩してしまったユーザー名とパスワードが使われた場合でも、確実に権限のあるユーザー本人のみがアカウントにアクセスできるようになります。

<Info>
  ### ベストプラクティス

顧客向けアプリケーションでは、ユーザーに第二要素の追加を「強制」するのではなく、選択肢として提供することが非常に一般的です。詳細は、[「ユーザーにMFAを追加するオプションを提供する」](https://auth0.com/learn/multifactor-authentication-customers/)をご覧ください。

</Info>

Auth0は、MFAを有効化してユーザーアカウントのアクセスを保護するために、複数のオプションをサポートしてます。また、アクセスを制限する柔軟な第二要素が確実に提供できるように、以下のようないくつかの実践があります。

* Auth0 [Guardian](https://auth0.com/multifactor-authentication)：プッシュ通知の生成、そして、要求の許可と拒否を扱うアプリケーションを両方提供するサービスです。プッシュはユーザーの登録済みデバイス（一般的に携帯電話やタブレット）に通知を送信します。ユーザーはボタンを押すだけで、デバイスから即座にアカウントへのアクセスを許可または拒否することができます。
* 時間ベースのワンタイムパスワード（[TOTP](https://auth0.com/blog/from-theory-to-practice-adding-two-factor-to-node-dot-js/)）：デバイスでGoogle Authenticatorなどのアプリを利用して、一度限りのパスワードを生成します。生成されるパスワードは一定期間で切り替わり、ユーザーアカウントを検証する第二要素として入力することができます。
* SMS：SMSでワンタイムコードを送信します。ユーザーが認証を完了するには、このコードを入力する必要があります。
* 音声：電話での通話を使ってワンタイムコードを提供します。ユーザーが認証を完了するには、このコードを入力する必要があります。
* Duo：多要素認証にDuoアカウントを使用できるようにします。
* メール：多要素認証にメールアカウントを使用できるようにします。

GuardianやGoogle Authenticatorなどの技術を使ったMFAのワークフローは通常、携帯電話やタブレット上で実行される別のアプリケーションで提供されます。顧客に別のアプリケーションのダウンロードを求めたくない場合には、Auth0が提供している[SDK](https://auth0.com/blog/announcing-guardian-whitelabel-sdk/)を使って、既存のモバイルデバイスアプリケーション内に第二要素のワークフローを構築することができます。

## プロジェクト計画ガイド

当社では、PDF形式の計画ガイダンスを提供しています。ダウンロードして、推奨される戦略の詳細を参照してください。

[B2B IAM Project Planning Guide](//assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)

## 複数Organizationアーキテクチャ（マルチテナント機能）

B2Bプラットフォームの多くが顧客のOrganizationを何らかの形で分離・ブランディングし、これがIDおよびアクセス管理（IAM）システムをさらに複雑にしています。この問題でお困りであれば、当社がそのような環境に合ったガイダンスとベストプラクティスをご紹介していますので、時間を割いてお読みになることをお勧めします。

[複数Organizationアーキテクチャ](/ja-jp/get-started/architecture-scenarios/multiple-organization-architecture)