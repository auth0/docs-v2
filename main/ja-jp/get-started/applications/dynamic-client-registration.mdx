---
title: "動的なアプリケーション登録"
permalink: "dynamic-client-registration"
'description': "Management APIを使用してAuth0でアプリケーションを動的に登録する方法について説明します。"
'og:title': "動的なアプリケーション登録"
'og:description': "Management APIを使用してAuth0でアプリケーションを動的に登録する方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "動的なアプリケーション登録"
'twitter:description': "Management APIを使用してAuth0でアプリケーションを動的に登録する方法について説明します。"
---

テナントに対して、サードパーティーのアプリケーションを動的に登録することができます。この機能は、[OpenID Connect Dynamic Client Registrationの仕様](https://openid.net/specs/openid-connect-registration-1_0.html)に基づいています。

## 動的なクライアント登録を有効にする

<Warning>

Auth0は **オープンな動的登録** をサポートしています。つまり、この機能を有効にすると、 **誰でも** トークンなしでテナント内にアプリケーションを作成できるようになります。

</Warning>

デフォルトで、動的なアプリケーション登録はすべてのテナントで無効になっています。これを変更するには、テナントの設定で`enable_dynamic_client_registration`フラグを`true`に設定する必要があります。

このためには、[［Dashboard］>［Settings（設定）］>［Advanced（詳細）］](https://manage.auth0.com/#/tenant/advanced)の順に移動し、**［OIDC Dynamic Application Registration（OIDCの動的なアプリケーション登録）］** を有効にします。

または、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=management-api" tip="Management API: 顧客が管理タスクを実行できるようにするための製品。" cta="用語集の表示">Management API</Tooltip> [`/Tenant/patch_settings`](/ja-jp/api/management/v2#!/Tenants/patch_settings)エンドポイントを使用してこのフラグを更新することができます。

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/tenants/settings' \
  --header 'authorization: Bearer API2_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "flags": { "enable_dynamic_client_registration": true } }'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/tenants/settings");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer API2_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ \"flags\": { \"enable_dynamic_client_registration\": true } }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/tenants/settings"

	payload := strings.NewReader("{ \"flags\": { \"enable_dynamic_client_registration\": true } }")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer API2_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/tenants/settings")
  .header("content-type", "application/json")
  .header("authorization", "Bearer API2_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ \"flags\": { \"enable_dynamic_client_registration\": true } }")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/tenants/settings',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer API2_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {flags: {enable_dynamic_client_registration: true}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer API2_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"flags": @{ @"enable_dynamic_client_registration": @YES } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/tenants/settings"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/tenants/settings",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{ \"flags\": { \"enable_dynamic_client_registration\": true } }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer API2_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ \"flags\": { \"enable_dynamic_client_registration\": true } }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer API2_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/tenants/settings", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/tenants/settings")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer API2_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ \"flags\": { \"enable_dynamic_client_registration\": true } }"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer API2_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = ["flags": ["enable_dynamic_client_registration": true]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/tenants/settings")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

`update:tenant_settings`スコープを含む有効なトークンで、`API2_ACCESS_TOKEN`を更新する必要があります。詳細については、「[Management APIのアクセストークン](/ja-jp/secure/tokens/access-tokens/management-api-access-tokens)」をお読みください。

## 動的なクライアント登録を使用する

このセクションでは、どのようにアプリケーションを動的に登録し、設定することができるかをご紹介します。

### アプリケーションの登録を

Auth0でアプリケーションを動的に登録するには、HTTP `POST`メッセージをアプリケーション登録エンドポイント`https://{yourDomain}/oidc/register`に送信する必要があります。Auth0は **Open Dynamic Registration（オープンな動的登録）** に対応しており、エンドポイントはアクセストークンなしに登録要求を受け入れます。

「`My Dynamic application`」という名前で、コールバックURLが`https://application.example.com/callback`と`https://application.example.com/callback2`に指定されているアプリケーションを作成するには、以下のスニペットを使用します。

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/oidc/register' \
  --header 'content-type: application/json' \
  --data '{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/oidc/register");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oidc/register"

	payload := strings.NewReader("{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/oidc/register")
  .header("content-type", "application/json")
  .body("{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oidc/register',
  headers: {'content-type': 'application/json'},
  data: {
    client_name: 'My Dynamic Application',
    redirect_uris: [
      'https://application.example.com/callback',
      'https://application.example.com/callback2'
    ]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"client_name": @"My Dynamic Application",
                              @"redirect_uris": @[ @"https://application.example.com/callback", @"https://application.example.com/callback2" ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oidc/register"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/oidc/register",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "POST",
CURLOPT_POSTFIELDS => "{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}",
CURLOPT_HTTPHEADER => [
"content-type: application/json"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
```
```python Python lines
import http.client
conn = http.client.HTTPSConnection("")
payload = "{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}"
headers = { 'content-type': "application/json" }
conn.request("POST", "/{yourDomain}/oidc/register", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/oidc/register")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request.body = "{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}"
response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation
let headers = ["content-type": "application/json"]
let parameters = [
"client_name": "My Dynamic Application",
"redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]
] as [String : Any]
let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oidc/register")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</CodeGroup>

ここでは、

* **client_name** ：作成するDynamic Application（動的アプリケーション）の名前
* **redirect_uris** （必須）：Auth0が認証フローの終了時に呼び出すのに有効であるとみなすURLの配列

または、`token_endpoint_auth_method`の値を設定することができます。これは、`none`または`client_secret_post`（デフォルト値）のいずれかで指定します。SPAを作成する場合、要求のペイロードで`token_endpoint_auth_method: none`を使用します。

応答には基本的なアプリケーション情報が含まれます。

```json lines
HTTP/1.1 201 Created
Content-Type: application/json
{
  "client_name": "My Dynamic Application",
  "client_id": "8SXWY6j3afl2CP5ntwEOpMdPxxy49Gt2",
  "client_secret": "Q5O...33P",
  "redirect_uris": [
    "https://application.example.com/callback",
    "https://application.example.com/callback2"
  ],
  "client_secret_expires_at": 0
}
```

ここでは、

* **client_id** ：一意のクライアント識別子。アプリケーションでAuth0を使用するよう構成するときに使用するIDです。これはシステムで生成され、変更することはできません。
* **client_secret** ：英数字の64ビットのクライアントシークレット。Authentication API [`/token`](/ja-jp/api/authentication#get-token)への認証と、IDトークンの検証にアプリケーションで使用される値です。
* **client_secret_expires_at** ：`client_secret`が期限切れする時刻。Auth0では、この値は常にゼロ（`0`）で、アプリケーションが期限切れになることはありません。

クライアントIDとクライアントシークレットは、認証および認証フローの実行に最も重要な要素であるため、メモしておいてください。詳細については、「[認証フローと認可フロー](/ja-jp/get-started/authentication-and-authorization-flow)」をお読みください。

さらに、サードパーティーの開発者がアプリケーション設定を変更することはできないことに留意します。必要な場合は、その要求に関して、テナント所有者に問い合わせる必要があります。

### アプリケーションを構成する

クライアントIDとシークレットが揃ったら、Auth0でユーザー認証を行うためにアプリケーションを構成することができます。

簡単なサンプルを通じて、[暗黙的フロー](/ja-jp/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)を使用してクライアント側のWebアプリからAPIを呼び出す方法をご紹介します。

まず、ユーザーを認可URLに送信するようにアプリケーションを構成する必要があります。

``` lines
https://{yourDomain}/authorize?
  audience={API_AUDIENCE}&
  scope={SCOPE}&
  response_type={RESPONSE_TYPE}&
  client_id={yourClientId}&
  redirect_uri={https://yourApp/callback}&
  nonce={NONCE}
  state={OPAQUE_VALUE}
```

ここでは、

* **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-6" href="/ja-jp/glossary?term=audience" tip="オーディエンス: 発行されたトークンに対するオーディエンスを表す一意の識別子。トークンでaudという名前が付けられ、その値にはIDトークンの場合はアプリケーション（Client ID）、アクセストークンの場合はAPI（API Identifier）のいずれかのIDが含まれます。" cta="用語集の表示">audience</Tooltip>**（任意）：アプリケーションがユーザーに代わってアクセスを要求しているターゲットAPI。APIアクセスが必要な場合、このパラメーターを設定します。
* **scope**（任意）：認可を要求したいスコープ。スペースで区切る必要があります。ユーザーの[標準OIDCスコープ](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)（`profile`や`email`など）、名前空間の形式に準拠しなければならないカスタムクレーム、またはターゲットAPIでサポートされているスコープ（`read:contacts`など）を要求することができます。APIアクセスが必要な場合、このパラメーターを設定します。詳細については、「[APIスコープ](/ja-jp/get-started/apis/scopes/api-scopes)」をお読みください。
* **response_type**：応答タイプ。暗黙的な付与の場合、`token`または`id_token token`を使用することができます。これで、フローの終了時に受け取るトークンの種類が指定されます。`token`を使用してアクセストークンのみを取得するか、`id_token token`を使用してIDトークンとアクセストークンの両方を取得します。
* **client_id**：アプリケーションのクライアントID
* **redirect_uri**：認可がユーザーによって付与された後、認可サーバー（Auth0）がユーザーエージェント（ブラウザー）をリダイレクトするURL。アクセストークン（および任意でIDトークン）は、このURLのハッシュフラグメントで使用することができます。このURLは、アプリケーションの **［Application Settings（アプリケーション設定）］** で有効なコールバックURLとして指定される必要があります。
* **state**：アプリケーションにリダイレクトするときに認可サーバーに含まれる初期要求にアプリケーションが追加する不透明な値。この値は、CSRF攻撃を防ぐためににアプリケーションで使用される必要があります。
* **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/ja-jp/glossary?term=nonce" tip="Nonce: リプレイ攻撃を検出および防止するために、認証プロトコルで1回だけ発行される任意の数値。" cta="用語集の表示">nonce</Tooltip>**：Auth0からのIDトークンの要求に含まれる文字列値で、トークンのリプレイ攻撃を防ぐのに使用されます。`response_type=id_token token`に必要です。

例：

```html lines
<a href="https://{yourDomain}/authorize?scope=appointments%20contacts&audience=appointments:api&response_type=id_token%20token&client_id={yourClientId}&redirect_uri={https://yourApp/callback}">
  Sign In
</a>
```

この呼び出しによってユーザーはAuth0にリダイレクトされ、認証に成功すると、アプリケーションに戻ります（具体的には**redirect_uri** にリダイレクトされます）。

APIアクセスを必要とする場合は、認証後にURLのハッシュフラグメントからアクセストークンを抽出し、これを使ってAPIへのを呼び出しを行う必要があります。そのためには、アクセストークンをHTTP要求の`Authorization`ヘッダーで`Bearer`トークンとして渡します。

## もっと詳しく

* [ファーストパーティーアプリケーションとサードパーティーアプリケーション](/ja-jp/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)
* [ユーザーの同意とサードパーティアプリケーション](/ja-jp/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications)